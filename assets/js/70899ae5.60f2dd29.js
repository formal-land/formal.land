"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2323],{8534:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=n(4848),o=n(8453);const a={title:"\ud83e\ude81 Enhancements to coq-of-solidity \u2013 1",tags:["Solidity","monad","effects","Yul","loops","mutations"],authors:[]},s=void 0,l={permalink:"/blog/2024/10/16/coq-of-solidity-enhanced-version-1",source:"@site/blog/2024-10-16-coq-of-solidity-enhanced-version-1.md",title:"\ud83e\ude81 Enhancements to coq-of-solidity \u2013 1",description:"We present improvements we made to our tool coq-of-solidity to formally verify Solidity smart contracts for any advanced properties, relying on the proof assistant \ud83d\udc13&nbsp;Coq. The idea is to be able to prove the full absence of bugs&nbsp;\u2728 in very complex contracts, like L1 verifiers for zero-knowledge L2s&nbsp;\ud83d\udd75\ufe0f, or contracts with very large amounts of money&nbsp;\ud83d\udcb0 (in the billions).",date:"2024-10-16T00:00:00.000Z",formattedDate:"October 16, 2024",tags:[{label:"Solidity",permalink:"/blog/tags/solidity"},{label:"monad",permalink:"/blog/tags/monad"},{label:"effects",permalink:"/blog/tags/effects"},{label:"Yul",permalink:"/blog/tags/yul"},{label:"loops",permalink:"/blog/tags/loops"},{label:"mutations",permalink:"/blog/tags/mutations"}],readingTime:8.82,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\ude81 Enhancements to coq-of-solidity \u2013 1",tags:["Solidity","monad","effects","Yul","loops","mutations"],authors:[]},unlisted:!1,prevItem:{title:"\u2688 Verification of the Smoo.th library \u2013 1",permalink:"/blog/2024/10/21/verification-smooth-library-1"},nextItem:{title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 3",permalink:"/blog/2024/10/15/verification-move-sui-type-checker-3"}},r={authorsImageUrls:[]},c=[{value:"\ud83e\udde8 The issue",id:"-the-issue",level:2},{value:"Why is it important?",id:"why-is-it-important",level:2},{value:"The solution",id:"the-solution",level:2},{value:"\ud83c\udfd7\ufe0f The tool",id:"\ufe0f-the-tool",level:3},{value:"\ud83d\udd0d Example",id:"-example",level:3},{value:"\ud83d\udd2e Monad",id:"-monad",level:3},{value:"Application",id:"application",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["We present improvements we made to our tool ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-solidity",children:"coq-of-solidity"})," to formally verify ",(0,i.jsx)(t.a,{href:"https://soliditylang.org/",children:"Solidity"})," smart contracts for any advanced properties, relying on the proof assistant ",(0,i.jsx)(t.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),". The idea is to be able to prove the ",(0,i.jsx)(t.strong,{children:"full absence of bugs\xa0\u2728"})," in ",(0,i.jsx)(t.strong,{children:"very complex contracts"}),", like L1 verifiers for ",(0,i.jsx)(t.strong,{children:"zero-knowledge L2s\xa0\ud83d\udd75\ufe0f"}),", or contracts with ",(0,i.jsx)(t.strong,{children:"very large amounts of money\xa0\ud83d\udcb0"})," (in the billions)."]}),"\n",(0,i.jsxs)(t.p,{children:["In this blog post, we present how we developed an effect inference mechanism to translate optimized ",(0,i.jsx)(t.a,{href:"https://docs.soliditylang.org/en/latest/yul.html",children:"Yul"})," code combining variable mutations and control flow with loops and nested premature returns (",(0,i.jsx)(t.code,{children:"break"}),", ",(0,i.jsx)(t.code,{children:"continue"}),", and ",(0,i.jsx)(t.code,{children:"leave"}),") to a clean\xa0\ud83e\uddfc purely functional representation in the proof system Coq."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["We will be talking about this work at the ",(0,i.jsx)(t.a,{href:"https://lu.ma/encode-london-24",children:"Encode London Conference"})," on Friday, October 25, 2024\xa0\ud83d\udce2."]})}),"\n",(0,i.jsxs)(t.admonition,{title:"Get started",type:"success",children:[(0,i.jsxs)(t.p,{children:["To ensure your code is secure today, contact us at\xa0",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udce7contact@formal.land"}),"!\xa0\ud83d\ude80"]}),(0,i.jsx)(t.p,{children:"Formal verification goes further than traditional audits to make 100% sure you cannot lose your funds. It can be integrated into your CI pipeline to make sure that every commit is correct without running a full audit again."}),(0,i.jsxs)(t.p,{children:["We make bugs such as the ",(0,i.jsx)(t.a,{href:"https://www.gemini.com/fr-fr/cryptopedia/the-dao-hack-makerdao",children:"DAO hack"})," ($60 million stolen) virtually impossible to happen again."]})]}),"\n",(0,i.jsx)("figure",{children:(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Frozen Solidity rock",src:n(7697).A+"",width:"1024",height:"1024"})})}),"\n",(0,i.jsx)(t.h2,{id:"-the-issue",children:"\ud83e\udde8 The issue"}),"\n",(0,i.jsxs)(t.p,{children:["Yul is the intermediate language of the Solidity compiler that we translate to the Coq proof system to formally verify properties of smart contracts. The issue is that it has slightly different behaviors than the Coq language. In particular, it allows for variable mutations and imperative loops (",(0,i.jsx)(t.code,{children:"for"})," loops) with premature exits that have no native equivalents in purely functional languages like the ones used for formal verification."]}),"\n",(0,i.jsx)(t.p,{children:"Here is a short example of Yul code that is impossible to translate to Coq as it is:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:"function rugby() -> x {\n  let i := 0\n  x := 0\n  for { } lt(i, 10) { i := add(i, 1) } {\n      x := add(x, i)\n      if eq(i, 5) {\n          leave\n      }\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It uses the variable ",(0,i.jsx)(t.code,{children:"x"})," to store the sum of the increasing sequence of integers ",(0,i.jsx)(t.code,{children:"1"}),", ",(0,i.jsx)(t.code,{children:"2"}),", ",(0,i.jsx)(t.code,{children:"3"}),", ... but prematurely stops the loop when ",(0,i.jsx)(t.code,{children:"i"})," reaches ",(0,i.jsx)(t.code,{children:"5"})," and returns the final value of ",(0,i.jsx)(t.code,{children:"x"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"To represent this code in a purely functional language, we need to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Make explicit the fact that we operate on a local state, that is to say, the couple of the two variables ",(0,i.jsx)(t.code,{children:"i"})," and ",(0,i.jsx)(t.code,{children:"x"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Represent the control flow of the loop, which repeats its body until the condition ",(0,i.jsx)(t.code,{children:"eq(i, 5)"})," is satisfied and then bubbles up to the body of the function to return the final result\xa0",(0,i.jsx)(t.code,{children:"x"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"why-is-it-important",children:"Why is it important?"}),"\n",(0,i.jsx)(t.p,{children:"Having a purely functional representation of the Yul code is important as verifying functional programs is easier than verifying imperative ones, especially in the case of a system like Coq that is based on functional programming even at the logical level."}),"\n",(0,i.jsx)(t.p,{children:"Ideally, such a translation should be done automatically so that we are not at risk of making mistakes and can focus our time on the verification work. This would allow to more efficiently formally verify properties of smart contracts or similar imperative programs. Not that in Yul, in addition to mutations on variables, there are also mutations on the contract's memory and storage, which we do not cover here."}),"\n",(0,i.jsx)(t.h2,{id:"the-solution",children:"The solution"}),"\n",(0,i.jsx)(t.p,{children:"Our solution is a tool that does an effect inference on the Yul code to determine which variables might be mutated at each point of the program, and then propagates the results in the two cases where the execution continues to the next instruction and the case where it bubbles up."}),"\n",(0,i.jsx)(t.h3,{id:"\ufe0f-the-tool",children:"\ud83c\udfd7\ufe0f The tool"}),"\n",(0,i.jsxs)(t.p,{children:["We wrote our tool in \ud83d\udc0d\xa0Python, for ease of development, parsing the Yul code from the JSON output of the Solidity compiler and outputting a Coq file that represents the functional version of the code. Yul is a rather pleasant language, optimized for formal verification and with very few constructs. Our code is available on our GitHub repository ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-solidity",children:"github.com/formal-land/coq-of-solidity"}),", in a pull request that is about to be merged."]}),"\n",(0,i.jsx)(t.p,{children:"Here is the header of our main Python function, which translates Yul statements to Coq:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"def statement_to_coq(node) -> tuple[Callable[[set[str]], str], set[str], set[str]]:\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It takes a JSON ",(0,i.jsx)(t.code,{children:"node"})," corresponding to a statement (assignment, ",(0,i.jsx)(t.code,{children:"if"}),", ",(0,i.jsx)(t.code,{children:"for"}),", ",(0,i.jsx)(t.code,{children:"leave"}),", ...) and returns a triple with:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"A function that takes the yet-to-be-determined mutated variables in the surrounding block and returns the Coq code of the statement."}),"\n",(0,i.jsx)(t.li,{children:"The set of newly declared variables."}),"\n",(0,i.jsx)(t.li,{children:"The set of mutated variables."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"From these information we can infer the variables that are mutated at each point of the program and propagate them."}),"\n",(0,i.jsx)(t.h3,{id:"-example",children:"\ud83d\udd0d Example"}),"\n",(0,i.jsxs)(t.p,{children:["As an example, here is the generated Coq translation of our \ud83c\udfc9\xa0",(0,i.jsx)(t.code,{children:"rugby"})," example above:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",metastring:"showLineNumbers",children:"Definition rugby : M.t U256.t :=\n  let~ '(_, result) :=\n    let~ i := [[ 0 ]] in\n    let~ x := [[ 0 ]] in\n    let_state~ '(i, x) :=\n      (* for loop *)\n      Shallow.for_\n        (* init state *)\n        (i, x)\n        (* condition *)\n        (fun '(i, x) => [[\n          lt ~(| i, 10 |)\n        ]])\n        (* body *)\n        (fun '(i, x) =>\n          Shallow.lift_state_update\n            (fun x => (i, x))\n            (let~ x := [[ add ~(| x, i |) ]] in\n            let_state~ 'tt := [[\n              Shallow.if_ (|\n                eq ~(| i, 5 |),\n                M.pure (BlockUnit.Leave, tt),\n                tt\n              |)\n            ]] default~ x in\n            M.pure (BlockUnit.Tt, x)))\n        (* post *)\n        (fun '(i, x) =>\n          Shallow.lift_state_update\n            (fun i => (i, x))\n            (let~ i := [[ add ~(| i, 1 |) ]] in\n            M.pure (BlockUnit.Tt, i)))\n    default~ x in\n    M.pure (BlockUnit.Tt, x)\n  in\n  M.pure result.\n"})}),"\n",(0,i.jsxs)(t.p,{children:["On lines ",(0,i.jsx)(t.code,{children:"3"})," and ",(0,i.jsx)(t.code,{children:"4"})," we see that we use normal ",(0,i.jsx)(t.code,{children:"let"})," declarations for the variables ",(0,i.jsx)(t.code,{children:"i"})," and ",(0,i.jsx)(t.code,{children:"x"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"let~ i := [[ 0 ]] in\nlet~ x := [[ 0 ]] in\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The notation\xa0",(0,i.jsx)(t.code,{children:"let~"})," is a monadic notation to represent the side-effects of the EVM (storage updates, contract calls, ...) but the variables ",(0,i.jsx)(t.code,{children:"i"})," and ",(0,i.jsx)(t.code,{children:"x"})," are plain Coq variables, what will facilitate the formal verification process later."]}),"\n",(0,i.jsxs)(t.p,{children:["In line\xa0",(0,i.jsx)(t.code,{children:"5"}),", we see that we consider the ",(0,i.jsx)(t.code,{children:"for"})," loop to have a two-variable state ",(0,i.jsx)(t.code,{children:"(i, x)"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"let_state~ '(i, x) :=\n  (* for loop *)\n  Shallow.for_\n    (* init state *)\n    (i, x)\n"})}),"\n",(0,i.jsx)(t.p,{children:"The condition depends on the whole state, even if it only uses a part of it:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"(* condition *)\n(fun '(i, x) => [[\n  lt ~(| i, 10 |)\n]])\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The body is more interesting. We only modify the variable ",(0,i.jsx)(t.code,{children:"x"})," but we need to read and return the whole state ",(0,i.jsx)(t.code,{children:"(i, x)"}),", so we start with a lift operation:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"(* body *)\n(fun '(i, x) =>\n  Shallow.lift_state_update\n    (fun x => (i, x))\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Then we update the variable ",(0,i.jsx)(t.code,{children:"x"})," with a standard variable declaration as if the variable was immutable:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"(let~ x := [[ add ~(| x, i |) ]] in\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The updated value of the variable ",(0,i.jsx)(t.code,{children:"x"})," is propagated at the end of the body:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"M.pure (BlockUnit.Tt, x)))\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is how we translate the inner\xa0",(0,i.jsx)(t.code,{children:"if"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"let_state~ 'tt := [[\n  Shallow.if_ (|\n    eq ~(| i, 5 |),\n    M.pure (BlockUnit.Leave, tt),\n    tt\n  |)\n]] default~ x in\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If the condition is satisfied, we return the special value ",(0,i.jsx)(t.code,{children:"BlockUnit.Leave"})," that will be interpreted as a premature exit of the function and activate the bubble-up mechanism. The associated state is the special empty value\xa0",(0,i.jsx)(t.code,{children:"tt"})," as there are no mutations in the ",(0,i.jsx)(t.code,{children:"if"})," statement. We use\xa0",(0,i.jsx)(t.code,{children:"default~ x"})," at the next line to say that we complete the\xa0",(0,i.jsx)(t.code,{children:"tt"})," state with the value ",(0,i.jsx)(t.code,{children:"x"})," if we are bubbling up."]}),"\n",(0,i.jsxs)(t.p,{children:["The binding of the expression of ",(0,i.jsx)(t.code,{children:"default~"})," is done after the ",(0,i.jsx)(t.code,{children:"let_state~"})," to be able to retrieve parts of the state that might have been modified, if needed. This is, for example, the case for the ",(0,i.jsx)(t.code,{children:"for"})," loop where we say that we first get the values of the two variables ",(0,i.jsx)(t.code,{children:"i"})," and ",(0,i.jsx)(t.code,{children:"x"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"let_state~ '(i, x) :=\n  (* for loop *)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["and then propagate only the state ",(0,i.jsx)(t.code,{children:"x"})," in case of a premature exit:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"default~ x in\n"})}),"\n",(0,i.jsxs)(t.p,{children:["at the line\xa0",(0,i.jsx)(t.code,{children:"33"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"-monad",children:"\ud83d\udd2e Monad"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Monad_(functional_programming)",children:"monad"})," we use to represent the bubble-up mechanism is the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Module Shallow.\n  Definition t (State : Set) : Set :=\n    M.t (BlockUnit.t * State).\n"})}),"\n",(0,i.jsx)(t.p,{children:"where:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"M.t"})," is the monad representing the side-effects of the EVM,"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"BlockUnit.t"})," is a type representing the different modes of the bubble-up mechanism: no bubble-up, or a bubble-up with a ",(0,i.jsx)(t.code,{children:"break"}),", ",(0,i.jsx)(t.code,{children:"continue"}),", or ",(0,i.jsx)(t.code,{children:"leave"})," instruction,"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"State"})," is the type of the current state that we might be writing to."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We define the notation ",(0,i.jsx)(t.code,{children:"let_state~ ... default~ ... in"})," with:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Notation \"'let_state~' pattern ':=' e 'default~' state 'in' k\" :=\n  (let_state e (fun pattern => (state, k)))\n"})}),"\n",(0,i.jsx)(t.p,{children:"and the function:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coq",children:"Definition let_state {State1 State2 : Set}\n    (expression : t State1) (body : State1 -> State2 * t State2) :\n    t State2 :=\n  M.strong_let_ expression (fun value =>\n  let '(mode, state1) := value in\n  match mode with\n  (* no bubble-up, do not use the default state *)\n  | BlockUnit.Tt => snd (body state1)\n  (* bubble-up, use the default state and keep the same bubble-up mode *)\n  | _ => M.pure (mode, fst (body state1))\n  end).\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can also look at the definitions of the ",(0,i.jsx)(t.code,{children:"Shallow.if_"})," and ",(0,i.jsx)(t.code,{children:"Shallow.for_"})," functions in our code. For loops, we use a non-termination effect of the underlying monad ",(0,i.jsx)(t.code,{children:"M.t"}),". This is because loops can be infinite, and this is not allowed in Coq."]}),"\n",(0,i.jsx)(t.h2,{id:"application",children:"Application"}),"\n",(0,i.jsx)(t.p,{children:"We are using the new translation above to formally verify the implementation of a hand-optimized Yul code using loops and mutations to implement cryptographic operations in an efficient way. We believe that this translation would work as well for any other examples of Yul code, enabling the formal verification of arbitrary Solidity or Yul code in a more functional way."}),"\n",(0,i.jsx)(t.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"We have show how we can automatically translate arbitrary Yul code in a purely functional form\xa0\ud83c\udf1f, excluding mutations of the memory and the storage, in order to simplify further formal verification operations\xa0\ud83d\ude42."}),"\n",(0,i.jsx)(t.p,{children:"A work left to be done is to prove that this transformation is correct, showing it equivalent to our initial and simpler Yul semantics where variables are represented as string keys in a map. We believe this is possible by generating a proof on a case-by-case basis for each transformed program, working by unification and exploring all the branches. But this remains to be done."}),"\n",(0,i.jsx)(t.admonition,{title:"For more",type:"success",children:(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["Follow us on ",(0,i.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,i.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"}),", or comment on this post below! Feel free to DM us for any formal verification services you need."]})})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},7697:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/frozen-solidity-94e895e01bbf2d7001331e17b3481197.webp"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);