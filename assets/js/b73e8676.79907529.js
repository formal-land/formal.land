"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[383],{6586:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=t(4848),i=t(8453);const o={id:"links",title:"Links"},r=void 0,a={id:"tools/coq-of-rust/links",title:"Links",description:'The "links" phase is the first refinement step we do in order to simplify the code generated by coq-of-rust and to give it a semantics.',source:"@site/docs/tools/coq-of-rust/links.md",sourceDirName:"tools/coq-of-rust",slug:"/tools/coq-of-rust/links",permalink:"/docs/tools/coq-of-rust/links",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"links",title:"Links"},sidebar:"sidebar",previous:{title:"Revm Project",permalink:"/docs/tools/coq-of-rust/revm-project"},next:{title:"\ud83e\ude81 coq-of-solidity",permalink:"/docs/tools/coq-of-solidity/introduction"}},l={},c=[{value:"Link class",id:"link-class",level:2},{value:"Link helpers",id:"link-helpers",level:3},{value:"Sub-pointer helpers",id:"sub-pointer-helpers",level:3},{value:"Expressions",id:"expressions",level:2},{value:"Predicates",id:"predicates",level:3},{value:"Functions",id:"functions",level:3},{value:"Traits",id:"traits",level:2},{value:"Definition",id:"definition",level:3},{value:"Instances",id:"instances",level:3},{value:"Associated types",id:"associated-types",level:3}];function d(e){const n={a:"a",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",math:"math",mi:"mi",mn:"mn",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:['The "links" phase is the first refinement step we do in order to simplify the code generated by ',(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," and to give it a semantics."]}),"\n",(0,s.jsxs)(n.p,{children:["The main idea is to add back typing and handle naming/trait resolution. These steps are already done by the Rust compiler, but do not translate these information to Rocq with ",(0,s.jsx)(n.code,{children:"coq-of-rust"})," as we have not found a reliable way to do so. An example of complexity is the handling of mutually dependent functions or types, that are hard to represent in a formal system such as Rocq. By letting the user do the work, we can have handle more case (in particular, having a translation of the ",(0,s.jsx)(n.code,{children:"core"})," library that type-checks), at the expense of more complexity for the user."]}),"\n",(0,s.jsxs)(n.p,{children:['On this page we aim to summarize the conventions we follow to define the "links" refinements. A large part of it is automated in tactics, and the rest that is very verbose can be handled by AI autocomplete rather well. You can look at the file ',(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/links/gas.v",children:"revm/revm_interpreter/links/gas.v"})," for a reference example."]}),"\n",(0,s.jsx)(n.h2,{id:"link-class",children:"Link class"}),"\n",(0,s.jsxs)(n.p,{children:["The main file for links definitions is ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/links/M.v",children:"links/M.v"}),". The type-class for links on types is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Class Link (A : Set) : Set := {\n  \u03a6 : Ty.t;\n  \u03c6 : A -> Value.t;\n}.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This defines, for a Rocq type ",(0,s.jsx)(n.code,{children:"A"}),", how it maps to a translated Rust type for two components:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ty.t"})," which is the descriptor of the type, used for the resolution of trait instances or associated functions,"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Value.t"})," which are the translated values of the type."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here is as an example the definition for the boolean type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'Global Instance IsLink : Link bool := {\n  \u03a6 := Ty.path "bool";\n  \u03c6 b := Value.Bool b;\n}.\n'})}),"\n",(0,s.jsx)(n.p,{children:"For the result type, which is an example of polymorphic type, we have:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'Module Result.\n  Inductive t (T E : Set) : Set :=\n  | Ok : T -> t\n  | Err : E -> t.\n  Arguments Ok {_ _}.\n  Arguments Err {_ _}.\n\n  Global Instance IsLink (T E : Set) `{Link T} `{Link E} : Link (t T E) := {\n    \u03a6 := Ty.apply (Ty.path "core::result::Result") [] [\u03a6 T; \u03a6 E];\n    \u03c6 x :=\n      match x with\n      | Ok x => Value.StructTuple "core::result::Result::Ok" [\u03c6 x]\n      | Err x => Value.StructTuple "core::result::Result::Err" [\u03c6 x]\n      end;\n  }.\nEnd Result.\n'})}),"\n",(0,s.jsx)(n.p,{children:"A few remarks:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We set the link ",(0,s.jsx)(n.code,{children:"Instance"})," as ",(0,s.jsx)(n.code,{children:"Global"})," instead of ",(0,s.jsx)(n.em,{children:"export"})," for now for ease of use."]}),"\n",(0,s.jsxs)(n.li,{children:["We only have a function from the link types to the base definitions ",(0,s.jsx)(n.code,{children:"Ty.t"})," and ",(0,s.jsx)(n.code,{children:"Value.t"}),". We think that it would be hard to define a function that goes in the other direction, as for example it would need to be global from the start and make composition more complex."]}),"\n",(0,s.jsxs)(n.li,{children:["The type descriptor for generic types is ",(0,s.jsx)(n.code,{children:"Ty.apply"})," with the path of the type and the list of constant arguments (that are values) and the list of type arguments (that are other type descriptors)."]}),"\n",(0,s.jsxs)(n.li,{children:["Names generated by ",(0,s.jsx)(n.code,{children:"coq-of-rust"})," as strings are always unique and global. This is one of the nice things provided by the Rust compiler."]}),"\n",(0,s.jsxs)(n.li,{children:["We have some conventions to represent Rust values in ",(0,s.jsx)(n.code,{children:"Value.t"}),". You can see the complete definition in ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/M.v",children:"M.v"}),":","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Module Value.\n  Inductive t : Set :=\n  | Bool : bool -> t\n  | Integer (kind : IntegerKind.t) (z : Z) : t\n  (** For now we do not know how to represent floats so we use a string *)\n  | Float : string -> t\n  | UnicodeChar : Z -> t\n  | String : string -> t\n  | Tuple : list t -> t\n  | Array : list t -> t\n  | StructRecord : string -> list (string * t) -> t\n  | StructTuple : string -> list t -> t\n  | Pointer : Pointer.t t -> t\n  (** The two existential types of the closure must be [Value.t] and [M]. We\n      cannot enforce this constraint there yet, but we will do when defining the\n      semantics. *)\n  | Closure : {'(Value, M) : (Set * Set) @ list Value -> M} -> t\n  (** A special value that does not appear in the translation, but that we use\n      to implement primitive functions over values that are not total. We\n      statically know, from the fact that the source Rust code is well-typed,\n      that these error values are impossible. In these values appear in a proof,\n      this might indicate invalid pre-conditions or mistakes in the translation\n      to Rocq. *)\n  | Error (message : string)\n  (** To implement the ability to declare a variable but not give it a value\n      yet. *)\n  | DeclaredButUndefined.\nEnd Value.\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"link-helpers",children:"Link helpers"}),"\n",(0,s.jsx)(n.p,{children:"When we define links, we also add three kinds of operations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"of_ty"})," to convert a type descriptor back to a Rocq type;"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"of_value_with"})," to convert a value back to a Rocq value knowing the expected type;"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"of_value"})," to convert a value back to a Rocq value without knowing the expected type."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here is the example for the boolean type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'Definition of_ty : OfTy.t (Ty.path "bool").\nProof. eapply OfTy.Make with (A := bool); reflexivity. Defined.\nSmpl Add apply of_ty : of_ty.\n\nLemma of_value_with (b : bool) :\n  Value.Bool b = \u03c6 b.\nProof. reflexivity. Qed.\nSmpl Add apply of_value_with : of_value.\n\nDefinition of_value (b : bool) :\n  OfValue.t (Value.Bool b).\nProof.\n  eapply OfValue.Make with (A := bool); smpl of_value.\nDefined.\nSmpl Add apply of_value : of_value.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here is the example for a ",(0,s.jsx)(n.code,{children:"struct"})," type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'(*\npub struct MemoryGas {\n    pub words_num: usize,\n    pub expansion_cost: u64,\n}\n*)\nModule MemoryGas.\n  Record t : Set := {\n    words_num : Usize.t;\n    expansion_cost : U64.t;\n  }.\n\n  Global Instance IsLink : Link t := {\n    \u03a6 := Ty.path "revm_interpreter::gas::MemoryGas";\n    \u03c6 x :=\n      Value.StructRecord "revm_interpreter::gas::MemoryGas" [\n        ("words_num", \u03c6 x.(words_num));\n        ("expansion_cost", \u03c6 x.(expansion_cost))\n      ];\n  }.\n\n  Definition of_ty : OfTy.t (Ty.path "revm_interpreter::gas::MemoryGas").\n  Proof. eapply OfTy.Make with (A := t); reflexivity. Defined.\n  Smpl Add apply of_ty : of_ty.\n\n  Lemma of_value_with words_num words_num\' expansion_cost expansion_cost\' :\n    words_num\' = \u03c6 words_num ->\n    expansion_cost\' = \u03c6 expansion_cost ->\n    Value.StructRecord "revm_interpreter::gas::MemoryGas" [\n      ("words_num", words_num\');\n      ("expansion_cost", expansion_cost\')\n    ] = \u03c6 (Build_t words_num expansion_cost).\n  Proof. now intros; subst. Qed.\n  Smpl Add apply of_value_with : of_value.\n\n  Definition of_value (words_num : Usize.t) words_num\' (expansion_cost : U64.t) expansion_cost\' :\n    words_num\' = \u03c6 words_num ->\n    expansion_cost\' = \u03c6 expansion_cost ->\n    OfValue.t (\n      Value.StructRecord "revm_interpreter::gas::MemoryGas" [\n        ("words_num", words_num\');\n        ("expansion_cost", expansion_cost\')\n      ]\n    ).\n  Proof. econstructor; apply of_value_with; eassumption. Defined.\n  Smpl Add apply of_value : of_value.\nEnd MemoryGas.\n'})}),"\n",(0,s.jsx)(n.p,{children:"A few notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We use the ",(0,s.jsx)(n.code,{children:"Smpl"})," tactic to add the conversion to the database ",(0,s.jsx)(n.code,{children:"of_ty"})," or ",(0,s.jsx)(n.code,{children:"of_value"})," of the ",(0,s.jsx)(n.code,{children:"smpl"})," tactic. This is a tactic that tries to apply all the conversion rules in the database, what will be useful later in the proofs. We could also use type-classes for it, and it may be more efficient, especially as type-classes have a mechanism to control which hints are available in the current context (with the default ",(0,s.jsx)(n.em,{children:"export"})," visibility of instances)."]}),"\n",(0,s.jsx)(n.li,{children:"These definitions are very verbose but can be efficiently generated by AI autocomplete. We also a Python script to generate them that helps us sometimes, but it not complete yet."}),"\n",(0,s.jsx)(n.li,{children:"Most of the definitions are straightforward, but some might need a custom solutions, especially if the type has some mutual dependencies with other types."}),"\n",(0,s.jsxs)(n.li,{children:["Some cases are still unclear. For example, how to handle the ",(0,s.jsx)(n.code,{children:"None"})," constructor as it can be used for ",(0,s.jsx)(n.code,{children:"Option<A>"})," for any ",(0,s.jsx)(n.code,{children:"A"}),"? For now, we have no automation for this case. It will probably require generating more annotation in the translated Rust code, to make explicit the type of constructors."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sub-pointer-helpers",children:"Sub-pointer helpers"}),"\n",(0,s.jsxs)(n.p,{children:["Computing pointers to structure fields or, in a functional programming vocabulary, lens to fields of structures is an important part of our work. For each datatype which has a notion of fields, we define a module with all the possible lens functions and a proof that they are correct, meaning compatible with how sub-fields are computed on the Rust translation. If we take the ",(0,s.jsx)(n.code,{children:"MemoryGas.t"})," example from above, we get:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'Module SubPointer.\n  Definition get_words_num : SubPointer.Runner.t t\n    (Pointer.Index.StructRecord "revm_interpreter::gas::MemoryGas" "words_num") :=\n  {|\n    SubPointer.Runner.projection x := Some x.(words_num);\n    SubPointer.Runner.injection x y := Some (x <| words_num := y |>);\n  |}.\n\n  Lemma get_words_num_is_valid :\n    SubPointer.Runner.Valid.t get_words_num.\n  Proof.\n    now constructor.\n  Qed.\n  Smpl Add apply get_words_num_is_valid : run_sub_pointer.\n\n  Definition get_expansion_cost : SubPointer.Runner.t t\n    (Pointer.Index.StructRecord "revm_interpreter::gas::MemoryGas" "expansion_cost") :=\n  {|\n    SubPointer.Runner.projection x := Some x.(expansion_cost);\n    SubPointer.Runner.injection x y := Some (x <| expansion_cost := y |>);\n  |}.\n\n  Lemma get_expansion_cost_is_valid :\n    SubPointer.Runner.Valid.t get_expansion_cost.\n  Proof.\n    now constructor.\n  Qed.\n  Smpl Add apply get_expansion_cost_is_valid : run_sub_pointer.\nEnd SubPointer.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The sub-pointer definition is a lens annotated by an index generated in the Rust translation. They are also added to an ",(0,s.jsx)(n.code,{children:"Smpl"})," database in order to be used automatically later in the proofs."]}),"\n",(0,s.jsx)(n.h2,{id:"expressions",children:"Expressions"}),"\n",(0,s.jsx)(n.p,{children:"Now that we have seen how to define link structures for types and values, we are to going to see how we make these definitions for expressions. To be able to understand what is going on and debug cases that might fail, it is interesting to look at:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The definition of the monad ",(0,s.jsx)(n.code,{children:"M"})," that we use to represent expressions with side-effects in the Rocq translation. This is defined in ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/M.v",children:"M.v"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The definition of the inductive rules ",(0,s.jsx)(n.code,{children:"Run.t"})," to add typing and name/trait resolution in ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/links/M.v",children:"links/M.v"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The definition of the tactic ",(0,s.jsx)(n.code,{children:"run_symbolic"})," also in  ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/links/M.v",children:"links/M.v"})," that is used to automatically apply the rules of ",(0,s.jsx)(n.code,{children:"Run.t"})," to the generated code, when possible."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The general idea is to go step-by-step through the whole expressions that are used to define functions in Rust to add the necessary information for typing and name/trait resolution in a way that is:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Proportional to the size of the expressions. For example, there are ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," ",(0,s.jsx)(n.code,{children:"if"})," expressions in sequence, we should have ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"n"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," rules to handle them and not ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsxs)(n.msup,{children:[(0,s.jsx)(n.mn,{children:"2"}),(0,s.jsx)(n.mi,{children:"n"})]})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"2^n"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6644em"}}),(0,s.jsxs)(n.span,{className:"mord",children:[(0,s.jsx)(n.span,{className:"mord",children:"2"}),(0,s.jsx)(n.span,{className:"msupsub",children:(0,s.jsx)(n.span,{className:"vlist-t",children:(0,s.jsx)(n.span,{className:"vlist-r",children:(0,s.jsx)(n.span,{className:"vlist",style:{height:"0.6644em"},children:(0,s.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,s.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(n.span,{className:"mord mathnormal mtight",children:"n"})})]})})})})})]})]})})]}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Using the unification mechanism of Rocq at a maximum, as well as the automations capabilities such as type-classes inference or custom tactics."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"predicates",children:"Predicates"}),"\n",(0,s.jsxs)(n.p,{children:["Here is the general predicate to say that a translated expression ",(0,s.jsx)(n.code,{children:"e"})," can be seen as evaluating to a certain typed value (that we do not compute at all here) of a certain type ",(0,s.jsx)(n.code,{children:"Output"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"{{ e \ud83d\udd3d R , Output }}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here the type ",(0,s.jsx)(n.code,{children:"R"})," represent the type of returned values in case there is a ",(0,s.jsx)(n.code,{children:"return"})," statement in the Rust code. For top-level expressions, like the body of a function, the return type is the same as the output type, so we can use this shortcut:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"{{ e \ud83d\udd3d Output }}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This predicate has an inductive definition and generated automatically by the ",(0,s.jsx)(n.code,{children:"run_symbolic"})," tactic for all common cases."]}),"\n",(0,s.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.p,{children:"Top-level Rust functions can always be polymorphic with both constant and type parameters. Combined with their list of runtime arguments, this means Rust functions always have three lists of parameters. We define the type of a translated function as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Module PolymorphicFunction.\n  Definition t : Set :=\n    list Value.t -> list Ty.t -> list Value.t -> M.\nEnd PolymorphicFunction.\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because we often apply the link predicate to such functions, and in order to make it a type-class to add automation with the instance inference mechanism, we define the following type-class:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Module Run.\n  Class Trait\n      (f : PolymorphicFunction.t)\n      (\u03b5 : list Value.t)\n      (\u03c4 : list Ty.t)\n      (\u03b1 : list Value.t)\n      (Output : Set) `{Link Output} :\n      Set :=\n  {\n    run_f : {{ f \u03b5 \u03c4 \u03b1 \ud83d\udd3d Output }};\n  }.\nEnd Run.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then, for top-level definitions or functions in an ",(0,s.jsx)(n.code,{children:"impl"})," block (but not for ",(0,s.jsx)(n.code,{children:"impl for"})," blocks that are trait instances), we make the following statement:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Instance run_spent (self : Ref.t Pointer.Kind.Ref Self) :\n  Run.Trait gas.Impl_revm_interpreter_gas_Gas.spent [] [] [\u03c6 self] U64.t.\n"})}),"\n",(0,s.jsx)(n.p,{children:"for a function with a signature such like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub const fn spent(&self) -> u64 {\n    self.limit - self.remaining\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Some remarks:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The name ",(0,s.jsx)(n.code,{children:"gas.Impl_revm_interpreter_gas_Gas.spent"})," is the name of the function in the translated Rust code. You need to find it in the corresponding\xa0",(0,s.jsx)(n.code,{children:".v"})," file."]}),"\n",(0,s.jsxs)(n.li,{children:["The two first lists of parameters are empty ",(0,s.jsx)(n.code,{children:"[]"})," as there are no constant or type parameters."]}),"\n",(0,s.jsxs)(n.li,{children:["The last list of parameters is ",(0,s.jsx)(n.code,{children:"[\u03c6 self]"})," as the function takes a single parameter named ",(0,s.jsx)(n.code,{children:"self"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The output type is ",(0,s.jsx)(n.code,{children:"U64.t"})," as the function returns a ",(0,s.jsx)(n.code,{children:"u64"})," in Rust."]}),"\n",(0,s.jsxs)(n.li,{children:["The type of ",(0,s.jsx)(n.code,{children:"self"})," is ",(0,s.jsx)(n.code,{children:"Ref.t Pointer.Kind.Ref Self"})," as it is a read-only reference to the type ",(0,s.jsx)(n.code,{children:"Self"})," in Rust."]}),"\n",(0,s.jsxs)(n.li,{children:["We use an ",(0,s.jsx)(n.code,{children:"Instance"})," so that the proof that the function can be evaluated to the expected type can be automatically reused in other statements. We use the default visibility of ",(0,s.jsx)(n.code,{children:"Instance"})," which is ",(0,s.jsx)(n.em,{children:"export"}),". It means that to use this instance in another file, you need to import its module with ",(0,s.jsx)(n.code,{children:"Import"}),". This helps to reduce the size of the exploration space of the type-class inference mechanism."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To construct this instance, we use the proof mode of Rocq with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Proof.\n  constructor.\n  run_symbolic.\nDefined.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["THe fact that we must always start by ",(0,s.jsx)(n.code,{children:"constructor"})," prevents the ",(0,s.jsx)(n.code,{children:"run_symbolic"})," tactic to go into the body of a function that we are calling. Instead, we should have one link per function and reuse existing ones when we call another function."]}),"\n",(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.code,{children:"impl"})," block, the corresponding module in Rocq should start with:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Module Impl_TypeName.\n  Definition Self : Set :=\n    TypeName.t.\n\n  (* The instances... *)\nEnd Impl_TypeName.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"run_symbolic"})," tactic might not always work fully automatically. When you encounter such cases, here are some strategies to follow:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check if the types that you expect for your function are correct. Maybe you have made a typo there."}),"\n",(0,s.jsxs)(n.li,{children:["If you are at the beginning of an ",(0,s.jsx)(n.code,{children:"if"})," or ",(0,s.jsx)(n.code,{children:"match"})," construct, you will first need to manually do a ",(0,s.jsx)(n.code,{children:"destruct"})," or similar to explore all cases."]}),"\n",(0,s.jsxs)(n.li,{children:["You might need to ",(0,s.jsx)(n.code,{children:"Import"})," the modules where are defined the functions yuo are calling, so that their instances can be used by the type-class inference mechanism."]}),"\n",(0,s.jsx)(n.li,{children:"You might be missing some link definitions or helpers for your types."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A good way to debug is to look at the rules of ",(0,s.jsx)(n.code,{children:"Run.t"})," to see which one should have been applied, and why it failed."]}),"\n",(0,s.jsx)(n.h2,{id:"traits",children:"Traits"}),"\n",(0,s.jsx)(n.p,{children:"The Rust traits are a bit more complicated. There are two distinct parts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The trait definition itself, that is a list of associated types and functions. This is translated to a type-class in Rocq."}),"\n",(0,s.jsxs)(n.li,{children:["The trait implementation, that is a list of function implementations for a certain trait and ",(0,s.jsx)(n.code,{children:"Self"})," type."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(n.p,{children:["There are a lot of trait definition examples in the file ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/links/interpreter_types.v",children:"revm/revm_interpreter/links/interpreter_types.v"}),". Here is one of these:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'(*\npub trait LegacyBytecode {\n    fn bytecode_len(&self) -> usize;\n    fn bytecode_slice(&self) -> &[u8];\n}\n*)\nModule LegacyBytecode.\n  Definition trait (Self : Set) `{Link Self} : TraitMethod.Header.t :=\n    ("revm_interpreter::interpreter_types::LegacyBytecode", [], [], \u03a6 Self).\n\n  Definition Run_bytecode_len (Self : Set) `{Link Self} : Set :=\n    TraitMethod.C (trait Self) "bytecode_len" (fun method =>\n      forall (self : Ref.t Pointer.Kind.Ref Self),\n      Run.Trait method [] [] [ \u03c6 self ] Usize.t\n    ).\n\n  Definition Run_bytecode_slice (Self : Set) `{Link Self} : Set :=\n    TraitMethod.C (trait Self) "bytecode_slice" (fun method =>\n      forall (self : Ref.t Pointer.Kind.Ref Self),\n      Run.Trait method [] [] [ \u03c6 self ] (Ref.t Pointer.Kind.Ref (list U8.t))\n    ).\n\n  Class Run (Self : Set) `{Link Self} : Set := {\n    bytecode_len : Run_bytecode_len Self;\n    bytecode_slice : Run_bytecode_slice Self;\n  }.\nEnd LegacyBytecode.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We first define what we expect for each method of the trait independently, and then group all these definitions in the ",(0,s.jsx)(n.code,{children:"Run"})," type-class for the trait definition. Splitting what is required for each method is useful for when we define a trait instance where some methods are calling other ones, so before the whole trait is instantiated."]}),"\n",(0,s.jsxs)(n.p,{children:["The definition ",(0,s.jsx)(n.code,{children:"trait"})," is for the header of the trait, meaning:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Its global unique name, that needs to match the one in the generated Rust code in order to make progress with ",(0,s.jsx)(n.code,{children:"run_symbolic"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"The list of constant parameters, that is empty here."}),"\n",(0,s.jsx)(n.li,{children:"The list of type parameters, that is empty here."}),"\n",(0,s.jsxs)(n.li,{children:["The type descriptor of the ",(0,s.jsx)(n.code,{children:"Self"})," type."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that in Rust methods can be polymorphic in addition of the trait itself. These are two different polymorphisms. We handle the trait polymorphism in the definition of ",(0,s.jsx)(n.code,{children:"trait"}),", and the method polymorphism in the definitions of the ",(0,s.jsx)(n.code,{children:"Run_*"})," for the individual methods. In this example, nothing is polymorphic expect for the ",(0,s.jsx)(n.code,{children:"Self"})," type, that is always a parameter in trait definitions."]}),"\n",(0,s.jsx)(n.h3,{id:"instances",children:"Instances"}),"\n",(0,s.jsxs)(n.p,{children:["For trait instances, you can see an example with an instance of the ",(0,s.jsx)(n.code,{children:"Default"})," trait for the ",(0,s.jsx)(n.code,{children:"Gas.t"})," type in the gas file ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/links/gas.v",children:"revm/revm_interpreter/links/gas.v"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Module Impl_Default_for_Gas.\n  Definition run_default : Default.Run_default Gas.t.\n  Proof.\n    eexists.\n    { eapply IsTraitMethod.Defined.\n      { apply gas.Impl_core_default_Default_for_revm_interpreter_gas_Gas.Implements. }\n      { reflexivity. }\n    }\n    { constructor.\n      pose (default.Impl_Default_for_integer.run_default IntegerKind.U64).\n      pose (default.Impl_Default_for_integer.run_default IntegerKind.I64).\n      pose Impl_Default_for_MemoryGas.run_default.\n      run_symbolic.\n    }\n  Defined.\n\n  Instance run : Default.Run Gas.t := {\n    Default.default := run_default;\n  }.\nEnd Impl_Default_for_Gas.\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here there is some administrative work that needs to be done for the instances (we should automate it more later). The command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"apply gas.Impl_core_default_Default_for_revm_interpreter_gas_Gas.Implements.\n"})}),"\n",(0,s.jsx)(n.p,{children:"relates to the name of the trait instance in the generated Rust code. In must be correct at this point and is verified by Rocq. Note that names in the generated code are sometimes long, but stable on code changes (no added numbers to avoid collisions for example)."}),"\n",(0,s.jsxs)(n.p,{children:["Something interesting is that before the ",(0,s.jsx)(n.code,{children:"run_symbolic"})," we also do:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"pose (default.Impl_Default_for_integer.run_default IntegerKind.U64).\npose (default.Impl_Default_for_integer.run_default IntegerKind.I64).\npose Impl_Default_for_MemoryGas.run_default.\nrun_symbolic.\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is to have the link of the instances of the trait methods we will call. For now, they need to be explicitly in context. You could have also done a destruct of the whole instance of the trait, with for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"destruct (default.Impl_Default_for_integer.run IntegerKind.U64).\n"})}),"\n",(0,s.jsx)(n.p,{children:"as it reveals all the methods."}),"\n",(0,s.jsx)(n.h3,{id:"associated-types",children:"Associated types"}),"\n",(0,s.jsxs)(n.p,{children:["For short, we represent associated types in traits as additional parameters for the trait. Here is an example with the ",(0,s.jsx)(n.code,{children:"Deref"})," trait:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'(*\npub trait Deref {\n    type Target: ?Sized;\n    fn deref(&self) -> &Self::Target;\n}\n*)\nModule Deref.\n  Definition trait (Self : Set) `{Link Self} : TraitMethod.Header.t :=\n    ("core::ops::deref::Deref", [], [], \u03a6 Self).\n\n  Definition Run_deref\n      (Self : Set) `{Link Self}\n      (Target : Set) `{Link Target} :\n      Set :=\n    TraitMethod.C (trait Self) "deref" (fun method =>\n      forall (self : Ref.t Pointer.Kind.Ref Self),\n      Run.Trait method [] [] [ \u03c6 self ] (Ref.t Pointer.Kind.Ref Target)\n    ).\n\n  Class Run\n      (Self : Set) `{Link Self}\n      (Target : Set) `{Link Target} :\n      Set := {\n    deref : Run_deref Self Target;\n  }.\nEnd Deref.\n'})}),"\n",(0,s.jsx)(n.p,{children:"The reason is that we can force these associated types to have a certain value in Rust. In that case, we can provide this value as a parameter. If this was not the case, we would be using existential types that are well supported in Rocq."}),"\n",(0,s.jsxs)(n.p,{children:["When a trait depends on other traits, for its ",(0,s.jsx)(n.code,{children:"Self"})," type, polymorphic types, or associated types, and when these types have associated types, we propagate these types parameters. For example, for the ",(0,s.jsx)(n.code,{children:"DerefMut"})," trait:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:'(*\npub trait DerefMut: Deref {\n    fn deref_mut(&mut self) -> &mut Self::Target;\n}\n*)\nModule DerefMut.\n  Definition trait (Self : Set) `{Link Self} : TraitMethod.Header.t :=\n    ("core::ops::deref::DerefMut", [], [], \u03a6 Self).\n\n  Definition Run_deref_mut\n      (Self : Set) `{Link Self}\n      (Target : Set) `{Link Target} :\n      Set :=\n    TraitMethod.C (trait Self) "deref_mut" (fun method =>\n      forall (self : Ref.t Pointer.Kind.MutRef Self),\n      Run.Trait method [] [] [ \u03c6 self ] (Ref.t Pointer.Kind.MutRef Target)\n    ).\n\n  Class Run\n      (Self : Set) `{Link Self}\n      (Target : Set) `{Link Target} :\n      Set := {\n    deref_mut : Run_deref_mut Self Target;\n  }.\nEnd DerefMut.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When associated types become too numerous (as these parameters are not visible on the Rust code, the programmers might introduce a lot of them), a pattern is to group them in a single record of types. You can see this approach used at the end of the file ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/links/interpreter_types.v",children:"revm/revm_interpreter/links/interpreter_types.v"})," with the definition of the ",(0,s.jsx)(n.code,{children:"InterpreterTypes"})," trait. Here is an example of use of this trait, in the ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/instructions/links/arithmetic.v",children:"revm/revm_interpreter/instructions/links/arithmetic.v"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"(*\npub fn add<WIRE: InterpreterTypes, H: Host + ?Sized>(\n    interpreter: &mut Interpreter<WIRE>,\n    _host: &mut H,\n)\n*)\nInstance run_add\n    {WIRE H : Set} `{Link WIRE} `{Link H}\n    {WIRE_types : InterpreterTypes.Types.t} `{InterpreterTypes.Types.AreLinks WIRE_types}\n    (run_InterpreterTypes_for_WIRE : InterpreterTypes.Run WIRE WIRE_types)\n    (interpreter : Ref.t Pointer.Kind.MutRef (Interpreter.t WIRE WIRE_types))\n    (_host : Ref.t Pointer.Kind.MutRef H) :\n  Run.Trait\n    instructions.arithmetic.add [] [ \u03a6 WIRE; \u03a6 H ] [ \u03c6 interpreter; \u03c6 _host ]\n    unit.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We do not reference the ",(0,s.jsx)(n.code,{children:"Host"})," trait in the example above as the variable ",(0,s.jsx)(n.code,{children:"_host"})," is not used."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);