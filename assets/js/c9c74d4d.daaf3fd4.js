"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[7401],{22316:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var t=o(74848),i=o(28453);const s={title:"\ud83e\udd84 Short introduction to Rocq",tags:["Rocq","formal verification","introduction"],authors:[]},r=void 0,a={permalink:"/blog/2025/08/11/quick-rocq-in-a-hurry",source:"@site/blog/2025-08-11-quick-rocq-in-a-hurry.md",title:"\ud83e\udd84 Short introduction to Rocq",description:"In this blog post, we present a short introduction to Rocq, a formal verification system, as a summary of the guide Rocq in a Hurry from Yves Bertot of the Rocq team.",date:"2025-08-11T00:00:00.000Z",formattedDate:"August 11, 2025",tags:[{label:"Rocq",permalink:"/blog/tags/rocq"},{label:"formal verification",permalink:"/blog/tags/formal-verification"},{label:"introduction",permalink:"/blog/tags/introduction"}],readingTime:5.61,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd84 Short introduction to Rocq",tags:["Rocq","formal verification","introduction"],authors:[]},unlisted:!1,nextItem:{title:"\ud83e\udd77 Formal verification of LLZK circuits in Rocq",permalink:"/blog/2025/07/31/llzk-to-rocq-verification"}},c={authorsImageUrls:[]},l=[{value:"\ud83e\udde9 Definitions",id:"-definitions",level:2},{value:"\ud83d\udcdd Proofs",id:"-proofs",level:2},{value:"\u262f\ufe0f Reasoning by cases",id:"\ufe0f-reasoning-by-cases",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In this blog post, we present a short introduction to ",(0,t.jsx)(n.a,{href:"https://rocq-prover.org/",children:"Rocq"}),", a formal verification system, as a summary of the guide ",(0,t.jsx)(n.a,{href:"https://cel.hal.science/inria-00001173v6/document",children:"Rocq in a Hurry"})," from ",(0,t.jsx)(n.a,{href:"https://www-sop.inria.fr/members/Yves.Bertot/research.html",children:"Yves Bertot"})," of the Rocq team."]}),"\n",(0,t.jsx)(n.p,{children:"Rocq is the formal system that we use exclusively, but other interactive theorem provers work the same way. From this introduction, you can get a sense of how the verification of mathematical statements or security properties of programs works."}),"\n",(0,t.jsx)("figure",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Green forest",src:o(43704).A+"",width:"1024",height:"1024"})})}),"\n",(0,t.jsx)(n.h2,{id:"-definitions",children:"\ud83e\udde9 Definitions"}),"\n",(0,t.jsxs)(n.p,{children:["There are propositions for logical formulas, which can be ",(0,t.jsx)(n.code,{children:"True"}),", ",(0,t.jsx)(n.code,{children:"False"}),", ",(0,t.jsx)(n.code,{children:"/\\"})," (and), ",(0,t.jsx)(n.code,{children:"\\/"})," (or), ",(0,t.jsx)(n.code,{children:"->"})," (implies), ",(0,t.jsx)(n.code,{children:"~"})," (not), using quantifiers ",(0,t.jsx)(n.code,{children:"forall"})," and ",(0,t.jsx)(n.code,{children:"exists"}),", and operators like ",(0,t.jsx)(n.code,{children:"="})," for equality. These can be proven to be correct. There are expressions like ",(0,t.jsx)(n.code,{children:"3 * x"})," that can be computed. We can define these as in a purely functional programming language."]}),"\n",(0,t.jsxs)(n.p,{children:["Basic data types for computations are booleans (not to be confused with propositions, on which you cannot compute), natural numbers defined as being either ",(0,t.jsx)(n.code,{children:"0"})," or ",(0,t.jsx)(n.code,{children:"n + 1"})," for some other ",(0,t.jsx)(n.code,{children:"n"})," a natural number, and lists which are either ",(0,t.jsx)(n.code,{children:"[]"})," or ",(0,t.jsx)(n.code,{children:"x :: l"})," like in many functional languages. You can define functions on those data types by pattern-matching (",(0,t.jsx)(n.code,{children:"match"})," operator) with recursive calls restricted to sub-elements of the patterns, to make sure all functions terminate."]}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of a recursive function combining booleans, natural numbers, and lists:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Fixpoint insert n l :=\n  match l with\n  | [] => n :: []\n  | a :: tl =>\n    if n <=? a then\n      n :: l\n    else\n      a :: insert n tl\n  end.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-proofs",children:"\ud83d\udcdd Proofs"}),"\n",(0,t.jsxs)(n.p,{children:["For propositions, like ",(0,t.jsx)(n.code,{children:"forall (n : nat), n < n + 1"}),", the goal is to find a proof of it, as we cannot simply evaluate a proposition to know if it is true or false. To write the proof, we use the interactive mode of Rocq, where we will step through the proof to construct it while being checked as correct. There are also automation primitives to go faster, but we will not see them here."]}),"\n",(0,t.jsxs)(n.p,{children:["An example of proposition to verify is the commutativity of the ",(0,t.jsx)(n.code,{children:"and"})," ope:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"forall (A B : Prop), A /\\ B -> B /\\ A\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In proof mode, we see what the hypotheses are and what the goal is, separated by a horizontal bar. Originally, the whole proposition is the goal, and there are no hypotheses. Then with ",(0,t.jsx)(n.code,{children:"intros"})," command, we move everything we can (in the ",(0,t.jsx)(n.code,{children:"forall"})," or before the ",(0,t.jsx)(n.code,{children:"->"}),") to the hypotheses:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"A, B : Prop\nH : A /\\ B\n\n----\n\nB /\\ A\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now the goal is ",(0,t.jsx)(n.code,{children:"B /\\ A"}),". We can use ",(0,t.jsx)(n.code,{children:"split"})," to split the goal into two, first ",(0,t.jsx)(n.code,{children:"B"})," and then ",(0,t.jsx)(n.code,{children:"A"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"A, B : Prop\nH : A /\\ B\n\n---- (1/2)\n\nB\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To solve the first goal, we can use ",(0,t.jsx)(n.code,{children:"destruct H"})," to split ",(0,t.jsx)(n.code,{children:"H"})," it into two hypotheses ",(0,t.jsx)(n.code,{children:"H1"})," and ",(0,t.jsx)(n.code,{children:"H2"}),". We obtain:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"A, B : Prop\nH1 : A\nH2 : B\n\n---- (1/2)\n\nB\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now we have in the hypotheses exactly what we want to prove, that is to say, ",(0,t.jsx)(n.code,{children:"B"}),". We can now conclude the proof with ",(0,t.jsx)(n.code,{children:"apply H2"}),", and do similarly for the other goal ",(0,t.jsx)(n.code,{children:"A"}),". We have completed our first formal proof!"]}),"\n",(0,t.jsxs)(n.p,{children:["For all the propositional operators, there is a command to use them when they are in a hypothesis, and a command to build them when they are in the goal. Most common commands, named tactics, are: ",(0,t.jsx)(n.code,{children:"intros"}),", ",(0,t.jsx)(n.code,{children:"apply"}),", ",(0,t.jsx)(n.code,{children:"split"}),", ",(0,t.jsx)(n.code,{children:"destruct"}),", ",(0,t.jsx)(n.code,{children:"rewrite"}),", ",(0,t.jsx)(n.code,{children:"exists"}),", ",(0,t.jsx)(n.code,{children:"reflexivity"}),", ",(0,t.jsx)(n.code,{children:"unfold"}),". As an exercise, you can try to prove the commutativity of the ",(0,t.jsx)(n.code,{children:"or"})," operator."]}),"\n",(0,t.jsxs)(n.p,{children:["Proofs are generally organized into a lot of sub-steps called lemmas. These are intermediate properties used to prove the main goal. The standard library or other packages provide a lot of such lemmas. You can find them using the ",(0,t.jsx)(n.code,{children:"Search"})," command."]}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-reasoning-by-cases",children:"\u262f\ufe0f Reasoning by cases"}),"\n",(0,t.jsxs)(n.p,{children:["To reason on propositions over expressions, and in particular programs, we can use the same tactics. The ",(0,t.jsx)(n.code,{children:"destruct"})," tactic enables reasoning by cases. For example, on booleans this means reasoning on the two cases ",(0,t.jsx)(n.code,{children:"false"})," and ",(0,t.jsx)(n.code,{children:"true"})," to verify that a property is correct for any boolean. On infinite data structures, like natural numbers, we reason by induction using the tactic ",(0,t.jsx)(n.code,{children:"induction"}),". For a given ",(0,t.jsx)(n.code,{children:"n"}),", a natural number in the hypotheses, it will generate two sub-goals, one with ",(0,t.jsx)(n.code,{children:"n"})," replaced by ",(0,t.jsx)(n.code,{children:"0"}),", and one with ",(0,t.jsx)(n.code,{children:"n"})," replaced by ",(0,t.jsx)(n.code,{children:"n + 1"}),", assuming an additional hypothesis which is the goal assumed correct for ",(0,t.jsx)(n.code,{children:"n"}),". An example of property is that the length of the concatenation of two lists is the sum of the lengths of the two lists, for any possible lists."]}),"\n",(0,t.jsx)(n.p,{children:"We can compose the reasoning by cases, yielding an arbitrary number of sub-goals. In practice, we will often get stuck in the wrong direction, like we would be stuck on paper, probably even more so than on paper."}),"\n",(0,t.jsxs)(n.p,{children:["The reasoning by induction works on arbitrary infinite data structures. For example, on lists it generates a sub-goal for the empty list, and one for the list ",(0,t.jsx)(n.code,{children:"x :: l"}),", assuming an additional hypothesis which is the goal assumed correct for ",(0,t.jsx)(n.code,{children:"l"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["We can define new data types with several constructors with potential parameters, and the possibility to reference itself in the parameters of the constructors. This is similar to the definition of ",(0,t.jsx)(n.code,{children:"enum"})," in Rust. For example, for binary trees with empty leaves:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Inductive bin : Set :=\n| Leaf : bin\n| Node : bin -> bin -> bin.\n"})}),"\n",(0,t.jsx)(n.p,{children:"It is then possible to define functions by pattern-matching and recursing on this new data type, like we were doing on natural numbers or lists, as well as prove properties by induction."}),"\n",(0,t.jsxs)(n.p,{children:["There are additional common data types. An important one is ",(0,t.jsx)(n.code,{children:"Z"})," which represents unbounded integers in binary encoding. It is more efficient than ",(0,t.jsx)(n.code,{children:"nat"})," for computations that use an unary encoding, but sometimes less convenient for proofs."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally, you can also define new propositions using the ",(0,t.jsx)(n.code,{children:"Inductive"})," keyword to define complex and recursive propositions. This is, for example, useful when defining the execution rules of programming languages."]}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["We have seen a quick introduction to understand to state and formally verify properties in a system like Rocq. In practice, to formally verify the security of a program, we will wrap these primitives in automation layers, and connect the definitions to the actual source code with translation tools such as ",(0,t.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),"."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["You want to secure your code? Contact us! \u21e8 ",(0,t.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"For more",type:"success",children:(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Follow us on ",(0,t.jsx)(n.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,t.jsx)(n.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions!"]})})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},43704:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/forest-4f0bdc03b8188e8b1d6e2410c466cff6.png"},28453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>a});var t=o(96540);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);