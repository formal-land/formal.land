"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4119],{9330:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var o=n(4848),s=n(8453);const i={title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (2/3)",tags:["Rust","links","simulations"],authors:[]},r=void 0,a={permalink:"/blog/2025/02/05/links-for-rust-in-rocq-2",source:"@site/blog/2025-02-05-links-for-rust-in-rocq-2.md",title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (2/3)",description:"In this blog post we present how represent a proof of execution for translated \ud83e\udd80&nbsp;Rust programs in &nbsp;Rocq/Coq, to show that it is possible to type the values and resolve the names. Resolving the names amounts to finding the trait instances and an ordering for the function definitions.",date:"2025-02-05T00:00:00.000Z",formattedDate:"February 5, 2025",tags:[{label:"Rust",permalink:"/blog/tags/rust"},{label:"links",permalink:"/blog/tags/links"},{label:"simulations",permalink:"/blog/tags/simulations"}],readingTime:9.82,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (2/3)",tags:["Rust","links","simulations"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Beginning of translation of OpenVM to Rocq",permalink:"/blog/2025/06/15/beginning-of-openvm-to-rocq"},nextItem:{title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (1/3)",permalink:"/blog/2025/01/30/links-for-rust-in-rocq"}},l={authorsImageUrls:[]},c=[];function u(t){const e={a:"a",p:"p",...(0,s.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.p,{children:["In this blog post we present how represent a proof of execution for translated ",(0,o.jsx)(e.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"})," programs in ",(0,o.jsxs)(e.a,{href:"https://rocq-prover.org/",children:[(0,o.jsx)("img",{src:"https://raw.githubusercontent.com/coq/rocq-prover.org/refs/heads/main/rocq-id/logos/SVG/icon-rocq-orange.svg",height:"18px"}),"\xa0Rocq/Coq"]}),", to show that it is possible to type the values and resolve the names. Resolving the names amounts to finding the trait instances and an ordering for the function definitions."]}),"\n",(0,o.jsxs)(e.p,{children:['We call these proofs of execution "links". They do not contain memory allocation strategies, which can be defined later in a second step called "simulation". From these links we have all the information to extract a typed execution that is equivalent to the translated code from ',(0,o.jsx)(e.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),". The core of the work presented in this article is in the file ",(0,o.jsx)(e.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/links/M.v",children:"CoqOfRust/links/M.v"})," on GitHub."]})]})}function h(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(u,{...t})}):u(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>r,x:()=>a});var o=n(6540);const s={},i=o.createContext(s);function r(t){const e=o.useContext(i);return o.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(s):t.components||s:r(t.components),o.createElement(i.Provider,{value:e},t.children)}}}]);