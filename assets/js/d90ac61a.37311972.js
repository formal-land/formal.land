"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[3362],{86967:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=i(74848),s=i(28453);const o={},r="\ud83d\udcda Start",a={id:"learn/start",title:"\ud83d\udcda Start",description:"In this part of the website, we will learn about applying modern formal verification to build software without bugs&nbsp;\ud83c\udf8a.",source:"@site/docs/learn/start.md",sourceDirName:"learn",slug:"/learn/start",permalink:"/docs/learn/start",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"\ud83d\uddfa\ufe0f Maps",permalink:"/docs/company/maps"},next:{title:"Install Rocq",permalink:"/docs/learn/install"}},l={},c=[{value:"Formal verification",id:"formal-verification",level:2},{value:"Quick example",id:"quick-example",level:2},{value:"Rust program",id:"rust-program",level:3},{value:"Coq version",id:"coq-version",level:3},{value:"Formal verification",id:"formal-verification-1",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"Next",id:"next",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"-start",children:"\ud83d\udcda Start"}),"\n",(0,t.jsxs)(n.p,{children:["In this part of the website, we will learn about applying modern ",(0,t.jsx)(n.strong,{children:"formal verification"})," to build ",(0,t.jsx)(n.strong,{children:"software without bugs\xa0\ud83c\udf8a"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Formal verification is proving that a program is correct for ",(0,t.jsx)(n.strong,{children:"any possible parameters"})," and initial state, even if there are ",(0,t.jsx)(n.strong,{children:"infinite possibilities"}),". The trick for this seemingly impossible challenge is to use ",(0,t.jsx)(n.strong,{children:"mathematical logic"})," to reason about the code."]}),"\n",(0,t.jsxs)(n.p,{children:["With formal verification, we will see how to build software for which users ",(0,t.jsx)(n.strong,{children:"can never complain about a bug"})," and attackers, even with state-level capabilities, ",(0,t.jsx)(n.strong,{children:"can never exploit a vulnerability"}),". Formal verification has been used successfully for critical systems such as ",(0,t.jsx)(n.strong,{children:"rockets going to space\xa0\ud83e\uddd1\u200d\ud83d\ude80"}),", trains, airplanes, and more recently to ",(0,t.jsx)(n.strong,{children:"securing cryptocurrencies\xa0\ud83d\udcb0"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For the learning, we will follow the adventures of ",(0,t.jsx)(n.strong,{children:"Jeju\xa0\ud83d\udc3b\u200d\u2744\ufe0f"}),", a small bear lost on an island who is very keen on never making mistakes."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Jeju in forest",src:i(52307).A+"",width:"768",height:"768"})}),(0,t.jsx)("figcaption",{children:"Jeju\xa0\ud83d\udc3b\u200d\u2744\ufe0f in the forest."})]}),"\n",(0,t.jsx)(n.h2,{id:"formal-verification",children:"Formal verification"}),"\n",(0,t.jsxs)(n.p,{children:["There are rules to follow to reason about the code in a logical way. These rules apply to each primitive instruction in a programming language, such as ",(0,t.jsx)(n.code,{children:"if"}),", ",(0,t.jsx)(n.code,{children:"while"}),", ",(0,t.jsx)(n.code,{children:"for"}),", ",(0,t.jsx)(n.code,{children:"return"}),", etc. There is also a way to specify the expected behavior of a program, to distinguish between a ",(0,t.jsx)(n.strong,{children:"bug"})," and a ",(0,t.jsx)(n.strong,{children:"feature"}),". Distinguishing between a bug and a feature might be one of the hardest things to do, as there is not a single answer fitting every situation. Stating what a program should do is called a ",(0,t.jsx)(n.strong,{children:"specification"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Jeju the bear \ud83d\udc3b\u200d\u2744\ufe0f knows the ancient art of formal verification. He is fortunate to use the ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://coq.inria.fr/",children:"Coq\xa0\ud83d\udc13"})})," proof software that helps write down all the reasoning ",(0,t.jsx)(n.strong,{children:"without making mistakes"}),". The Coq system has now been existing for 40 years and continues to evolve. It uses a special kind of logic based on ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dependent_type",children:"dependent types"}),", in which we can express any ",(0,t.jsx)(n.strong,{children:"mathematical statement"})," or ",(0,t.jsx)(n.strong,{children:"property about a program"})," and verify it. Many other systems are also based on these ideas, such as ",(0,t.jsx)(n.a,{href:"https://lean-lang.org/",children:"Lean"})," or ",(0,t.jsx)(n.a,{href:"https://wiki.portal.chalmers.se/agda/pmwiki.php",children:"Agda"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"quick-example",children:"Quick example"}),"\n",(0,t.jsx)(n.p,{children:"We now look at a small example to see the difference between testing and formal verification. You do not need to understand all the details for now."}),"\n",(0,t.jsx)(n.p,{children:"To find bugs in a program the traditional method is to test many parameters until we can see the program working fine enough times. However there can always be a missing bug on a case that we have not tested. Here we take a small example to show the difference between testing and formal verification."}),"\n",(0,t.jsx)(n.h3,{id:"rust-program",children:"Rust program"}),"\n",(0,t.jsx)(n.p,{children:"This is a Rust program returning the opposite of an integer:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn opposite_i8(n: i8) -> i8 {\n    return -n;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The type ",(0,t.jsx)(n.code,{children:"i8"})," represents signed integers in 8 bits. If we test this function, it will work for most cases:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'fn main() {\n    println!("{}", opposite_i8(0)); // prints 0\n    println!("{}", opposite_i8(40)); // prints -40\n    println!("{}", opposite_i8(-28)); // prints 28\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"But there is one case in which the function fails:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// You need to run this code in release mode as in debug mode\n// the overflows are checked and the program instead panics\nfn main() {\n    println!("{}", opposite_i8(-128)); // prints -128 instead of 128\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The reason is that the bounds of 8 bits integers are from ",(0,t.jsx)(n.code,{children:"-128"})," to ",(0,t.jsx)(n.code,{children:"127"})," so we cannot represent ",(0,t.jsx)(n.code,{children:"128"})," and thus we get a wrong result, in this case ",(0,t.jsx)(n.code,{children:"-128"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"coq-version",children:"Coq version"}),"\n",(0,t.jsx)(n.p,{children:"To be extra safe, Jeju uses formal verification and even sometimes avoids writing any tests!"}),"\n",(0,t.jsxs)(n.p,{children:["Here is how he would represent the above program in Coq. We do not have an ",(0,t.jsx)(n.code,{children:"i8"})," type but we have the ",(0,t.jsx)(n.code,{children:"Z"})," type of integers without bounds. We simulate ",(0,t.jsx)(n.code,{children:"i8"})," numbers by a function that takes an arbitrary integer and puts it back into the ",(0,t.jsx)(n.code,{children:"-128"})," and ",(0,t.jsx)(n.code,{children:"+127"})," bounds using the modulo operator:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition normalize_i8 (n : Z) : Z :=\n  ((n + 128) mod 256) - 128.\n"})}),"\n",(0,t.jsx)(n.p,{children:"We then define the opposite function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition opposite_i8 (n : Z) : Z :=\n  normalize_i8 (-n).\n"})}),"\n",(0,t.jsx)(n.p,{children:"that returns the same results as in Rust:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Compute opposite_i8 0. (* 0 *)\nCompute opposite_i8 40. (* -40 *)\nCompute opposite_i8 (-28). (* 28 *)\nCompute opposite_i8 (-128). (* -128 *)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"formal-verification-1",children:"Formal verification"}),"\n",(0,t.jsxs)(n.p,{children:["We can now state that the ",(0,t.jsx)(n.code,{children:"opposite_i8"})," function should work for all ",(0,t.jsx)(n.code,{children:"i8"})," values except ",(0,t.jsx)(n.code,{children:"-128"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Lemma normalize_i8_eq (n : Z) :\n  - 127 <= n <= 127 ->\n  opposite_i8 n = - n.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It says that for all integers between ",(0,t.jsx)(n.code,{children:"-127"})," and ",(0,t.jsx)(n.code,{children:"127"})," the opposite function returns the same value as what we would have in ",(0,t.jsx)(n.code,{children:"Z"}),". We need to write an argument to say that this property is always true as the Coq system cannot check everything by itself. The argument is called a proof and is the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Proof.\n  unfold opposite_i8, normalize_i8.\n  lia.\nQed.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It says that we unfold all the definitions and then run the linear arithmetic solver ",(0,t.jsx)(n.code,{children:"lia"})," to conclude the proof automatically. Once someone knows about the Coq proof system this is a very natural proof to write. For the proof above to work, you need to activate the division mode for ",(0,t.jsx)(n.code,{children:"lia"})," with:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Ltac Zify.zify_post_hook ::= Z.to_euclidean_division_equations.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If we use an interval starting at ",(0,t.jsx)(n.code,{children:"-128"})," instead, the same proof fails as expected:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Lemma normalize_i8_eq (n : Z) :\n  - 128 <= n <= 127 ->\n  opposite_i8 n = - n.\nProof.\n  unfold opposite_i8, normalize_i8.\n  lia.\nQed.\n"})}),"\n",(0,t.jsx)(n.p,{children:"returns the error:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Error: Tactic failure:  Cannot find witness.\n"})}),"\n",(0,t.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["We have seen how to both test and formally verify a small program ",(0,t.jsx)(n.code,{children:"opposite_i8"}),". As there are only ",(0,t.jsx)(n.code,{children:"256"})," possible values between ",(0,t.jsx)(n.code,{children:"-128"})," and ",(0,t.jsx)(n.code,{children:"127"}),", we could have also tested it exhaustively. But if we were working with the ",(0,t.jsx)(n.code,{children:"i64"})," type instead, for signed integers with 64 bits, there would be too many possible values to test. That does not make Jeju afraid as the proof for 64-bits integers takes about the same time to run, a fraction of a second, and confirms that ",(0,t.jsx)(n.code,{children:"opposite_i64"})," is valid for all ",(0,t.jsx)(n.code,{children:"i64"})," values except the minimal one! \ud83c\udf8a"]}),"\n",(0,t.jsx)(n.h2,{id:"next",children:"Next"}),"\n",(0,t.jsx)(n.p,{children:"The rest of the learning section is under construction. We will learn:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The basics of the Coq system."}),"\n",(0,t.jsx)(n.li,{children:"How to write a specification for a program in Coq and verify it?"}),"\n",(0,t.jsx)(n.li,{children:"How to use Coq to verify smart contracts in Solidity?"}),"\n",(0,t.jsx)(n.li,{children:"How to use Coq to verify Rust programs?"}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"J. \ud83d\udc3e"}),"\n",(0,t.jsxs)(n.p,{children:["Follow my ",(0,t.jsx)(n.a,{href:"https://x.com/JejuFormalLand",children:"X account"})," for more learning!"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},52307:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/start_jeju_medium-86af759252127f303b380cffb9831f75.webp"},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);