"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[9453],{4290:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=n(4848),i=n(8453);const o={title:"\ud83e\udd84 Mutually recursive functions with notation",tags:["recursion","notation","mutual"],authors:[]},r=void 0,a={permalink:"/blog/2024/12/26/mutually-recursive-functions-with-notation",source:"@site/blog/2024-12-26-mutually-recursive-functions-with-notation.md",title:"\ud83e\udd84 Mutually recursive functions with notation",description:"In this blog post, we present a technique with the &nbsp;Rocq/Coq theorem prover to define mutually recursive functions using a notation. This is sometimes convenient for types defined using a container type, such as types depending on a list of itself.",date:"2024-12-26T00:00:00.000Z",formattedDate:"December 26, 2024",tags:[{label:"recursion",permalink:"/blog/tags/recursion"},{label:"notation",permalink:"/blog/tags/notation"},{label:"mutual",permalink:"/blog/tags/mutual"}],readingTime:3.735,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd84 Mutually recursive functions with notation",tags:["recursion","notation","mutual"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd16 Annotating what we are doing for an LLM to pick up",permalink:"/blog/2025/01/06/annotating-what-we-are-doing"},nextItem:{title:"\ud83d\udc7b Translation of Circom to Coq",permalink:"/blog/2024/12/20/translation-of-circom-to-coq"}},l={authorsImageUrls:[]},c=[{value:"\ud83d\udd0d Example",id:"-example",level:2},{value:"\ud83d\udcdd First solution",id:"-first-solution",level:2},{value:"\ud83d\ude80 Second solution",id:"-second-solution",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function u(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In this blog post, we present a technique with the ",(0,s.jsxs)(t.a,{href:"https://rocq-prover.org/",children:[(0,s.jsx)("img",{src:"https://raw.githubusercontent.com/coq/rocq-prover.org/refs/heads/main/rocq-id/logos/SVG/icon-rocq-orange.svg",height:"18px"}),"\xa0Rocq/Coq"]})," theorem prover to define mutually recursive functions using a notation. This is sometimes convenient for types defined using a container type, such as types depending on a list of itself."]}),"\n",(0,s.jsxs)(t.admonition,{title:"Ask for the highest security!",type:"success",children:[(0,s.jsxs)(t.p,{children:["To ensure your code is fully secure today, contact us at\xa0",(0,s.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"}),"!\xa0\ud83d\ude80"]}),(0,s.jsx)(t.p,{children:"We exclusively focus on formal verification to offer you the highest degree of security for your application."}),(0,s.jsx)(t.p,{children:"We currently work with some of the leading blockchain entities, such as:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.a,{href:"https://ethereum.foundation/",children:"Ethereum Foundation"})]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.a,{href:"https://sui.io/about",children:"Sui Foundation"})]}),"\n",(0,s.jsxs)(t.li,{children:["Previously, the ",(0,s.jsx)(t.a,{href:"https://alephzero.org/",children:"Aleph Zero"})," and ",(0,s.jsx)(t.a,{href:"https://tezos.com/",children:"Tezos"})," foundations"]}),"\n"]})]}),"\n",(0,s.jsx)("figure",{children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Forest",src:n(8793).A+"",width:"1472",height:"832"})})}),"\n",(0,s.jsx)(t.h2,{id:"-example",children:"\ud83d\udd0d Example"}),"\n",(0,s.jsxs)(t.p,{children:["Here is a typical example of a type defined using a container of itself, written in ",(0,s.jsx)(t.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"struct Trees<A>(Vec<Tree<A>>);\n\nenum Tree<A> {\n    Leaf,\n    Node { data: A, children: Trees<A> },\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"These two definitions are mutually dependent. We choose to represent it in Rocq/Coq with the following definition:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Inductive Tree (A : Set) : Set :=\n| Leaf : Tree A\n| Node : A -> list (Tree A) -> Tree A.\n\nDefinition Trees (A : Set) : Set :=\n  list (Tree A).\n"})}),"\n",(0,s.jsx)(t.p,{children:"If we define a recursive function on this type, for example, to compute the sum of all the values in the tree, we would naturally write a function that iterates both on:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The tree constructors,"}),"\n",(0,s.jsxs)(t.li,{children:["The list of the ",(0,s.jsx)(t.code,{children:"Node"})," case."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"-first-solution",children:"\ud83d\udcdd First solution"}),"\n",(0,s.jsxs)(t.p,{children:["Here is a first attempt to define a ",(0,s.jsx)(t.code,{children:"sum"})," function that adds all the elements of the tree:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Fixpoint sum_tree {A : Set} (f : A -> nat) (t : Tree A) : nat :=\n  match t with\n  | Leaf => 0\n  | Node a ts => f a + sum_trees f ts\n  end\n\nwith sum_trees {A : Set} (f : A -> nat) (ts : Trees A) : nat :=\n  match ts with\n  | nil => 0\n  | t :: ts => sum_tree f t + sum_trees f ts\n  end.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This definition does not work as the ",(0,s.jsx)(t.code,{children:"Tree"})," type is not mutually recursive, but the function ",(0,s.jsx)(t.code,{children:"sum_tree"})," is. The error message is:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"Error: Cannot guess decreasing argument of fix.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["A first solution is to define the function ",(0,s.jsx)(t.code,{children:"sum_trees"})," as a local definition in ",(0,s.jsx)(t.code,{children:"sum_tree"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Fixpoint sum_tree {A : Set} (f : A -> nat) (t : Tree A) : nat :=\n  let fix sum_trees (ts : Trees A) : nat :=\n    match ts with\n    | nil => 0\n    | t :: ts => sum_tree f t + sum_trees ts\n    end in\n  match t with\n  | Leaf => 0\n  | Node a ts => f a + sum_trees ts\n  end.\n"})}),"\n",(0,s.jsx)(t.p,{children:"This definition gets accepted by the prover!"}),"\n",(0,s.jsx)(t.h2,{id:"-second-solution",children:"\ud83d\ude80 Second solution"}),"\n",(0,s.jsxs)(t.p,{children:["An issue is that we cannot call ",(0,s.jsx)(t.code,{children:"sum_trees"})," directly as its definition is hidden in the one of ",(0,s.jsx)(t.code,{children:"sum_tree"}),". This is a problem if further top-level definitions depend on ",(0,s.jsx)(t.code,{children:"sum_trees"}),", or if we want to verify intermediate properties about ",(0,s.jsx)(t.code,{children:"sum_trees"})," itself."]}),"\n",(0,s.jsxs)(t.p,{children:["A solution we use for this kind of problem is to add a notation to make ",(0,s.jsx)(t.code,{children:"sum_trees"})," a top-level definition while keeping the mutual recursion with ",(0,s.jsx)(t.code,{children:"sum_tree"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Reserved Notation \"'sum_trees\".\n\nFixpoint sum_tree {A : Set} (f : A -> nat) (t : Tree A) : nat :=\n  match t with\n  | Leaf => 0\n  | Node a ts => f a + 'sum_trees _ f ts\n  end\n\nwhere \"'sum_trees\" := (fix sum_trees (A : Set) (f : A -> nat) (ts : Trees A) : nat :=\n  match ts with\n  | nil => 0\n  | t :: ts => sum_tree f t + sum_trees _ f ts\n  end).\n\nDefinition sum_trees {A : Set} := 'sum_trees A.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Here, both ",(0,s.jsx)(t.code,{children:"sum_tree"})," and ",(0,s.jsx)(t.code,{children:"sum_trees"})," are defined as top-level, and the mutually recursive definition is accepted. Note that we have to make the type ",(0,s.jsx)(t.code,{children:"A"})," explicit in the notation, as implicit parameters are not allowed there."]}),"\n",(0,s.jsx)(t.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,s.jsxs)(t.p,{children:["We have shown a technique that is sometimes useful for us to define complex, mutually dependent data structures. This was recently useful for defining the ",(0,s.jsx)(t.code,{children:"ValueImpl"})," type in the type-checker of ",(0,s.jsx)(t.a,{href:"https://sui.io/move",children:"Move"})," for the blockchain ",(0,s.jsx)(t.a,{href:"https://sui.io/",children:"Sui"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"You can tell us what you think or if you prefer another way to define mutually recursive functions!"}),"\n",(0,s.jsx)(t.admonition,{title:"For more",type:"success",children:(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["Follow us on ",(0,s.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,s.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions or requests!"]})})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8793:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/two-trees-4e9d1d0b0d813576a958ece5726466fb.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);