"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[9780],{29287:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var o=n(74848),i=n(28453);const a={title:"\ud83e\ude81 Coq of Solidity \u2013 part 4",tags:["formal verification","Coq","Solidity","Yul"],authors:[]},s=void 0,r={permalink:"/blog/2024/08/13/coq-of-solidity-4",source:"@site/blog/2024-08-13-coq-of-solidity-4.md",title:"\ud83e\ude81 Coq of Solidity \u2013 part 4",description:"In this blog post we explain how we specify and formally verify a whole ERC-20 smart contract using our tool coq-of-solidity, which translates Solidity code to the proof assistant Coq&nbsp;\ud83d\udc13.",date:"2024-08-13T00:00:00.000Z",formattedDate:"August 13, 2024",tags:[{label:"formal verification",permalink:"/blog/tags/formal-verification"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"Solidity",permalink:"/blog/tags/solidity"},{label:"Yul",permalink:"/blog/tags/yul"}],readingTime:6.49,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\ude81 Coq of Solidity \u2013 part 4",tags:["formal verification","Coq","Solidity","Yul"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 1",permalink:"/blog/2024/08/19/verification-move-sui-type-checker-1"},nextItem:{title:"\ud83e\ude81 Coq of Solidity \u2013 part 3",permalink:"/blog/2024/08/12/coq-of-solidity-3"}},l={authorsImageUrls:[]},c=[{value:"Functional specification",id:"functional-specification",level:2},{value:"Dispatch to the entrypoints",id:"dispatch-to-the-entrypoints",level:2},{value:"Equivalence statement",id:"equivalence-statement",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In this blog post we explain how we specify and formally verify a whole ",(0,o.jsx)(t.a,{href:"https://github.com/ethereum/solidity,/blob/develop/test/libsolidity/semanticTests/various/erc20.sol",children:"ERC-20 smart contract"})," using our tool ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-solidity",children:"coq-of-solidity"}),", which translates ",(0,o.jsx)(t.a,{href:"https://soliditylang.org/",children:"Solidity"})," code to the proof assistant ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq\xa0\ud83d\udc13"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"The proofs are still tedious for now, as there are around 1,000 lines of proofs for 100 lines of Solidity. We plan to automate this work as much as possible in the subsequent iterations of the tool. One good thing about the interactive theorem prover Coq is that we know we can never be stuck, so we can always make progress in our proof techniques and verify complex properties even if it takes time\xa0\u2728."}),"\n",(0,o.jsx)(t.p,{children:"Formal verification with an interactive proof assistant is the strongest way to verify programs since:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"it covers all possible inputs and program states,"}),"\n",(0,o.jsx)(t.li,{children:"it checks any kind of properties."}),"\n"]}),"\n",(0,o.jsxs)(t.admonition,{title:"Get started",type:"success",children:[(0,o.jsxs)(t.p,{children:["To audit your smart contracts and make sure they contain no bugs, contact us at\xa0",(0,o.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udce7contact@formal.land"}),"."]}),(0,o.jsx)(t.p,{children:"We refund our work if we missed a high/critical severity bug."})]}),"\n",(0,o.jsx)("figure",{children:(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Ethereum in forest",src:n(63416).A+"",width:"1024",height:"1024"})})}),"\n",(0,o.jsx)(t.h2,{id:"functional-specification",children:"Functional specification"}),"\n",(0,o.jsxs)(t.p,{children:["We specify the ERC-20 smart contract by writing an equivalent version in Coq that acts as a functional specification. In this specification, we ignore the ",(0,o.jsx)(t.code,{children:"emit"}),' operations that are logging events in Solidity and the precise payload of revert operations (we only say that "a revert occurs"). We make all our arithmetic operations on\xa0',(0,o.jsx)(t.code,{children:"Z"})," the type of unbounded integers with explicit overflow checks."]}),"\n",(0,o.jsxs)(t.p,{children:["For example, here is the ",(0,o.jsx)(t.code,{children:"_transfer"})," function of the Solidity smart contract:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-solidity",children:'function _transfer(address from, address to, uint256 value) internal {\n    require(to != address(0), "ERC20: transfer to the zero address");\n\n    // The subtraction and addition here will revert on overflow.\n    _balances[from] = _balances[from] - value;\n    _balances[to] = _balances[to] + value;\n    emit Transfer(from, to, value);\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["We specify it in the file ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-solidity/blob/guillaume-claret%40verify-erc20/CoqOfSolidity/simulations/erc20.v",children:"erc20.v"})," by:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Definition _transfer (from to : Address.t) (value : U256.t) (s : Storage.t)\n    : Result.t Storage.t :=\n  if to =? 0 then\n    revert_address_null\n  else if balanceOf s from <? value then\n    revert_arithmetic\n  else\n    let s :=\n      s <| Storage.balances :=\n        Dict.declare_or_assign s.(Storage.balances) from (balanceOf s from - value)\n      |> in\n    if balanceOf s to + value >=? 2 ^ 256 then\n      revert_arithmetic\n    else\n      Result.Success s <| Storage.balances :=\n        Dict.declare_or_assign s.(Storage.balances) to (balanceOf s to + value)\n      |>.\n"})}),"\n",(0,o.jsx)(t.p,{children:"With the Coq notation:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"storage <| field := new_value |>\n"})}),"\n",(0,o.jsx)(t.p,{children:"we modify a storage element as in the equivalent Solidity:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-solidity",children:"field = new_value;\n"})}),"\n",(0,o.jsx)(t.p,{children:"With the two tests:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"if balanceOf s from <? value then\nif balanceOf s to + value >=? 2 ^ 256 then\n"})}),"\n",(0,o.jsx)(t.p,{children:"we make explicit the overflow checks that are implicit in the Solidity code."}),"\n",(0,o.jsx)(t.h2,{id:"dispatch-to-the-entrypoints",children:"Dispatch to the entrypoints"}),"\n",(0,o.jsx)(t.p,{children:"A Solidity smart contract has two public functions:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"One is the deployment code, which essentially initializes the storage of the smart contract and loads the rest of the code in memory,"}),"\n",(0,o.jsx)(t.li,{children:"The other one is executed when a transaction is sent to the smart contract, which is dispatched to the relevant entrypoint according to the payload of the transaction."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"We will focus on the second one. It takes the contract's payload in a specific format:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"The first four bytes are the function selector, which is the first four bytes of the hash of the function signature,"}),"\n",(0,o.jsxs)(t.li,{children:["The rest of the payload is the arguments of the function, following the ABI (",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Application_binary_interface",children:"Application Binary Interface"}),") of Solidity."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["This blog article ",(0,o.jsx)(t.a,{href:"https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-iii-the-function-selector-6a9b6886ea49",children:"Deconstructing a Solidity Contract\u200a-\u200aPart III: The Function Selector"})," from OpenZeppelin gives more information about it. In Coq, we represent the payload of a contract with a sum type:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Module Payload.\n  Inductive t : Set :=\n  | Transfer (to: Address.t) (value: U256.t)\n  | Approve (spender: Address.t) (value: U256.t)\n  | TransferFrom (from: Address.t) (to: Address.t) (value: U256.t)\n  | IncreaseAllowance (spender: Address.t) (addedValue: U256.t)\n  | DecreaseAllowance (spender: Address.t) (subtractedValue: U256.t)\n  | TotalSupply\n  | BalanceOf (owner: Address.t)\n  | Allowance (owner: Address.t) (spender: Address.t).\nEnd Payload.\n"})}),"\n",(0,o.jsx)(t.p,{children:"We define how to get this payload from the binary representation:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:'Definition of_calldata (callvalue : U256.t) (calldata: list U256.t) :\n    option Payload.t :=\n  if Z.of_nat (List.length calldata) <? 4 then\n    None\n  else\n    let selector := Stdlib.Pure.shr (256 - 32) (StdlibAux.get_calldata_u256 calldata 0) in\n    if selector =? get_selector "approve(address,uint256)" then\n      let to := StdlibAux.get_calldata_u256 calldata (4 + 32 * 0) in\n      let value := StdlibAux.get_calldata_u256 calldata (4 + 32 * 1) in\n      if negb (callvalue =? 0) then\n        None\n      else if negb (get_have_enough_calldata (32 * 2) calldata) then\n        None\n      else if negb (get_is_address_valid to) then\n        None\n      else\n        Some (Approve to value)\n    else if selector =? get_selector "totalSupply()" then\n    (* ... other cases ... *)\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"callvalue"})," is the amount of Ether sent with the transaction, which has to be zero for non-payable functions. The ",(0,o.jsx)(t.code,{children:"calldata"})," is the list bytes of the payload of the transaction. We check that the length of the payload is at least 4 bytes, then we extract the selector and the arguments of the function. We check that the arguments are valid, and we return the corresponding payload or ",(0,o.jsx)(t.code,{children:"None"})," in case of error."]}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsxs)(t.p,{children:["Note that a lot of the code is very repetitive and can be generated automatically by AI. For example the definition of the ",(0,o.jsx)(t.code,{children:"Payload.t"})," type was automatically generated by ",(0,o.jsx)(t.a,{href:"https://claude.ai/",children:"Claude.ai"})," in one shot, with the code of the smart contract and its specification in context."]})}),"\n",(0,o.jsx)(t.h2,{id:"equivalence-statement",children:"Equivalence statement"}),"\n",(0,o.jsx)(t.p,{children:"Here is the lemma stating that, for any possible user inputs and storage values, the Solidity smart contract and the Coq specification behave exactly the same:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Lemma run_body codes environment state\n    (s : erc20.Storage.t)\n    (H_environment : Environment.Valid.t environment)\n    (H_s : erc20.Storage.Valid.t s) :\n  let memoryguard := 128 in\n  let memory_start :=\n    [0; 0; 0; 0; 0] in\n  let state_start :=\n    make_state environment state memory_start (SimulatedStorage.of_erc20_state s) in\n  let output :=\n    // highlight-next-line\n    The functional specification here:\n    erc20.body\n      environment.(Environment.caller)\n      environment.(Environment.callvalue)\n      s\n      environment.(Environment.calldata) in\n  let memory_end_middle :=\n    [memoryguard; 0] in\n  let state_end :=\n    match output with\n    | erc20.Result.Revert _ _ => None\n    | erc20.Result.Success (memory_end_beginning, memory_end_end, s) =>\n      Some (make_state environment state\n        (memory_end_beginning ++ memory_end_middle ++ memory_end_end)\n        (SimulatedStorage.of_erc20_state s)\n      )\n    end in\n  {{? codes, environment, Some state_start |\n    // highlight-next-line\n    The original code here:\n    ERC20_403.ERC20_403_deployed.body \u21d3\n    match output with\n    | erc20.Result.Revert p s => Result.Revert p s\n    | erc20.Result.Success (_, memory_end_end, _) =>\n      Result.Return memoryguard (32 * Z.of_nat (List.length memory_end_end))\n    end\n  | state_end ?}}.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The proof is done in the same way as in the previous blog post ",(0,o.jsx)(t.a,{href:"/blog/2024/08/12/coq-of-solidity-3",children:"\ud83e\ude81 Coq of Solidity \u2013 part 3"})," about the verification of the ",(0,o.jsx)(t.code,{children:"_approve"})," function. The body of the contract calls all the other functions of the contract, and we reuse the equivalence proofs for the other functions here."]}),"\n",(0,o.jsx)(t.p,{children:"The main difficulty we encountered in the proof was missing information in the specification. For example, our predicate of equivalence requires for the memory of the smart contract to have the exact same value as its specification at the end of execution, except in case of revert. This means we needed to add the final state of the memory in the specification also, even if this is an implementation detail. We will refine our equivalence statement in the future to avoid this kind of issue."}),"\n",(0,o.jsx)(t.p,{children:"For the most part of the proof, the work was about stepping through both codes and making sure, by automatic unification, that the twos are indeed equal."}),"\n",(0,o.jsx)(t.admonition,{title:"AlephZero",type:"success",children:(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:["The development of ",(0,o.jsx)(t.code,{children:"coq-of-solidity"})," is made possible thanks to the ",(0,o.jsx)(t.a,{href:"https://alephzero.org/",children:"AlephZero"})," project. We thank the AlephZero Foundation for their support\xa0\ud83d\ude4f."]})})}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(t.p,{children:["We have presented how to specify and formally verify a typical smart contract in Solidity, the ERC-20 token, using our tool ",(0,o.jsx)(t.code,{children:"coq-of-solidity"})," (open-source). In the next post, we will see how to verify an invariant on the code and how the proof system Coq reacts if we introduce a bug."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},63416:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/ethereum-in-forest-e8ecce5a4ad697a15ea00fedb9450e75.webp"},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(96540);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);