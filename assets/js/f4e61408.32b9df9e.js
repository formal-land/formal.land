"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[6895],{64980:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var r=n(74848),s=n(28453);const o={title:"\ud83e\udd80 Verification of one instruction of the Move's type-checker",tags:["Rust","Move","Sui","type-checker"],authors:[]},i=void 0,a={permalink:"/blog/2025/01/13/verification-one-instruction-sui",source:"@site/blog/2025-01-13-verification-one-instruction-sui.md",title:"\ud83e\udd80 Verification of one instruction of the Move's type-checker",description:"This is the last article of a series of blog post presenting our formal verification effort in &nbsp;Rocq/Coq to ensure the correctness of the type-checker of the Move language for Sui.",date:"2025-01-13T00:00:00.000Z",formattedDate:"January 13, 2025",tags:[{label:"Rust",permalink:"/blog/tags/rust"},{label:"Move",permalink:"/blog/tags/move"},{label:"Sui",permalink:"/blog/tags/sui"},{label:"type-checker",permalink:"/blog/tags/type-checker"}],readingTime:5.73,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Verification of one instruction of the Move's type-checker",tags:["Rust","Move","Sui","type-checker"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd16 Designing a coding assistant for Rocq",permalink:"/blog/2025/01/21/designing-a-coding-assistant-for-rocq"},nextItem:{title:"\ud83e\udd16 Annotating what we are doing for an LLM to pick up",permalink:"/blog/2025/01/06/annotating-what-we-are-doing"}},c={authorsImageUrls:[]},h=[{value:"\ud83e\udd80 The Rust code",id:"-the-rust-code",level:2},{value:"\ud83d\udc26\u200d\u2b1b The Rocq translation",id:"-the-rocq-translation",level:2},{value:"\ud83d\udcdc Formal statement",id:"-formal-statement",level:2},{value:"\ud83d\udee1\ufe0f Proof time",id:"\ufe0f-proof-time",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["This is the last article of a series of blog post presenting our formal verification effort in ",(0,r.jsxs)(t.a,{href:"https://rocq-prover.org/",children:[(0,r.jsx)("img",{src:"https://raw.githubusercontent.com/coq/rocq-prover.org/refs/heads/main/rocq-id/logos/SVG/icon-rocq-orange.svg",height:"18px"}),"\xa0Rocq/Coq"]})," to ensure the correctness of the type-checker of the ",(0,r.jsx)(t.a,{href:"https://sui.io/move",children:"Move language"})," for ",(0,r.jsx)(t.a,{href:"https://sui.io/",children:"Sui"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Here we show how the formal proof works to check that the type-checker is correct on a particular instruction, for any possible initial states. The general idea is to symbolically execute the code step by step on the type-checker side, accumulating properties about the stack assuming the type-checker succeeds, and then to show that the interpreter will produce a stack of the expected type as a result."}),"\n",(0,r.jsx)(t.p,{children:"Previous post:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/blog/2024/11/14/sui-move-checker-abstract-stack",children:"\ud83e\udd80 Example of verification for the Move's checker of Sui"})}),"\n"]}),"\n",(0,r.jsxs)(t.admonition,{title:"Ask for the highest security!",type:"success",children:[(0,r.jsx)(t.p,{children:"When millions are at stake, bug bounties are not enough."}),(0,r.jsx)(t.p,{children:"How do you ensure your security audits are exhaustive?"}),(0,r.jsxs)(t.p,{children:["The best way to do this is to use ",(0,r.jsx)(t.strong,{children:"formal verification"}),"."]}),(0,r.jsxs)(t.p,{children:["This is what we provide as a service. ",(0,r.jsx)(t.strong,{children:"Contact us"})," at\xa0",(0,r.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"})," to make sure your code is safe!\xa0\ud83d\udee1\ufe0f"]}),(0,r.jsxs)(t.p,{children:["We cover ",(0,r.jsx)(t.strong,{children:"Rust"}),", ",(0,r.jsx)(t.strong,{children:"Solidity"}),", and ",(0,r.jsx)(t.strong,{children:"ZK systems"}),"."]})]}),"\n",(0,r.jsx)("figure",{children:(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Green forest with water",src:n(27183).A+"",width:"1024",height:"1024"})})}),"\n",(0,r.jsx)(t.h2,{id:"-the-rust-code",children:"\ud83e\udd80 The Rust code"}),"\n",(0,r.jsxs)(t.p,{children:["We are verifying the type-checking for the Move bytecode instruction ",(0,r.jsx)(t.code,{children:"CastU8"}),". This instruction takes the top-most element of the stack, checks that it is an integer, and pushes it back on the stack as a ",(0,r.jsx)(t.code,{children:"U8"})," if it is in the right range or fails with an error ",(0,r.jsx)(t.code,{children:"StatusCode::ARITHMETIC_ERROR"})," otherwise."]}),"\n",(0,r.jsx)(t.p,{children:"Here is the code of the interpreter:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"Bytecode::CastU8 => {\n    gas_meter.charge_simple_instr(S::CastU8)?;\n    let integer_value =\n        interpreter.operand_stack.pop_as::<IntegerValue>()?;\n    interpreter\n        .operand_stack\n        .push(Value::u8(integer_value.cast_u8()?))?;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We ignore the gas metering for now. The ",(0,r.jsx)(t.code,{children:"pop_as"})," method pops the top-most element of the stack and checks that it is an integer. The ",(0,r.jsx)(t.code,{children:"cast_u8"})," method checks that the integer is in the right range (",(0,r.jsx)(t.code,{children:"0"})," to ",(0,r.jsx)(t.code,{children:"255"}),") and returns the value as a ",(0,r.jsx)(t.code,{children:"U8"}),". The ",(0,r.jsx)(t.code,{children:"push"})," method pushes the value back on the stack. The question mark operator ",(0,r.jsx)(t.code,{children:"?"})," is used to propagate errors."]}),"\n",(0,r.jsx)(t.p,{children:"Here is the corresponding code in the type-checker:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"Bytecode::CastU8 => {\n    let operand = safe_unwrap_err!(verifier.stack.pop());\n    if !operand.is_integer() {\n        return Err(verifier.error(\n            StatusCode::INTEGER_OP_TYPE_MISMATCH_ERROR,\n            offset,\n        ));\n    }\n    verifier.push(meter, ST::U8)?;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["It pops the top-most element of the stack of types (we do not have values here) and checks that it is an integer type. If it is not, it returns an error. Otherwise, it pushes the type ",(0,r.jsx)(t.code,{children:"U8"})," on the stack. Note that there are no ways to know, in the type-checker, if the value is in the right range."]}),"\n",(0,r.jsx)(t.h2,{id:"-the-rocq-translation",children:"\ud83d\udc26\u200d\u2b1b The Rocq translation"}),"\n",(0,r.jsx)(t.p,{children:"In previous posts, we covered our manual translation of the Rust code in Rocq. We repeat it here. The interpreter code in Rocq:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"| Bytecode.CastU8 =>\n  letS!? integer_value := liftS! State.Lens.interpreter (\n    liftS! Interpreter.Lens.operand_stack $\n      Stack.Impl_Stack.pop_as IntegerValue.t\n  ) in\n  letS!? integer_value :=\n    returnS! $ IntegerValue.cast_u8 integer_value in\n  doS!? liftS! State.Lens.interpreter (\n    liftS! Interpreter.Lens.operand_stack $\n      Stack.Impl_Stack.push $\n      ValueImpl.U8 integer_value\n  ) in\n  returnS!? InstrRet.Ok\n"})}),"\n",(0,r.jsx)(t.p,{children:"The type-checker code in Rocq:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"| Bytecode.CastU8 => \n  letS! operand :=\n    liftS! TypeSafetyChecker.lens_self_stack AbstractStack.pop in\n  letS! operand := return!toS! $ safe_unwrap_err operand in\n  if negb $ SignatureToken.is_integer operand then\n    returnS! $\n      Result.Err $\n      TypeSafetyChecker.Impl_TypeSafetyChecker.error\n        verifier StatusCode.INTEGER_OP_TYPE_MISMATCH_ERROR offset\n  else\n    TypeSafetyChecker.Impl_TypeSafetyChecker.push SignatureToken.U8\n"})}),"\n",(0,r.jsx)(t.h2,{id:"-formal-statement",children:"\ud83d\udcdc Formal statement"}),"\n",(0,r.jsx)(t.p,{children:"Here is the formal statement of the property we want to prove to ensure the correctness of the type-checker:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Lemma progress\n  (* [...] parameters and hypothesis *)\n  (* We assume that the initial state is well-typed *)\n  IsInterpreterContextOfType.t locals interpreter type_safety_checker ->\n  match\n    verify_instr instruction pc type_safety_checker,\n    execute_instruction ty_args function resolver instruction state\n  with\n  | Panic.Value (Result.Ok _, type_safety_checker'),\n    Panic.Value (Result.Ok _, state') =>\n    let '{|\n      State.pc := _;\n      State.locals := locals';\n      State.interpreter := interpreter';\n    |} := state' in\n    IsInterpreterContextOfType.t locals' interpreter' type_safety_checker'\n  (* If the type-checker succeeds, then the interpreter cannot return a panic *)\n  | Panic.Value (Result.Ok _, _), Panic.Panic _ => False\n  (* Other errors are allowed *)\n  | Panic.Value (Result.Ok _, _), Panic.Value (Result.Err _, _)\n  | Panic.Value (Result.Err _, _), _\n  | Panic.Panic _, _ => True\n  end.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This lemma is in the file ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/proofs/move_bytecode_verifier/type_safety.v",children:"proofs/move_bytecode_verifier/type_safety.v"}),". It compares the behavior of the type-checker and the interpreter when executing an instruction. If the type-checker succeeds, then the interpreter cannot return a panic. If the interpreter also succeeds, then the new state is well-typed according to the types returned by the type-checker."]}),"\n",(0,r.jsx)(t.h2,{id:"\ufe0f-proof-time",children:"\ud83d\udee1\ufe0f Proof time"}),"\n",(0,r.jsxs)(t.p,{children:["We prove the statement above by reasoning about all possible instructions. For the ",(0,r.jsx)(t.code,{children:"CastU8"})," instruction, the Rocq proof is as follows:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"{ guard_instruction Bytecode.CastU8.\n  destruct_abstract_pop.\n  step; cbn; [exact I|].\n  destruct_abstract_push.\n  step; cbn; (try easy); (try now destruct operand_ty);\n    repeat (step; cbn; try easy);\n    constructor; cbn; try assumption;\n    sauto lq: on.\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Here is what this script does:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"guard_instruction Bytecode.CastU8"})," checks that the current instruction is ",(0,r.jsx)(t.code,{children:"CastU8"}),". This helps debugging if we are not at the right place."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"destruct_abstract_pop"})," pops the top-most element of the stack of types and gives it the name ",(0,r.jsx)(t.code,{children:"operand_ty"}),". It handles the cases where the stack is empty."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"step; cbn; [exact I|]"})," is a command to handle the next ",(0,r.jsx)(t.code,{children:"if"})," in the code of the type-checker. We are only interested in the success branch (",(0,r.jsx)(t.code,{children:"else"})," branch in this case)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"destruct_abstract_push"})," pushes the type ",(0,r.jsx)(t.code,{children:"U8"})," on the stack of types."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Then, there is a set of automated tactics iterating over all the possible types of values that can be on the stack. Just before the end of the proof, we have the following proof state:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"---------------------------------------\n(1/6)\nList.Forall2 IsValueImplOfType.t (ValueImpl.U8 z :: x0)\n  (SignatureToken.U8 :: AbstractStack.flatten stack_ty0)\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This proof state is repeated identically six times, once for each possible integer type (",(0,r.jsx)(t.code,{children:"U8"}),", ",(0,r.jsx)(t.code,{children:"U16"}),", ",(0,r.jsx)(t.code,{children:"U32"}),", ",(0,r.jsx)(t.code,{children:"U64"}),", ",(0,r.jsx)(t.code,{children:"U128"}),", ",(0,r.jsx)(t.code,{children:"U256"}),"). It says that the stack of values:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"ValueImpl.U8 z :: x0\n"})}),"\n",(0,r.jsx)(t.p,{children:"must have the stack of types:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"SignatureToken.U8 :: AbstractStack.flatten stack_ty0\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The value ",(0,r.jsx)(t.code,{children:"z"})," is the result of the ",(0,r.jsx)(t.code,{children:"cast_u8"})," function in the interpreter. The ",(0,r.jsx)(t.code,{children:"flatten"})," function is used to flatten the stack of types that may contain duplicates."]}),"\n",(0,r.jsx)(t.p,{children:"For the head of the stack the property is trivially true. For the tail of the stack, we use one of the hypotheses from the context, coming from the fact that the stack was initially well-typed and with did not modify the tail."}),"\n",(0,r.jsx)(t.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,r.jsxs)(t.p,{children:["We have show how to formally verify that the type-checker for the Move's bytecode virtual machine is correct on a simple instruction ",(0,r.jsx)(t.code,{children:"CastU8"}),". This is part of a larger effort to ensure the correctness of the whole type-checker."]}),"\n",(0,r.jsx)(t.p,{children:"Other instructions operating on atomic types (integers, booleans, addresses) are similar to this one. The most complex instructions are the ones operating on references and data structures like vectors and structs. These require more work, and we have not yet tackled them."}),"\n",(0,r.jsx)(t.admonition,{title:"For more",type:"success",children:(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.em,{children:["Follow us on ",(0,r.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,r.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions or requests!"]})})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},27183:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/green-forest-with-water-d585bfd8843e8c87210ace14398fae84.webp"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(96540);const s={},o=r.createContext(s);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);