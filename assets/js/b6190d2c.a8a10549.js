"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4559],{9552:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=t(4848),o=t(8453);const s={title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (1/3)",tags:["Rust","links","simulations"],authors:[]},r=void 0,a={permalink:"/blog/2025/01/30/links-for-rust-in-rocq",source:"@site/blog/2025-01-30-links-for-rust-in-rocq.md",title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (1/3)",description:"In this article we show how we re-build the type and naming information of \ud83e\udd80&nbsp;Rust code in &nbsp;Rocq/Coq, the formal verification system we use. A challenge is to be able to represent arbitrary Rust programs, including the standard library of Rust and the whole of Revm, a virtual machine to run EVM programs.",date:"2025-01-30T00:00:00.000Z",formattedDate:"January 30, 2025",tags:[{label:"Rust",permalink:"/blog/tags/rust"},{label:"links",permalink:"/blog/tags/links"},{label:"simulations",permalink:"/blog/tags/simulations"}],readingTime:7.485,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (1/3)",tags:["Rust","links","simulations"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (2/3)",permalink:"/blog/2025/02/05/links-for-rust-in-rocq-2"},nextItem:{title:"\ud83e\udd16 Designing a coding assistant for Rocq",permalink:"/blog/2025/01/21/designing-a-coding-assistant-for-rocq"}},l={authorsImageUrls:[]},c=[{value:"\ud83c\udfaf The challenge",id:"-the-challenge",level:2},{value:"\ud83d\udedd Strategy",id:"-strategy",level:2},{value:"\ud83e\uddea Example",id:"-example",level:2},{value:"\ud83d\udd2e Link&#39;s monad",id:"-links-monad",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In this article we show how we re-build the type and naming information of ",(0,i.jsx)(n.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"})," code in ",(0,i.jsxs)(n.a,{href:"https://rocq-prover.org/",children:[(0,i.jsx)("img",{src:"https://raw.githubusercontent.com/coq/rocq-prover.org/refs/heads/main/rocq-id/logos/SVG/icon-rocq-orange.svg",height:"18px"}),"\xa0Rocq/Coq"]}),", the formal verification system we use. A challenge is to be able to represent arbitrary Rust programs, including the standard library of Rust and the whole of ",(0,i.jsx)(n.a,{href:"https://github.com/bluealloy/revm",children:"Revm"}),", a virtual machine to run ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Ethereum#Virtual_machine",children:"EVM"})," programs."]}),"\n",(0,i.jsx)(n.p,{children:"This is the continuation of the following article:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/blog/2024/04/26/translation-core-alloc-crates",children:"\ud83e\udd80 Translation of the Rust's core and alloc crates"})}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{title:"Ask for the highest security!",type:"success",children:[(0,i.jsx)(n.p,{children:"When millions are at stake, bug bounties are not enough. How do you ensure your security audits are exhaustive?"}),(0,i.jsxs)(n.p,{children:["The best way is to use ",(0,i.jsx)(n.strong,{children:"formal verification"}),"."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Contact us"})," at\xa0",(0,i.jsx)(n.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"})," to make sure your code is safe!\xa0\ud83d\udee1\ufe0f"]}),(0,i.jsxs)(n.p,{children:["We cover ",(0,i.jsx)(n.strong,{children:"Rust"}),", ",(0,i.jsx)(n.strong,{children:"Solidity"}),", and ",(0,i.jsx)(n.strong,{children:"ZK systems"}),"."]})]}),"\n",(0,i.jsx)("figure",{children:(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Green forest",src:t(3423).A+"",width:"1024",height:"1024"})})}),"\n",(0,i.jsx)(n.h2,{id:"-the-challenge",children:"\ud83c\udfaf The challenge"}),"\n",(0,i.jsx)(n.p,{children:"Our goal is to be able to formally verify large Rust codebases, counting thousands of lines, and without having to modify the code to make it more amenable to formal verification. Our concrete example is the verification of the Revm that includes about 10,000 lines of Rust code, depending on how far we include the dependencies."}),"\n",(0,i.jsx)(n.p,{children:"This requires to have a methodology of verification that both:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Scales with the size of the codebase. Rust programs often use a lot of abstractions, and we make the choice to keep these abstractions in the formal model. Combined with the expressivity of the Rocq prover, we hope this will ensure we can scale our reasoning."}),"\n",(0,i.jsx)(n.li,{children:"Supports most of the Rust language, noting that Rust is a complex and feature-rich language."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["To make sure our translation from the Rust language to the Rocq system has good support, we generate a translation that is very verbose and rather low-level without interpreting the meaning of the various Rust primitives too much. For example, our translation tool is only about 5,000 lines long. It is written in Rust and uses the APIs of the ",(0,i.jsx)(n.code,{children:"rustc"})," compiler."]}),"\n",(0,i.jsx)(n.p,{children:"This approach leaves the burdens of defining the semantics of Rust and designing the reasoning primitives on the Rocq side."}),"\n",(0,i.jsx)(n.h2,{id:"-strategy",children:"\ud83d\udedd Strategy"}),"\n",(0,i.jsx)(n.p,{children:"We plan to reason on the translated Rust code with two intermediate steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Links"})," These represent a complete rewriting of the translated code, adding type and naming information that are erased during the translation to Rocq. We also prove that this rewriting is equivalent to the initial translation. We hope to automate this step as much as possible."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulations"})," In this step we make the less obvious transformations, in particular representing the memory mutations in a clean and custom state monad, as well as various optimizations such as collapsing all the integer types if it helps for the proofs later. We also prove that this rewriting is equivalent to the links."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["At the end of the ",(0,i.jsx)(n.strong,{children:"Simulations"})," step, we should obtain a purely functional and idiomatic representation of the original Rust code in Rocq. This representation should be easier to reason about, and we will be able to formally verify properties of the code."]}),"\n",(0,i.jsx)(n.p,{children:"As a summary, here are the steps we want to follow:"}),"\n",(0,i.jsx)("figure",{class:"text--center",children:(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Compilation steps",src:t(7867).A+"",width:"214",height:"696"})})}),"\n",(0,i.jsx)(n.h2,{id:"-example",children:"\ud83e\uddea Example"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example from the standard library of Rust, which is used to define other comparison operators:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n    match compare(&v1, &v2) {\n        Ordering::Less | Ordering::Equal => v2,\n        Ordering::Greater => v1,\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This example is interesting as it uses some abstractions, with polymorphism, traits, closures, and a bit of pointer manipulations. Ideally, we should be able to represent it with a Rocq code of a similar size, without the explicit references\xa0",(0,i.jsx)(n.code,{children:"&"})," that are mostly useless in a purely functional setting. But here is the Rocq code we obtain after running\xa0",(0,i.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:'Definition max_by (\u03b5 : list Value.t) (\u03c4 : list Ty.t) (\u03b1 : list Value.t) : M :=\n  match \u03b5, \u03c4, \u03b1 with\n  | [], [ T; F ], [ v1; v2; compare ] =>\n    ltac:(M.monadic\n      (let v1 := M.alloc (| v1 |) in\n      let v2 := M.alloc (| v2 |) in\n      let compare := M.alloc (| compare |) in\n      M.read (|\n        M.match_operator (|\n          M.alloc (|\n            M.call_closure (|\n              M.get_trait_method (|\n                "core::ops::function::FnOnce",\n                F,\n                [],\n                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ] ] ],\n                "call_once",\n                [],\n                []\n              |),\n              [\n                M.read (| compare |);\n                Value.Tuple\n                  [\n                    M.borrow (|\n                      Pointer.Kind.Ref,\n                      M.deref (| M.borrow (| Pointer.Kind.Ref, v1 |) |)\n                    |);\n                    M.borrow (|\n                      Pointer.Kind.Ref,\n                      M.deref (| M.borrow (| Pointer.Kind.Ref, v2 |) |)\n                    |)\n                  ]\n              ]\n            |)\n          |),\n          [\n            fun \u03b3 =>\n              ltac:(M.monadic\n                (M.find_or_pattern (|\n                  \u03b3,\n                  [\n                    fun \u03b3 =>\n                      ltac:(M.monadic\n                        (let _ := M.is_struct_tuple (| \u03b3, "core::cmp::Ordering::Less" |) in\n                        Value.Tuple []));\n                    fun \u03b3 =>\n                      ltac:(M.monadic\n                        (let _ := M.is_struct_tuple (| \u03b3, "core::cmp::Ordering::Equal" |) in\n                        Value.Tuple []))\n                  ],\n                  fun \u03b3 =>\n                    ltac:(M.monadic\n                      match \u03b3 with\n                      | [] => ltac:(M.monadic v2)\n                      | _ => M.impossible "wrong number of arguments"\n                      end)\n                |)));\n            fun \u03b3 =>\n              ltac:(M.monadic\n                (let _ := M.is_struct_tuple (| \u03b3, "core::cmp::Ordering::Greater" |) in\n                v1))\n          ]\n        |)\n      |)))\n  | _, _, _ => M.impossible "wrong number of arguments"\n  end.\n'})}),"\n",(0,i.jsx)(n.p,{children:"This is extremely verbose and not idiomatic for Rocq! We can see some of the Rust features that are made explicit:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The list of constant generics ",(0,i.jsx)(n.code,{children:"\u03b5"}),", the list of type generics ",(0,i.jsx)(n.code,{children:"\u03c4"}),", and the list of arguments ",(0,i.jsx)(n.code,{children:"\u03b1"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The memory operations ",(0,i.jsx)(n.code,{children:"alloc"})," and ",(0,i.jsx)(n.code,{children:"read"}),", and the pointers manipulations ",(0,i.jsx)(n.code,{children:"borrow"})," and ",(0,i.jsx)(n.code,{children:"deref"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The trait instance resolution with ",(0,i.jsx)(n.code,{children:"M.get_trait_method"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The decomposition of the pattern matching in more elementary operations like ",(0,i.jsx)(n.code,{children:"M.is_struct_tuple"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Most of this information comes from the ",(0,i.jsx)(n.a,{href:"https://rustc-dev-guide.rust-lang.org/thir.html",children:"THIR intermediate representation"})," of the code as provided by the Rust compiler."]}),"\n",(0,i.jsx)(n.p,{children:"Here is the link definition we will write, proven equivalent to the code above by construction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Definition run_max_by {T F : Set} `{Link T} `{Link F}\n    (Run_FnOnce_for_F :\n      function.FnOnce.Run\n        F\n        (Ref.t Pointer.Kind.Ref T * Ref.t Pointer.Kind.Ref T)\n        (Output := Ordering.t)\n    )\n    (v1 v2 : T) (compare : F) :\n  {{ cmp.max_by [] [ \u03a6 T; \u03a6 F ] [ \u03c6 v1; \u03c6 v2; \u03c6 compare ] \ud83d\udd3d T }}.\nProof.\n  destruct Run_FnOnce_for_F as [[call_once [H_call_once run_call_once]]].\n  run_symbolic.\n  eapply Run.CallPrimitiveGetTraitMethod. {\n    apply H_call_once.\n  }\n  run_symbolic.\n  eapply Run.CallClosure. {\n    apply (run_call_once compare (Ref.immediate _ v1, Ref.immediate _ v2)).\n  }\n  intros [ordering |]; cbn; [|run_symbolic].\n  destruct ordering; run_symbolic.\nDefined.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The beginning of the definition corresponds to the trait resolution and calls to the ",(0,i.jsx)(n.code,{children:"compare"})," function. The last part with ",(0,i.jsx)(n.code,{children:"destruct ordering"})," is the representation of the ",(0,i.jsx)(n.code,{children:"match"})," statement in the Rust code. With this definition, we add explicit Rocq types instead of the universal ",(0,i.jsx)(n.code,{children:"Value.t"})," type of the translated code and make explicit the trait resolution. The trait instance has to be provided as an explicit parameter with the ",(0,i.jsx)(n.code,{children:"Run_FnOnce_for_F"})," argument."]}),"\n",(0,i.jsx)(n.p,{children:"With the statement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"{{ cmp.max_by [] [ \u03a6 T; \u03a6 F ] [ \u03c6 v1; \u03c6 v2; \u03c6 compare ] \ud83d\udd3d T }}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["we say that the translated function ",(0,i.jsx)(n.code,{children:"cmp.max_by"}),' has a "link" definition, built implicitly in the proof, returning a value of type ',(0,i.jsx)(n.code,{children:"T"}),". We can extract the definition of this function calling the primitive:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"evaluate : forall {Output : Set} `{Link Output} {e : M},\n  {{ e \ud83d\udd3d Output }} ->\n  LowM.t (Output.t Output)\n"})}),"\n",(0,i.jsxs)(n.p,{children:['It returns a "link" computation in the ',(0,i.jsx)(n.code,{children:"LowM.t"}),' monad. The output is often unreadable as it is, but we can step through it by symbolic execution. This will be useful for the next step to define and prove equivalent the "simulations".']}),"\n",(0,i.jsx)(n.h2,{id:"-links-monad",children:"\ud83d\udd2e Link's monad"}),"\n",(0,i.jsxs)(n.p,{children:["Like the monad used for the translation of Rust programs by ",(0,i.jsx)(n.code,{children:"coq-of-rust"}),", the link's monad is a free monad but with fewer primitive operations. The primitive operations are only related to the memory handling:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Inductive t : Set -> Set :=\n| StateAlloc {A : Set} `{Link A} (value : A) : t (Ref.Core.t A)\n| StateRead {A : Set} `{Link A} (ref_core : Ref.Core.t A) : t A\n| StateWrite {A : Set} `{Link A} (ref_core : Ref.Core.t A) (value : A) : t unit\n| GetSubPointer {A Sub_A : Set} `{Link A} `{Link Sub_A}\n  (ref_core : Ref.Core.t A) (runner : SubPointer.Runner.t A Sub_A) :\n  t (Ref.Core.t Sub_A).\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Compared to the side effects in the generated translation, we eliminate all the operations related to name handling (trait resolution, function calls, etc.). We also always use explicit types instead of the universal ",(0,i.jsx)(n.code,{children:"Value.t"})," type and get rid of the ",(0,i.jsx)(n.code,{children:"M.impossible"})," operation that was necessary to represent impossible branches in the absence of types."]}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"We have presented our general strategy to formally verify large Rust codebases. In the next blog posts, we will go into more details to look at the definition of the proof of equivalence for the links, and at how we automate the most repetitive parts of the proofs."}),"\n",(0,i.jsx)(n.admonition,{title:"For more",type:"success",children:(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Follow us on ",(0,i.jsx)(n.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,i.jsx)(n.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions or requests!"]})})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},7867:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/compilation-steps-28e6722120c86d9e17aa05e4d38f1515.svg"},3423:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/green-forest-00d5ecf11d8ae6a919d6f5e8ce6aeb7e.webp"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);