"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[668],{85335:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var t=s(74848),a=s(28453);const i={title:"\ud83e\udd77 Semantics for LLZK in Rocq",tags:["LLZK","semantics","zero-knowledge"],authors:[]},r=void 0,l={permalink:"/blog/2025/07/30/llzk-to-rocq-semantics",source:"@site/blog/2025-07-30-llzk-to-rocq-semantics.md",title:"\ud83e\udd77 Semantics for LLZK in Rocq",description:"LLZK is a language designed to implement zero-knowledge circuits. We wrote a translation tool from this language to a representation in the formal language Rocq.",date:"2025-07-30T00:00:00.000Z",formattedDate:"July 30, 2025",tags:[{label:"LLZK",permalink:"/blog/tags/llzk"},{label:"semantics",permalink:"/blog/tags/semantics"},{label:"zero-knowledge",permalink:"/blog/tags/zero-knowledge"}],readingTime:6.26,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd77 Semantics for LLZK in Rocq",tags:["LLZK","semantics","zero-knowledge"],authors:[]},unlisted:!1,nextItem:{title:"\ud83e\udd77 Beginning of a formal verification tool for LLZK",permalink:"/blog/2025/07/28/llzk-to-rocq-beginning"}},o={authorsImageUrls:[]},c=[{value:"\ud83e\ude86 Data types",id:"-data-types",level:2},{value:"<code>Felt.t</code>",id:"feltt",level:3},{value:"<code>Array.t</code>",id:"arrayt",level:3},{value:"Structures",id:"structures",level:3},{value:"\ud83d\udd2e Monad",id:"-monad",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/Veridise/llzk-lib",children:"LLZK"})," is a language designed to implement ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Zero-knowledge_proof",children:"zero-knowledge"})," circuits. We wrote a translation tool from this language to a representation in the formal language ",(0,t.jsx)(n.a,{href:"https://rocq-prover.org/",children:"Rocq"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"In this blog post, we present how we give a semantics to all the primitive operations of LLZK in Rocq. The end-goal is to provide a way to formally verify that a zero-knowledge circuit is safe, that is to say, without under-constraints."}),"\n",(0,t.jsxs)(n.admonition,{title:"Follow-up",type:"info",children:[(0,t.jsx)(n.p,{children:"This blog post is a follow-up to:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/blog/2025/07/28/llzk-to-rocq-beginning",children:"\ud83e\udd77 Beginning of a formal verification tool for LLZK"})}),"\n"]}),(0,t.jsxs)(n.p,{children:["The code we are referring to in this post is available in ",(0,t.jsx)(n.a,{href:"https://github.com/formal-land/garden/tree/main/Garden/LLZK",children:"github.com/formal-land/garden/Garden/LLZK"}),"."]})]}),"\n",(0,t.jsxs)(n.admonition,{title:"Discuss with us!",type:"success",children:[(0,t.jsx)(n.p,{children:"The cost of a bug is extremely high in some industries (loss of life, loss of money, etc.), while there exist technologies like formal verification to make sure programs are correct for all cases."}),(0,t.jsxs)(n.p,{children:["Many companies and institutions like ",(0,t.jsx)(n.a,{href:"https://ethereum.org/",children:"Ethereum"})," are already using formal verification to secure their operations."]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Contact us"})," at\xa0",(0,t.jsx)(n.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"})," to discuss!\xa0\ud83d\udc4b"]})]}),"\n",(0,t.jsx)("figure",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Green forest",src:s(46126).A+"",width:"1024",height:"1024"})})}),"\n",(0,t.jsx)(n.h2,{id:"-data-types",children:"\ud83e\ude86 Data types"}),"\n",(0,t.jsx)(n.p,{children:"Here are the main data types that we see appearing in LLZK code examples:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Felt.t"}),", for integers modulo\xa0",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"p"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]})," a large prime number. We represent them with the type of unbounded integers ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{mathvariant:"double-struck",children:"Z"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathbb{Z}"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6889em"}}),(0,t.jsx)(n.span,{className:"mord mathbb",children:"Z"})]})})]}),", and explicitly compute the modulo on the result of each operation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"i1"}),", for boolean values. We represent them with the boolean type ",(0,t.jsx)(n.code,{children:"bool"})," of Rocq."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Index.t"})," for length or indexes in arrays. We represent them with the type ",(0,t.jsx)(n.code,{children:"nat"})," of Rocq (non-negative integers)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Array.t"})," for arrays, parametrized by a list of dimensions and a type of elements. We design a custom type for these."]}),"\n",(0,t.jsx)(n.li,{children:"Structures, defined in an LLZK module with a list of fields. We represent them with a record type in Rocq."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"feltt",children:(0,t.jsx)(n.code,{children:"Felt.t"})}),"\n",(0,t.jsxs)(n.p,{children:["We define the primitive arithmetic operations on ",(0,t.jsx)(n.code,{children:"Felt.t"})," as pure functions in Rocq, parametrized by an implicit prime number ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"p"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]}),". For example, for the binary operations we do:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Module BinOp.\n  Definition add {p} `{Prime p} (x y : Z) : Z :=\n    (x + y) mod p.\n\n  Definition sub {p} `{Prime p} (x y : Z) : Z :=\n    (x - y) mod p.\n\n  Definition mul {p} `{Prime p} (x y : Z) : Z :=\n    (x * y) mod p.\n\n  Definition div {p} `{Prime p} (x y : Z) : Z :=\n    (x / y) mod p.\n\n  Definition mod_ {p} `{Prime p} (x y : Z) : Z :=\n    (x mod y) mod p.\nEnd BinOp.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We do not check if the parameters are in the bounds ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mn,{children:"0"}),(0,t.jsx)(n.mo,{children:"\u2264"}),(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mo,{children:"<"}),(0,t.jsx)(n.mi,{children:"p"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"0 \\leq n < p"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.7804em",verticalAlign:"-0.136em"}}),(0,t.jsx)(n.span,{className:"mord",children:"0"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mrel",children:"\u2264"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.5782em",verticalAlign:"-0.0391em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mrel",children:"<"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})]})]}),", but we apply the modulo operation on the result of each function. This is a convention that we will try to use for the rest of the formalizations."]}),"\n",(0,t.jsx)(n.h3,{id:"arrayt",children:(0,t.jsx)(n.code,{children:"Array.t"})}),"\n",(0,t.jsxs)(n.p,{children:["We represent arrays as a record wrapping a ",(0,t.jsx)(n.code,{children:"get"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Record t {A : Set} {Ns : list nat} := {\n  get : MultiIndex.t Ns -> A;\n}.\nArguments t : clear implicits.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We use a function rather than a list, as in our experience, for many zero-knowledge circuits, there exists an expression relating the values in an array to their indices. A limitation is that we need to find a default value for out-of-bounds indexes. This is generally easy to find, as most data structures are built around the ",(0,t.jsx)(n.code,{children:"Felt.t"})," type with zero as a default value."]}),"\n",(0,t.jsxs)(n.p,{children:["Because arrays can be multi-dimensional, define a type for multi-dimensional indices instead of using a plain ",(0,t.jsx)(n.code,{children:"nat"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Module MultiIndex.\n  Fixpoint t (Ns : list nat) : Set :=\n    match Ns with\n    | nil => unit\n    | _ :: Ns => Index.t * t Ns\n    end.\nEnd MultiIndex.\n"})}),"\n",(0,t.jsx)(n.p,{children:"A multi-index is simply a tuple with as many integers as there are dimensions. We prefer to use an array with multi-indices instead of arrays of arrays, in order to have a representation following the choices of LLZK."}),"\n",(0,t.jsxs)(n.p,{children:["There is an ",(0,t.jsx)(n.code,{children:"array.extract"})," operator in LLZK, to extract a sub-array from an array, which isgeneralized to the case of multidimensional arrays. We define it as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Definition extract {A : Set} {Ns Ms : list nat}\n    (array : t A (Ns ++ Ms))\n    (indexes : MultiIndex.t Ns) :\n    t A Ms :=\n  {|\n    get indexes' := array.(get) (MultiIndex.concat indexes indexes');\n  |}.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It takes an array whose multi-dimension is a list of dimensions ",(0,t.jsx)(n.code,{children:"Ns"})," followed by dimensions ",(0,t.jsx)(n.code,{children:"Ms"}),". It returns a sub-array whose multi-dimension is ",(0,t.jsx)(n.code,{children:"Ms"}),". It relies on an operator ",(0,t.jsx)(n.code,{children:"MultiIndex.concat"})," to concatenate two multi-indexes of the right dimensions:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Fixpoint concat {Ns Ms : list nat}\n    (indexes : MultiIndex.t Ns)\n    (indexes' : MultiIndex.t Ms) :\n    MultiIndex.t (Ns ++ Ms) :=\n  match Ns, indexes with\n  | nil, _ => indexes'\n  | _ :: Ns, (index, indexes) => (index, concat indexes indexes')\n  end.\n"})}),"\n",(0,t.jsx)(n.h3,{id:"structures",children:"Structures"}),"\n",(0,t.jsxs)(n.p,{children:["We found that directly using the ",(0,t.jsx)(n.code,{children:"Record"})," construct of Rocq to represent structures was enough. Here is how a typical structure is defined in LLZK:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mlir",children:"struct.def @MatrixConstrain {\n    struct.field @check0 : !struct.type<@ArrayConstrain<[7, 11]>>\n    struct.field @check1 : !struct.type<@ArrayConstrain<[13, 17]>>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is translated to a record type in Rocq:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Module MatrixConstrain.\n  Record t : Set := {\n    check0 : ArrayConstrain.t 7 11;\n    check1 : ArrayConstrain.t 13 17;\n  }.\nEnd MatrixConstrain.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-monad",children:"\ud83d\udd2e Monad"}),"\n",(0,t.jsxs)(n.p,{children:["While we try to represent as many operations as possible in the purely functional fragment of Rocq, since it simplifies formal reasoning, for some operations we must use a monad. The main monadic operation is the check of equality between two integers modulo ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"p"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]}),". This is the main building block for circuits, to ensure that only valid witnesses are accepted."]}),"\n",(0,t.jsx)(n.p,{children:"We design our monad as a free-monad, in order to be able to define the reasoning rules independently:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-coq",children:"Module M.\n  Inductive t : Set -> Set :=\n  | Pure {A : Set} (value : A) : t A\n  | AssertEqual {A : Set} (x1 x2 : A) : t unit\n  | AssertIn {A : Set} {Ns : list nat} (x : A) (array : Array.t A Ns) : t unit\n  | AssertBool (value : bool) : t unit\n  | CreateStruct {A : Set} : t A\n  | ArrayWrite {A : Set} {Ns : list nat}\n      (array : Array.t A Ns)\n      (indexes : Array.MultiIndex.t Ns)\n      (value : A) :\n      t unit\n  | FieldWrite {A : Set} (field : A) (value : A) : t unit\n  | Let {A B : Set} (e : t A) (k : A -> t B) : t B\n  .\nEnd M.\n"})}),"\n",(0,t.jsx)(n.p,{children:"The two standard monadic operators are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Pure"})," that we note ",(0,t.jsx)(n.code,{children:"M.Pure"}),", and"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Let"})," that we note ",(0,t.jsx)(n.code,{children:"let* x := ... in ..."}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We also define some primitives, in particular:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AssertEqual"})," typically used to enforce the equality between two integers modulo ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"p"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AssertIn"})," to check that an element is in an array."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CreateStruct"})," to instantiate a value for a structure in a non-deterministic way. The structure is to be defined in subsequent write operations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"FieldWrite"})," to write a value in a field of a structure and force its definition."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"We have seen how to define the main primitives for the LLZK language in Rocq. In the upcoming blog posts, we will show how to reason about LLZK circuits in Rocq, thanks to the introduction of reasoning rules for each monadic operation."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["You want to secure your code? Contact us! \u21e8 ",(0,t.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"For more",type:"success",children:(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Follow us on ",(0,t.jsx)(n.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,t.jsx)(n.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions!"]})})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},46126:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/green_forest-f8954bcc184f52fe93fea331b1453bf2.png"},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);