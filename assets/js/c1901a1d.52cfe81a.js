"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8121],{4299:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var n=o(4848),r=o(8453);const i={id:"revm-project",title:"Revm Project"},s=void 0,a={id:"tools/coq-of-rust/revm-project",title:"Revm Project",description:"All the code of this project is available on github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/revm",source:"@site/docs/tools/coq-of-rust/revm-project.md",sourceDirName:"tools/coq-of-rust",slug:"/tools/coq-of-rust/revm-project",permalink:"/docs/tools/coq-of-rust/revm-project",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"revm-project",title:"Revm Project"},sidebar:"sidebar",previous:{title:"\ud83e\udd80 coq-of-rust",permalink:"/docs/tools/coq-of-rust/introduction"},next:{title:"Links",permalink:"/docs/tools/coq-of-rust/links"}},c={},l=[{value:"\ud83c\udf81 What we have",id:"-what-we-have",level:2},{value:"\ud83c\udfaf Next target",id:"-next-target",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.admonition,{title:"The source",type:"tip",children:(0,n.jsxs)(t.p,{children:["All the code of this project is available on ",(0,n.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/revm",children:"github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/revm"})]})}),"\n",(0,n.jsxs)(t.p,{children:["The goal of this project is to apply the formal verification tool for Rust ",(0,n.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:(0,n.jsx)(t.strong,{children:"coq-of-rust"})})," to formally verify a functional specification of ",(0,n.jsx)(t.a,{href:"https://github.com/bluealloy/revm",children:"Revm"})," that is a Rust implementation of the Ethereum Virtual Machine (EVM)."]}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["This project is funded by the ",(0,n.jsx)(t.a,{href:"https://ethereum.foundation/",children:"Ethereum Foundation"}),", to whom we are grateful."]})}),"\n",(0,n.jsxs)(t.p,{children:["The general mechanism we take to verify Rust code with ",(0,n.jsx)(t.a,{href:"https://rocq-prover.org/",children:"Rocq"})," is as follows:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Make an automated translation of the Rust source code of Revm to Rocq using ",(0,n.jsx)(t.code,{children:"coq-of-rust"}),". This translation is as straightforward as possible \ud83c\udfce\ufe0f."]}),"\n",(0,n.jsx)(t.li,{children:'Make a refinement of the translated code that we code a "link" \ud83d\udd17, that is equivalent to the original code but with type information and name resolution added back. There information are lost during the translation, as it is hard to come up with a general way to keep them.'}),"\n",(0,n.jsx)(t.li,{children:'Make a second refinement to a purely functional or monadic code, that we call a "simulation". This is the step in which we handle the memory \ud83d\udc18.'}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Why don't we use other existing tools? We want to verify the code of Revm without modifications. As it uses many advanced Rust features (traits with associated types, a bit of unsafe code, and more generally a large code base), we needed to design a process that can handle all this complexity. As this space is constantly evolving, we are happy to hear about alternative tooling to handle the Revm project!"}),"\n",(0,n.jsx)(t.h2,{id:"-what-we-have",children:"\ud83c\udf81 What we have"}),"\n",(0,n.jsxs)(t.p,{children:['Currently, we have a translation in Rocq of the Revm that compiles. We mainly focused on the "link" step, with the definition of a link for the ',(0,n.jsx)(t.code,{children:"ADD"})," instruction implementation:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub fn add<WIRE: InterpreterTypes, H: Host + ?Sized>(\n    interpreter: &mut Interpreter<WIRE>,\n    _host: &mut H,\n) {\n    gas!(interpreter, gas::VERYLOW);\n    popn_top!([op1], op2, interpreter);\n    *op2 = op1.wrapping_add(*op2);\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["You can find this code in the ",(0,n.jsx)(t.a,{href:"https://github.com/bluealloy/revm/blob/main/crates/interpreter/src/instructions/arithmetic.rs",children:"arithmetic.rs"})," file from the Revm project. Note the use of the macros ",(0,n.jsx)(t.code,{children:"gas!"})," and ",(0,n.jsx)(t.code,{children:"popn_top!"})," which generate a bit more code than it seems. Our link is in ",(0,n.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/instructions/links/arithmetic.v",children:"arithmetic.v"})," with:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-coq",children:"Definition run_add\n    {WIRE H : Set} `{Link WIRE} `{Link H}\n    {WIRE_types : InterpreterTypes.Types.t} `{InterpreterTypes.Types.AreLinks WIRE_types}\n    (run_InterpreterTypes_for_WIRE : InterpreterTypes.Run WIRE WIRE_types)\n    (interpreter : Ref.t Pointer.Kind.MutRef (Interpreter.t WIRE WIRE_types))\n    (_host : Ref.t Pointer.Kind.MutRef H) :\n  {{\n    instructions.arithmetic.add [] [ \u03a6 WIRE; \u03a6 H ] [ \u03c6 interpreter; \u03c6 _host ] \ud83d\udd3d\n    unit\n  }}.\n"})}),"\n",(0,n.jsxs)(t.p,{children:["followed by a proof script that is mostly about calling automated tactics. It states that the function ",(0,n.jsx)(t.code,{children:"instructions.arithmetic.add"}),", that is translated by ",(0,n.jsx)(t.code,{children:"coq-of-rust"})," from the source of Revm, reduces to some value of type ",(0,n.jsx)(t.code,{children:"unit"})," given parameters of the right type."]}),"\n",(0,n.jsxs)(t.p,{children:["One difficulty to type this function was the use of the ",(0,n.jsx)(t.code,{children:"InterpreterTypes"})," trait that is essentially a container holding other types, through the use of associated types in traits. Here is its definition in Rust:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"pub trait InterpreterTypes {\n    type Stack: StackTr;\n    type Memory: MemoryTr;\n    type Bytecode: Jumps + Immediates + LegacyBytecode + EofData + EofContainer + EofCodeInfo;\n    type ReturnData: ReturnData;\n    type Input: InputsTr;\n    type SubRoutineStack: SubRoutineStack;\n    type Control: LoopControl;\n    type RuntimeFlag: RuntimeFlag;\n    type Extend;\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Thanks to the flexibility of the type system of Rocq, we still found a way to represent this kind of construct we the above."}),"\n",(0,n.jsx)(t.h2,{id:"-next-target",children:"\ud83c\udfaf Next target"}),"\n",(0,n.jsx)(t.p,{children:"Our next target is to fully handle a simplified version of Revm with only three instructions (the actual total is around 150) to make the code more manageable."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>a});var n=o(6540);const r={},i=n.createContext(r);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);