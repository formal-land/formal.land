"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2864],{4593:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=n(4848),t=n(8453);const i={title:"\u2688 Verification of the Smoo.th library \u2013 1",tags:["Solidity","Yul","elliptic curves"],authors:[]},l=void 0,r={permalink:"/blog/2024/10/21/verification-smooth-library-1",source:"@site/blog/2024-10-21-verification-smooth-library-1.md",title:"\u2688 Verification of the Smoo.th library \u2013 1",description:"In this blog post, we present the formal verification effort we started to show the absence of bugs in the \u2688&nbsp;Smoo.th library, a library for optimized \u3030\ufe0f&nbsp;elliptic curve operations in Solidity. We are using our tool coq-of-solidity to make this non-trivial verification using the generic proof assistant \ud83d\udc13&nbsp;Coq.",date:"2024-10-21T00:00:00.000Z",formattedDate:"October 21, 2024",tags:[{label:"Solidity",permalink:"/blog/tags/solidity"},{label:"Yul",permalink:"/blog/tags/yul"},{label:"elliptic curves",permalink:"/blog/tags/elliptic-curves"}],readingTime:10.45,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\u2688 Verification of the Smoo.th library \u2013 1",tags:["Solidity","Yul","elliptic curves"],authors:[]},unlisted:!1,prevItem:{title:"\ud83c\udf32 What we bring you",permalink:"/blog/2024/10/22/what-we-bring-to-you"},nextItem:{title:"\ud83e\ude81 Enhancements to coq-of-solidity \u2013 1",permalink:"/blog/2024/10/16/coq-of-solidity-enhanced-version-1"}},o={authorsImageUrls:[]},d=[{value:"\ud83d\uddfa\ufe0f Design of the library",id:"\ufe0f-design-of-the-library",level:2},{value:"\ud83d\udc13 Translation to Coq",id:"-translation-to-coq",level:2},{value:"\ud83d\udd2c What we verified",id:"-what-we-verified",level:2},{value:"\ud83d\udc40 What remains to be done",id:"-what-remains-to-be-done",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function c(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",msub:"msub",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.p,{children:["In this blog post, we present the formal verification effort we started to show the absence of bugs in the ",(0,a.jsx)(s.a,{href:"https://smoo.th/",children:"\u2688\xa0Smoo.th"})," library, a library for optimized ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Elliptic_curve",children:"\u3030\ufe0f\xa0elliptic curve"})," operations in ",(0,a.jsx)(s.a,{href:"https://soliditylang.org/",children:"Solidity"}),". We are using our tool ",(0,a.jsx)(s.a,{href:"https://github.com/formal-land/coq-of-solidity",children:"coq-of-solidity"})," to make this non-trivial verification using the generic proof assistant ",(0,a.jsx)(s.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.strong,{children:"Smoo.th"})," library is interesting as elliptic curves are at the core of many cryptographic protocols, including authentication protocols, and having a generic and fast implementation simplifies the development of ",(0,a.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Decentralized_application",children:"dApps"})," in environments with missing pre-compiled (like L1s) or missing circuits (like zero-knowledge layers)."]}),"\n",(0,a.jsxs)(s.p,{children:["From a verification point of view, it is very challenging as it combines low-level operations (hand-optimized ",(0,a.jsx)(s.a,{href:"https://docs.soliditylang.org/en/latest/yul.html",children:"Yul"})," code with bit shifts, inlined functions, ...) with higher-level reasoning on elliptic curves and arithmetic\xa0\ud83d\udcaa."]}),"\n",(0,a.jsxs)(s.admonition,{title:"Get started",type:"success",children:[(0,a.jsxs)(s.p,{children:["To ensure your code is secure today, contact us at\xa0",(0,a.jsx)(s.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"}),"!\xa0\ud83d\ude80"]}),(0,a.jsxs)(s.p,{children:["Formal verification goes further than traditional audits to make 100% sure you cannot lose your funds, thanks to a ",(0,a.jsx)(s.strong,{children:"mathematical reasoning on the code"}),". It can be integrated into your CI pipeline to check that every commit is fully correct ",(0,a.jsx)(s.strong,{children:"without doing a whole audit again"}),"."]}),(0,a.jsxs)(s.p,{children:["We make bugs such as the ",(0,a.jsx)(s.a,{href:"https://www.gemini.com/fr-fr/cryptopedia/the-dao-hack-makerdao",children:"DAO hack"})," ($60 million stolen) virtually ",(0,a.jsx)(s.strong,{children:"impossible to happen again"}),"."]})]}),"\n",(0,a.jsx)("figure",{children:(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"Panda in forest",src:n(6837).A+"",width:"1024",height:"1024"})})}),"\n",(0,a.jsx)(s.h2,{id:"\ufe0f-design-of-the-library",children:"\ud83d\uddfa\ufe0f Design of the library"}),"\n",(0,a.jsxs)(s.p,{children:["The library is implemented in ",(0,a.jsx)(s.a,{href:"https://github.com/get-smooth/crypto-lib/blob/main/src/elliptic/SCL_mulmuladdX_fullgen_b4.sol",children:"SCL_mulmuladdX_fullgen_b4.sol"})," mostly in Yul. Given two points ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"G"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"G"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"G"})]})})]})," and ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"Q"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"Q"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"Q"})]})})]})," on an elliptic curve in the field ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsxs)(s.msub,{children:[(0,a.jsx)(s.mi,{mathvariant:"double-struck",children:"F"}),(0,a.jsx)(s.mi,{children:"p"})]})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\mathbb{F}_p"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.975em",verticalAlign:"-0.2861em"}}),(0,a.jsxs)(s.span,{className:"mord",children:[(0,a.jsx)(s.span,{className:"mord mathbb",children:"F"}),(0,a.jsx)(s.span,{className:"msupsub",children:(0,a.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(s.span,{className:"vlist-r",children:[(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.1514em"},children:(0,a.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,a.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(s.span,{className:"mord mathnormal mtight",children:"p"})})]})}),(0,a.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(s.span,{className:"vlist-r",children:(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.2861em"},children:(0,a.jsx)(s.span,{})})})]})})]})]})})]})," and two scalars ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"u"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"u"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"u"})]})})]})," and ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"v"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"v"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"})]})})]}),", it computes the following operation:"]}),"\n",(0,a.jsx)(s.span,{className:"katex-display",children:(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"u"}),(0,a.jsx)(s.mo,{children:"\u22c5"}),(0,a.jsx)(s.mi,{children:"G"}),(0,a.jsx)(s.mo,{children:"+"}),(0,a.jsx)(s.mi,{children:"v"}),(0,a.jsx)(s.mo,{children:"\u22c5"}),(0,a.jsx)(s.mi,{children:"Q"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"u \\cdot G + v \\cdot Q"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4445em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"u"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.7667em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"G"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"+"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4445em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"Q"})]})]})]})}),"\n",(0,a.jsxs)(s.p,{children:["where the points are represented as ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsx)(s.mi,{children:"x"}),(0,a.jsx)(s.mo,{separator:"true",children:","}),(0,a.jsx)(s.mi,{children:"y"}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"(x, y)"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"x"}),(0,a.jsx)(s.span,{className:"mpunct",children:","}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,a.jsx)(s.span,{className:"mclose",children:")"})]})})]})," coordinates, the scalars are integers, and the curve is described in the short Weierstrass form."]}),"\n",(0,a.jsx)(s.p,{children:"Here is a diagram to summarize the workflow of the library\xa0\ud83e\udd13:"}),"\n",(0,a.jsx)("figure",{children:(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"Smoo.th workflow",src:n(6490).A+"",width:"276",height:"782"})})}),"\n",(0,a.jsxs)(s.p,{children:["You can find more details about the algorithms used in the library in the complete ",(0,a.jsx)(s.a,{href:"https://github.com/get-smooth/crypto-lib/blob/main/doc/Audits/CRX_smooth_report_2024_07_11_v1.2.pdf",children:"audit report"})," by ",(0,a.jsx)(s.a,{href:"https://www.cryptoexperts.com/",children:"CryptoExperts"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["Our goal is to show that all these steps are equivalent to doing the naive operation of adding the points ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"u"}),(0,a.jsx)(s.mo,{children:"\u22c5"}),(0,a.jsx)(s.mi,{children:"G"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"u \\cdot G"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4445em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"u"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"G"})]})]})]})," and ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"v"}),(0,a.jsx)(s.mo,{children:"\u22c5"}),(0,a.jsx)(s.mi,{children:"Q"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"v \\cdot Q"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4445em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"Q"})]})]})]})," on the elliptic curve, ignoring a higher gas consumption and that the library is then free of bugs. Note that there are a few exceptional points, for example, when ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"G"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"G"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"G"})]})})]})," is the opposite of ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"Q"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"Q"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"Q"})]})})]}),", where the library does not work as it is and runs another algorithm instead. We need to make these points explicit in the proof and assume we are not in these special cases."]}),"\n",(0,a.jsx)(s.h2,{id:"-translation-to-coq",children:"\ud83d\udc13 Translation to Coq"}),"\n",(0,a.jsxs)(s.p,{children:["In order to formally verify that the code is correct for any possible inputs, we need to first translate it to a proof language, in our case Coq. We run our tool ",(0,a.jsx)(s.code,{children:"coq-of-solidity"})," on the optimized Yul code as generated by the Solidity compiler, that optimizes further the already hand-optimized code of the library. All our verification work is available on GitHub in the folder ",(0,a.jsx)(s.a,{href:"https://github.com/formal-land/coq-of-solidity/tree/develop/coq/CoqOfSolidity/contracts/scl/mulmuladdX_fullgen_b4",children:"coq/CoqOfSolidity/contracts/scl/mulmuladdX_fullgen_b4"})," of the ",(0,a.jsx)(s.a,{href:"https://github.com/formal-land/coq-of-solidity",children:"coq-of-solidity's repository"}),"."]}),"\n",(0,a.jsx)(s.p,{children:"Here is an example of hand-written Yul code from the contract, to compute the most-significant bit from the scalars:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-go",children:"ZZZ := 0\nfor {} iszero(ZZZ) { mask := shr(1, mask) } {\n  ZZZ := add(\n    add(\n      sub(1, iszero(and(scalar_u, mask))),\n      shl(1, sub(1, iszero(and(shr(128, scalar_u), mask))))\n    ),\n    add(\n      shl(2, sub(1, iszero(and(scalar_v, mask)))),\n      shl(3, sub(1, iszero(and(shr(128, scalar_v), mask))))\n    )\n  )\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"The Yul code after optimization by the Solidity compiler is:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-go",children:"mstore(0xe0, 0)\nfor { } iszero(mload(0xe0)) { mstore(0x01a0, shr(1, mload(0x01a0))) } {\n    mstore(0xe0, add(\n      add(\n        sub(1, iszero(and(mload(0x0120), mload(0x01a0)))),\n        shl(1, sub(1, iszero(and(shr(128, mload(0x0120)), mload(0x01a0)))))\n      ),\n      add(\n        shl(2, sub(1, iszero(and(mload(0x0160), mload(0x01a0))))),\n        shl(3, sub(1, iszero(and(shr(128, mload(0x0160)), mload(0x01a0)))))\n      )\n    ))\n}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["As we can see, the variable names were replaced by fixed memory addresses. As we can see, this will make the verification more complex. The Coq code that we generate with ",(0,a.jsx)(s.code,{children:"coq-of-solidity"})," is:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-coq",children:"do~ [[ mstore ~(| 0xe0, 0 |) ]] in\nlet_state~ 'tt :=\n  (* for loop *)\n  Shallow.for_\n    (* init state *)\n    tt\n    (* condition *)\n    (fun 'tt => [[\n      iszero ~(| mload ~(| 0xe0 |) |)\n    ]])\n    (* body *)\n    (fun 'tt =>\n      do~ [[\n        mstore ~(| 0xe0, add ~(|\n          add ~(|\n            sub ~(| 1, iszero ~(| and ~(| mload ~(| 0x0120 |), mload ~(| 0x01a0 |) |) |) |),\n            shl ~(| 1, sub ~(| 1, iszero ~(| and ~(| shr ~(| 128, mload ~(| 0x0120 |) |), mload ~(| 0x01a0 |) |) |) |) |)\n          |),\n          add ~(|\n            shl ~(| 2, sub ~(| 1, iszero ~(| and ~(| mload ~(| 0x0160 |), mload ~(| 0x01a0 |) |) |) |) |),\n            shl ~(| 3, sub ~(| 1, iszero ~(| and ~(| shr ~(| 128, mload ~(| 0x0160 |) |), mload ~(| 0x01a0 |) |) |) |) |)\n          |)\n        |) |)\n      ]] in\n      M.pure (BlockUnit.Tt, tt))\n    (* post *)\n    (fun 'tt =>\n      do~ [[ mstore ~(| 0x01a0, shr ~(| 1, mload ~(| 0x01a0 |) |) |) ]] in\n      M.pure (BlockUnit.Tt, tt))\ndefault~ tt in\n"})}),"\n",(0,a.jsxs)(s.p,{children:["We use a monadic notation ",(0,a.jsx)(s.code,{children:"f ~(| x1, ..., xn |)"})," to represent the side-effects of the EVM, such as memory read and write with ",(0,a.jsx)(s.code,{children:"mload"})," and ",(0,a.jsx)(s.code,{children:"mstore"}),". The function ",(0,a.jsx)(s.code,{children:"Shallow.for_"})," represents a for loop with an initial state, a condition, a body, and a post-action. We implement it using a primitive from our monad to represent potentially non-terminating loops."]}),"\n",(0,a.jsxs)(s.p,{children:["Here the proper state of the loop is empty (value ",(0,a.jsx)(s.code,{children:"tt"}),") and we instead modify the memory with ",(0,a.jsx)(s.code,{children:"mload"}),". Ideally we should have ",(0,a.jsx)(s.code,{children:"(ZZZ, mask)"})," as the state of the loop to simplify the verification. For our next attempt at verifying this code, we will look at the Yul code generated before optimizations by the Solidity compiler in order to keep these variables."]}),"\n",(0,a.jsx)(s.h2,{id:"-what-we-verified",children:"\ud83d\udd2c What we verified"}),"\n",(0,a.jsx)(s.p,{children:"We are not done yet with the verification of this library. For now, we have verified that:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["The addition operation ",(0,a.jsx)(s.code,{children:"ecAddn2"})," is implemented as specified."]}),"\n",(0,a.jsxs)(s.li,{children:["The doubling and negation operation ",(0,a.jsx)(s.code,{children:"ecDblNeg"})," is implemented as in the specification, in an inlined manner."]}),"\n",(0,a.jsx)(s.li,{children:"The pre-computations of the sums of the possible combinations of points are correct."}),"\n",(0,a.jsx)(s.li,{children:"The retrieval of the pre-computed sums from the current bits of the scalars is correct."}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["For example, here is our statement for the execution of the ",(0,a.jsx)(s.code,{children:"ecAddn2"})," operation:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-coq",children:"Lemma run_usr'dollar'ecAddn2 codes environment state\n    (P1_X P1_Y P1_ZZ P1_ZZZ P2_X P2_Y : U256.t) (p : U256.t) :\n  let output :=\n    ecAddn2 p\n      {| PZZ.X := P1_X; PZZ.Y := P1_Y; PZZ.ZZ := P1_ZZ; PZZ.ZZZ := P1_ZZZ |}\n      {| PA.X := P2_X; PA.Y := P2_Y |} in\n  let output := Result.Ok (output.(PZZ.X), output.(PZZ.Y), output.(PZZ.ZZ), output.(PZZ.ZZZ)) in\n  {{? codes, environment, Some state |\n    Contract_91.Contract_91_deployed.usr'dollar'ecAddn2 P1_X P1_Y P1_ZZ P1_ZZZ P2_X P2_Y p \u21d3\n    output\n  | Some state ?}}.\n"})}),"\n",(0,a.jsxs)(s.p,{children:["It says that in a given environment (",(0,a.jsx)(s.code,{children:"codes"}),", ",(0,a.jsx)(s.code,{children:"environment"}),", ",(0,a.jsx)(s.code,{children:"state"}),"), the execution of the translated function ",(0,a.jsx)(s.code,{children:"Contract_91.Contract_91_deployed.usr'dollar'ecAddn2"})," gives the same result as a hand-written purely functional version ",(0,a.jsx)(s.code,{children:"ecAddn2"})," operating on data types directly representing the curve points (",(0,a.jsx)(s.code,{children:"PZZ.t"})," and ",(0,a.jsx)(s.code,{children:"PA.t"}),")."]}),"\n",(0,a.jsx)(s.p,{children:"We verify this execution in a straightforward way by unfolding the definition and executing it step by step:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-coq",children:"Proof.\n  simpl.\n  unfold Contract_91.Contract_91_deployed.usr'dollar'ecAddn2.\n  l. {\n    repeat (l; [repeat cu; p|]).\n    p.\n  }\n  p.\nQed.\n"})}),"\n",(0,a.jsxs)(s.p,{children:["For the verification of the inlined",(0,a.jsx)(s.code,{children:"ecDblNeg"})," operation, here is the memory state just after computing the coordinates of the doubled point:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-coq",children:"[\n  mem0; mem1; Pure.add 0 2048; mem3; mem4;\n  Pure.addmod\n    (Pure.mulmod\n        (Pure.addmod (Pure.mulmod 3 (Pure.mulmod P_127.(PZZ.X) P_127.(PZZ.X) p) p)\n          (Pure.mulmod a (Pure.mulmod P_127.(PZZ.ZZ) P_127.(PZZ.ZZ) p) p) p)\n        (Pure.addmod (Pure.mulmod 3 (Pure.mulmod P_127.(PZZ.X) P_127.(PZZ.X) p) p)\n          (Pure.mulmod a (Pure.mulmod P_127.(PZZ.ZZ) P_127.(PZZ.ZZ) p) p) p) p)\n    (Pure.mulmod (Pure.sub p 2)\n        (Pure.mulmod P_127.(PZZ.X) (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) p) p) p;\n  Pure.mulmod P_127.(PZZ.X) (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) p;\n  Pure.mulmod\n    (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) p)\n    P_127.(PZZ.ZZZ) p;\n  Pure.addmod\n    (Pure.mulmod\n        (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) p)\n        P_127.(PZZ.Y) p)\n    (Pure.mulmod\n        (Pure.addmod (Pure.mulmod 3 (Pure.mulmod P_127.(PZZ.X) P_127.(PZZ.X) p) p)\n          (Pure.mulmod a (Pure.mulmod P_127.(PZZ.ZZ) P_127.(PZZ.ZZ) p) p) p)\n        (Pure.addmod\n          (Pure.addmod\n              (Pure.mulmod\n                (Pure.addmod (Pure.mulmod 3 (Pure.mulmod P_127.(PZZ.X) P_127.(PZZ.X) p) p)\n                    (Pure.mulmod a (Pure.mulmod P_127.(PZZ.ZZ) P_127.(PZZ.ZZ) p) p) p)\n                (Pure.addmod (Pure.mulmod 3 (Pure.mulmod P_127.(PZZ.X) P_127.(PZZ.X) p) p)\n                    (Pure.mulmod a (Pure.mulmod P_127.(PZZ.ZZ) P_127.(PZZ.ZZ) p) p) p) p)\n              (Pure.mulmod (Pure.sub p 2)\n                (Pure.mulmod P_127.(PZZ.X) (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) p) p) p)\n          (Pure.sub p (Pure.mulmod P_127.(PZZ.X) (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) p))\n          p) p) p;\n  HighLow.merge u_high u_low; 480; HighLow.merge v_high v_low; Pure.add 0 2048; 2 ^ 126;\n  Pure.mulmod (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) P_127.(PZZ.ZZ) p;\n  p; Q.(PA.Y); Q'.(PA.X); Q'.(PA.Y); p; a; G.(PA.X); G.(PA.Y); G'.(PA.X); G'.(PA.Y);\n  0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;\n  0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;\n  P0.(PZZ.X); P0.(PZZ.Y); P0.(PZZ.ZZ);  P0.(PZZ.ZZZ);\n  P1.(PZZ.X); P1.(PZZ.Y); P1.(PZZ.ZZ); P1.(PZZ.ZZZ);\n  P2.(PZZ.X); P2.(PZZ.Y); P2.(PZZ.ZZ); P2.(PZZ.ZZZ);\n  P3.(PZZ.X); P3.(PZZ.Y); P3.(PZZ.ZZ); P3.(PZZ.ZZZ);\n  P4.(PZZ.X); P4.(PZZ.Y); P4.(PZZ.ZZ); P4.(PZZ.ZZZ);\n  P5.(PZZ.X); P5.(PZZ.Y); P5.(PZZ.ZZ); P5.(PZZ.ZZZ);\n  P6.(PZZ.X); P6.(PZZ.Y); P6.(PZZ.ZZ); P6.(PZZ.ZZZ);\n  P7.(PZZ.X); P7.(PZZ.Y); P7.(PZZ.ZZ); P7.(PZZ.ZZZ);\n  P8.(PZZ.X); P8.(PZZ.Y); P8.(PZZ.ZZ); P8.(PZZ.ZZZ);\n  P9.(PZZ.X); P9.(PZZ.Y); P9.(PZZ.ZZ); P9.(PZZ.ZZZ);\n  P10.(PZZ.X); P10.(PZZ.Y); P10.(PZZ.ZZ); P10.(PZZ.ZZZ);\n  P11.(PZZ.X); P11.(PZZ.Y); P11.(PZZ.ZZ); P11.(PZZ.ZZZ);\n  P12.(PZZ.X); P12.(PZZ.Y); P12.(PZZ.ZZ); P12.(PZZ.ZZZ);\n  P13.(PZZ.X); P13.(PZZ.Y); P13.(PZZ.ZZ); P13.(PZZ.ZZZ);\n  P14.(PZZ.X); P14.(PZZ.Y); P14.(PZZ.ZZ); P14.(PZZ.ZZZ);\n  P15.(PZZ.X); P15.(PZZ.Y); P15.(PZZ.ZZ); P15.(PZZ.ZZZ);\n  0; p\n]\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The state is very large as we are verifying a large function (250 lines) directly mutating the memory. We recognize the parameters of the function (",(0,a.jsx)(s.code,{children:"Q"}),", ",(0,a.jsx)(s.code,{children:"Q'"}),", ",(0,a.jsx)(s.code,{children:"G"}),", ",(0,a.jsx)(s.code,{children:"G'"}),") as well as the pre-computed points (",(0,a.jsx)(s.code,{children:"P0"}),", ",(0,a.jsx)(s.code,{children:"P1"}),", ",(0,a.jsx)(s.code,{children:"P2"}),", ..., ",(0,a.jsx)(s.code,{children:"P16"}),"). We also see the computation of the coordinates of the doubled point, stored at fixed memory addresses."]}),"\n",(0,a.jsxs)(s.p,{children:["We define the ",(0,a.jsx)(s.code,{children:"dbl_neg_P_127"})," point as:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-coq",children:"set (dbl_neg_P_127 := ecDblNeg a p P_127).\n"})}),"\n",(0,a.jsxs)(s.p,{children:["We then rewrite the memory locations of the doubled point with the coordinates of ",(0,a.jsx)(s.code,{children:"dbl_neg_P_127"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-coq",children:"apply_memory_update_at P_127_X_address dbl_neg_P_127.(PZZ.X); [reflexivity|].\napply_memory_update_at P_127_Y_address dbl_neg_P_127.(PZZ.Y); [reflexivity|].\napply_memory_update_at P_127_ZZ_address dbl_neg_P_127.(PZZ.ZZ); [reflexivity|].\napply_memory_update_at P_127_ZZZ_address dbl_neg_P_127.(PZZ.ZZZ); [reflexivity|].\n"})}),"\n",(0,a.jsx)(s.p,{children:"giving us the new state:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-coq",children:"[\n  mem0; mem1; Pure.add 0 2048; mem3; mem4; dbl_neg_P_127.(PZZ.X);\n  Pure.mulmod P_127.(PZZ.X) (Pure.mulmod (Pure.mulmod 2 P_127.(PZZ.Y) p) (Pure.mulmod 2 P_127.(PZZ.Y) p) p) p;\n  dbl_neg_P_127.(PZZ.ZZZ); dbl_neg_P_127.(PZZ.Y);\n  HighLow.merge u_high u_low; 480; HighLow.merge v_high v_low; Pure.add 0 2048; 2 ^ 126;\n  dbl_neg_P_127.(PZZ.ZZ);\n  p; Q.(PA.Y); Q'.(PA.X); Q'.(PA.Y); p; a; G.(PA.X); G.(PA.Y); G'.(PA.X); G'.(PA.Y);\n  0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;\n  0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;\n  P0.(PZZ.X); P0.(PZZ.Y); P0.(PZZ.ZZ);  P0.(PZZ.ZZZ);\n  P1.(PZZ.X); P1.(PZZ.Y); P1.(PZZ.ZZ); P1.(PZZ.ZZZ);\n  P2.(PZZ.X); P2.(PZZ.Y); P2.(PZZ.ZZ); P2.(PZZ.ZZZ);\n  P3.(PZZ.X); P3.(PZZ.Y); P3.(PZZ.ZZ); P3.(PZZ.ZZZ);\n  P4.(PZZ.X); P4.(PZZ.Y); P4.(PZZ.ZZ); P4.(PZZ.ZZZ);\n  P5.(PZZ.X); P5.(PZZ.Y); P5.(PZZ.ZZ); P5.(PZZ.ZZZ);\n  P6.(PZZ.X); P6.(PZZ.Y); P6.(PZZ.ZZ); P6.(PZZ.ZZZ);\n  P7.(PZZ.X); P7.(PZZ.Y); P7.(PZZ.ZZ); P7.(PZZ.ZZZ);\n  P8.(PZZ.X); P8.(PZZ.Y); P8.(PZZ.ZZ); P8.(PZZ.ZZZ);\n  P9.(PZZ.X); P9.(PZZ.Y); P9.(PZZ.ZZ); P9.(PZZ.ZZZ);\n  P10.(PZZ.X); P10.(PZZ.Y); P10.(PZZ.ZZ); P10.(PZZ.ZZZ);\n  P11.(PZZ.X); P11.(PZZ.Y); P11.(PZZ.ZZ); P11.(PZZ.ZZZ);\n  P12.(PZZ.X); P12.(PZZ.Y); P12.(PZZ.ZZ); P12.(PZZ.ZZZ);\n  P13.(PZZ.X); P13.(PZZ.Y); P13.(PZZ.ZZ); P13.(PZZ.ZZZ);\n  P14.(PZZ.X); P14.(PZZ.Y); P14.(PZZ.ZZ); P14.(PZZ.ZZZ);\n  P15.(PZZ.X); P15.(PZZ.Y); P15.(PZZ.ZZ); P15.(PZZ.ZZZ);\n  0; p\n]\n"})}),"\n",(0,a.jsx)(s.p,{children:"Still large but much cleaner!"}),"\n",(0,a.jsx)(s.h2,{id:"-what-remains-to-be-done",children:"\ud83d\udc40 What remains to be done"}),"\n",(0,a.jsx)(s.p,{children:"There are two main parts that remain to be done in order to have a full formal verification of the library:"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["We need to complete the proof stating that the execution of the smart contract is equivalent to the execution of a purely functional version written in Coq, especially using recursive functions instead of ",(0,a.jsx)(s.code,{children:"for"})," loops. Reasoning on the loops is complex; in the current version, we unroll the loops once in order to have a first step towards the full proof. As the memory used by the main function is quite large, we will first need to change the code we verify by looking at the Yul code generated before optimizations by the Solidity compiler."]}),"\n",(0,a.jsxs)(s.li,{children:["Show that the purely functional version of the library is equivalent to the plain addition and scalar multiplication. We have only started this work. The main challenge is to show that we can remove the loop by doing the bitwise addition. This will require some bit-arithmetic reasoning, as well as field arithmetic for the operations modulo the prime number ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"p"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"p"})]})})]}),"."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,a.jsxs)(s.p,{children:["We have seen how the ",(0,a.jsx)(s.strong,{children:"Smoo.th"})," library works at a high level, how we can start verifying it, and what challenges do we face. This is also an interesting example to improve our tool ",(0,a.jsx)(s.code,{children:"coq-of-solidity"})," and develop reasoning primitives for cryptographic code. We will continue this work in the coming weeks to verify more parts of this library."]}),"\n",(0,a.jsx)(s.admonition,{title:"For more",type:"success",children:(0,a.jsx)(s.p,{children:(0,a.jsxs)(s.em,{children:["Follow us on ",(0,a.jsx)(s.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,a.jsx)(s.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"}),", or comment on this post below! Feel free to DM us for any formal verification services you need."]})})})]})}function m(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},6837:(e,s,n)=>{n.d(s,{A:()=>a});const a=n.p+"assets/images/panda-in-forest-d00a641f3c2272f5a60b7eb4ef42009a.webp"},6490:(e,s,n)=>{n.d(s,{A:()=>a});const a=n.p+"assets/images/smoo-th-diagram-b4175d005c9ee419c532cde9a22a93cb.svg"},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>r});var a=n(6540);const t={},i=a.createContext(t);function l(e){const s=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),a.createElement(i.Provider,{value:s},e.children)}}}]);