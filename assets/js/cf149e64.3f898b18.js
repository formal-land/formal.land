"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[3639],{1537:(t,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>n,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=o(4848),i=o(8453);const a={title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 1",tags:["Noir","smart contract","circuits"],authors:[]},n=void 0,s={permalink:"/blog/2024/11/01/tool-for-noir-1",source:"@site/blog/2024-11-01-tool-for-noir-1.md",title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 1",description:"In this series of blog posts, we present our development of a formal verification tool for the \u25fc\ufe0f&nbsp;Noir smart contract language. It is particularly suited to writing zero-knowledge applications, providing primitive constructs such as a Field type to write programs that run efficiently as circuits. Having a formal verification for Noir enables the development of applications holding a large amount of money in this language, as it ensures that the code is correct with a mathematical level of certainty.",date:"2024-11-01T00:00:00.000Z",formattedDate:"November 1, 2024",tags:[{label:"Noir",permalink:"/blog/tags/noir"},{label:"smart contract",permalink:"/blog/tags/smart-contract"},{label:"circuits",permalink:"/blog/tags/circuits"}],readingTime:11.94,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 1",tags:["Noir","smart contract","circuits"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Example of verification for the Move's checker of Sui",permalink:"/blog/2024/11/14/sui-move-checker-abstract-stack"},nextItem:{title:"\u2688 Verification of the Smoo.th library \u2013 2",permalink:"/blog/2024/10/28/verification-smooth-library-2"}},l={authorsImageUrls:[]},c=[];function f(t){const e={a:"a",code:"code",em:"em",p:"p",...(0,i.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:["In this series of blog posts, we present our development of a formal verification tool for the ",(0,r.jsx)(e.a,{href:"https://noir-lang.org/",children:"\u25fc\ufe0f\xa0Noir"})," smart contract language. It is particularly suited to writing zero-knowledge applications, providing primitive constructs such as a ",(0,r.jsx)(e.code,{children:"Field"})," type to write programs that run efficiently as circuits. Having a formal verification for Noir enables the development of applications holding a large amount of money in this language, as it ensures that the code is correct with a mathematical level of certainty."]}),"\n",(0,r.jsxs)(e.p,{children:["In this first post, we present how we translate Noir code to the ",(0,r.jsx)(e.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"})," proof system. We explore a translation after monomorphization and then at the HIR level. Note that we are interested in verifying programs ",(0,r.jsx)(e.em,{children:"written in Noir"}),". The verification of the Noir compiler itself is a separated topic."]}),"\n",(0,r.jsxs)(e.p,{children:["All our code is available as open-source on ",(0,r.jsx)(e.a,{href:"https://github.com/formal-land/coq-of-noir",children:"github.com/formal-land/coq-of-noir"}),", and you are welcome to use it. We also provide all-included audit services to formally verify your smart contracts using ",(0,r.jsx)(e.code,{children:"coq-of-noir"}),"."]})]})}function m(t={}){const{wrapper:e}={...(0,i.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(f,{...t})}):f(t)}},8453:(t,e,o)=>{o.d(e,{R:()=>n,x:()=>s});var r=o(6540);const i={},a=r.createContext(i);function n(t){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:n(t.components),r.createElement(a.Provider,{value:e},t.children)}}}]);