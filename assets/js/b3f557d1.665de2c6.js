"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[715],{8629:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=o(74848),t=o(28453);const i={title:"\ud83e\udd77 Formal verification of an OpenVM chip",tags:["zkVM","zero-knowledge","determinism"],authors:[]},s=void 0,l={permalink:"/blog/2025/08/13/verification-of-openvm-branch-eq",source:"@site/blog/2025-08-13-verification-of-openvm-branch-eq.md",title:"\ud83e\udd77 Formal verification of an OpenVM chip",description:"In this blog post, we present the formal verification of the determinism of the BranchEq circuit of the OpenVM zkVM. This zkVM provides an implementation of RISC-V with Plonky3, and appears to be very fast even on a CPU.",date:"2025-08-13T00:00:00.000Z",formattedDate:"August 13, 2025",tags:[{label:"zkVM",permalink:"/blog/tags/zk-vm"},{label:"zero-knowledge",permalink:"/blog/tags/zero-knowledge"},{label:"determinism",permalink:"/blog/tags/determinism"}],readingTime:8.615,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd77 Formal verification of an OpenVM chip",tags:["zkVM","zero-knowledge","determinism"],authors:[]},unlisted:!1,nextItem:{title:"\ud83e\udd84 What to verify in a zkVM",permalink:"/blog/2025/08/12/verification-of-zkvm"}},r={authorsImageUrls:[]},c=[{value:"\ud83e\udd80 Rust source code",id:"-rust-source-code",level:2},{value:"\ud83d\udc13 Rocq model",id:"-rocq-model",level:2},{value:"\ud83e\udde0 Reasoning rules",id:"-reasoning-rules",level:2},{value:"\ud83d\udcdd Specification",id:"-specification",level:2},{value:"\ud83d\udd0d Proof",id:"-proof",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In this blog post, we present the formal verification of the determinism of the ",(0,a.jsx)(n.a,{href:"https://github.com/openvm-org/openvm/blob/main/extensions/rv32im/circuit/src/branch_eq/core.rs",children:"BranchEq"})," circuit of the ",(0,a.jsx)(n.a,{href:"https://openvm.dev/",children:"OpenVM"})," zkVM. This zkVM provides an implementation of RISC-V with ",(0,a.jsx)(n.a,{href:"https://github.com/Plonky3/Plonky3",children:"Plonky3"}),", and appears to be very fast even on a CPU."]}),"\n",(0,a.jsxs)(n.p,{children:["We do our verification work using the formal verification system ",(0,a.jsx)(n.a,{href:"https://rocq-prover.org/",children:"Rocq"}),", showing the determinism on a model of the code. To see the other properties that can be verified, you can refer to our previous blog post ",(0,a.jsx)(n.a,{href:"/blog/2025/08/12/verification-of-zkvm",children:"\ud83e\udd84 What to verify in a zkVM"}),". We will see later how to make sure that the Rocq model corresponds to the actual Rust implementation of the circuit."]}),"\n",(0,a.jsx)("figure",{children:(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Green forest",src:o(14350).A+"",width:"1024",height:"1024"})})}),"\n",(0,a.jsx)(n.h2,{id:"-rust-source-code",children:"\ud83e\udd80 Rust source code"}),"\n",(0,a.jsxs)(n.p,{children:["The role of the ",(0,a.jsx)(n.code,{children:"branch_eq"})," chip is to compare two integers decomposed into limbs, and to make a code jump depending on the result of the comparison. To check the determinism, we only need to verify the code of the circuit itself, which is:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"fn eval(\n    &self,\n    builder: &mut AB,\n    local: &[AB::Var],\n    from_pc: AB::Var,\n) -> AdapterAirContext<AB::Expr, I> {\n    let cols: &BranchEqualCoreCols<_, NUM_LIMBS> = local.borrow();\n    let flags = [cols.opcode_beq_flag, cols.opcode_bne_flag];\n\n    let is_valid = flags.iter().fold(AB::Expr::ZERO, |acc, &flag| {\n        builder.assert_bool(flag);\n        acc + flag.into()\n    });\n    builder.assert_bool(is_valid.clone());\n    builder.assert_bool(cols.cmp_result);\n\n    let a = &cols.a;\n    let b = &cols.b;\n    let inv_marker = &cols.diff_inv_marker;\n\n    // 1 if cmp_result indicates a and b are equal, 0 otherwise\n    let cmp_eq =\n        cols.cmp_result * cols.opcode_beq_flag + not(cols.cmp_result) * cols.opcode_bne_flag;\n    let mut sum = cmp_eq.clone();\n\n    for i in 0..NUM_LIMBS {\n        sum += (a[i] - b[i]) * inv_marker[i];\n        builder.assert_zero(cmp_eq.clone() * (a[i] - b[i]));\n    }\n    builder.when(is_valid.clone()).assert_one(sum);\n\n    let expected_opcode = flags\n        .iter()\n        .zip(BranchEqualOpcode::iter())\n        .fold(AB::Expr::ZERO, |acc, (flag, opcode)| {\n            acc + (*flag).into() * AB::Expr::from_canonical_u8(opcode as u8)\n        })\n        + AB::Expr::from_canonical_usize(self.offset);\n\n    let to_pc = from_pc\n        + cols.cmp_result * cols.imm\n        + not(cols.cmp_result) * AB::Expr::from_canonical_u32(self.pc_step);\n\n    AdapterAirContext {\n        to_pc: Some(to_pc),\n        reads: [cols.a.map(Into::into), cols.b.map(Into::into)].into(),\n        writes: Default::default(),\n        instruction: ImmInstruction {\n            is_valid,\n            opcode: expected_opcode,\n            immediate: cols.imm.into(),\n        }\n        .into(),\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"If you are used to Plonky3 circuits, you should be able to read most of the code. The most clever part is this loop:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let mut sum = cmp_eq.clone();\n\nfor i in 0..NUM_LIMBS {\n    sum += (a[i] - b[i]) * inv_marker[i];\n    builder.assert_zero(cmp_eq.clone() * (a[i] - b[i]));\n}\nbuilder.when(is_valid.clone()).assert_one(sum);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["to compute whether the two integers are equal. For two different values of ",(0,a.jsx)(n.code,{children:"a"})," and ",(0,a.jsx)(n.code,{children:"b"}),", it relies on the oracle ",(0,a.jsx)(n.code,{children:"inv_marker"}),", which will be equal to the inverse of ",(0,a.jsx)(n.code,{children:"(a[i] - b[i])"})," for one of the ",(0,a.jsx)(n.code,{children:"i"})," such that ",(0,a.jsx)(n.code,{children:"a"})," and ",(0,a.jsx)(n.code,{children:"b"})," differ, and to 0 otherwise. In contrast to the AIR examples provided in the Plonky3 repository, we return field expressions in addition to asserting equations with the ",(0,a.jsx)(n.code,{children:"builder"}),". This will enable more advanced compositions with other chips."]}),"\n",(0,a.jsx)(n.h2,{id:"-rocq-model",children:"\ud83d\udc13 Rocq model"}),"\n",(0,a.jsxs)(n.p,{children:["We translate this code ",(0,a.jsx)(n.em,{children:"manually"})," to the formal language Rocq using our zero-knowledge framework ",(0,a.jsx)(n.a,{href:"https://github.com/formal-land/garden",children:"Garden"}),". We will see later how to check that this translation is faithful to the original code. Here is our translation:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"Definition eval {p} `{Prime p} {NUM_LIMBS : Z}\n    (self : BranchEqualCoreAir.t NUM_LIMBS)\n    (local : BranchEqualCoreCols.t NUM_LIMBS)\n    (from_pc : Z) :\n    M.t (AdapterAirContext.t NUM_LIMBS) :=\n  let flags : list Z := [\n    local.(BranchEqualCoreCols.opcode_beq_flag);\n    local.(BranchEqualCoreCols.opcode_bne_flag)\n  ] in\n\n  let* is_valid : Z :=\n    List.fold_left\n      (fun acc flag =>\n        let* _ := M.assert_bool flag in\n        M.pure (BinOp.add acc flag)\n      )\n      Z.zero\n      flags in\n  let* _ := M.assert_bool is_valid in\n  let* _ := M.assert_bool local.(BranchEqualCoreCols.cmp_result) in\n\n  let a : Array.t Z NUM_LIMBS := local.(BranchEqualCoreCols.a) in\n  let b : Array.t Z NUM_LIMBS := local.(BranchEqualCoreCols.b) in\n  let inv_marker : Array.t Z NUM_LIMBS := local.(BranchEqualCoreCols.diff_inv_marker) in\n\n  let* cmp_eq : Z :=\n    M.pure (\n      BinOp.add\n        (BinOp.mul local.(BranchEqualCoreCols.cmp_result) local.(BranchEqualCoreCols.opcode_beq_flag))\n        (BinOp.mul (M.not local.(BranchEqualCoreCols.cmp_result)) local.(BranchEqualCoreCols.opcode_bne_flag))\n    ) in\n\n  let* _ := M.for_in_zero_to_n NUM_LIMBS (fun i =>\n    M.assert_zero (BinOp.mul cmp_eq (BinOp.sub (Array.get a i) (Array.get b i)))\n  ) in\n  let sum : Z := M.sum_for_in_zero_to_n NUM_LIMBS (fun i =>\n    BinOp.mul (Array.get inv_marker i) (BinOp.sub (Array.get a i) (Array.get b i))\n  ) in\n  let sum := BinOp.add sum cmp_eq in\n  let* _ := M.when is_valid (M.assert_one sum) in\n\n  let flags_with_opcode_integer : list (Z * Z) :=\n    [\n      (local.(BranchEqualCoreCols.opcode_beq_flag), 0);\n      (local.(BranchEqualCoreCols.opcode_bne_flag), 1)\n    ] in\n  let expected_opcode : Z :=\n    Lists.List.fold_left\n      (fun acc '(flag, opcode) =>\n        BinOp.add acc (BinOp.mul flag opcode)\n      )\n      flags_with_opcode_integer\n      0 in\n  let expected_opcode : Z :=\n    BinOp.add expected_opcode self.(BranchEqualCoreAir.offset) in\n\n  let to_pc : Z :=\n    BinOp.add\n      (BinOp.add\n        from_pc\n        (BinOp.mul local.(BranchEqualCoreCols.cmp_result) local.(BranchEqualCoreCols.imm))\n      )\n      (BinOp.mul (M.not local.(BranchEqualCoreCols.cmp_result)) self.(BranchEqualCoreAir.pc_step))\n    in\n\n  M.pure {|\n    AdapterAirContext.to_pc := Some to_pc;\n    AdapterAirContext.reads := (a, b);\n    AdapterAirContext.writes := tt;\n    AdapterAirContext.instruction := {|\n      ImmInstruction.is_valid := is_valid;\n      ImmInstruction.opcode := expected_opcode;\n      ImmInstruction.immediate := local.(BranchEqualCoreCols.imm);\n    |};\n  |}.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It should be similar to the Rust code above, with the use of the monadic notation ",(0,a.jsx)(n.code,{children:"let*"})," as asserting equations makes a side-effect. We do not need an explicit ",(0,a.jsx)(n.code,{children:"builder"})," variable, as it is part of the monad ",(0,a.jsx)(n.code,{children:"M.t"}),". We should use binary notations ",(0,a.jsx)(n.code,{children:"+"})," and ",(0,a.jsx)(n.code,{children:"*"})," for ",(0,a.jsx)(n.code,{children:"BinOp.add"})," and ",(0,a.jsx)(n.code,{children:"BinOp.mul"})," to make it even more similar to the original code. We do not distinguish between field elements, variables, and polynomial expressions, as we can do symbolic reasoning in Rocq, and we do not need to translate the constraints to a list of polynomial equations."]}),"\n",(0,a.jsxs)(n.p,{children:["We parametrize all the code by an ambient prime number ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"p"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]}),", which is used for all the field operations, in order to know modulo which\xa0",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"p"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]})," we should make the computations. We represent all the field elements in ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{mathvariant:"double-struck",children:"Z"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathbb{Z}"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6889em"}}),(0,a.jsx)(n.span,{className:"mord mathbb",children:"Z"})]})})]}),", and we apply the modulo operation on the result of each operation."]}),"\n",(0,a.jsx)(n.h2,{id:"-reasoning-rules",children:"\ud83e\udde0 Reasoning rules"}),"\n",(0,a.jsxs)(n.p,{children:["We use similar reasoning rules as in the previous blog post ",(0,a.jsx)(n.a,{href:"/blog/2025/07/31/llzk-to-rocq-verification",children:"\ud83e\udd77 Formal verification of LLZK circuits in Rocq"}),". These rules execute the code as one would expect for a purely functional program, and additionally accumulate the equational constraints in a resulting proposition. Here is the rule for the monadic bind:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"| Let {A B : Set} (e : M.t A) (k : A -> M.t B) (value : A) (output : B) (P1 P2 : Prop) :\n  {{ e \ud83d\udd3d value, P1 }} ->\n  (P1 -> {{ k value \ud83d\udd3d output, P2 }}) ->\n  {{ M.Let e k \ud83d\udd3d output, P1 /\\ P2 }}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When we execute two computations in sequence ",(0,a.jsx)(n.code,{children:"e"})," and ",(0,a.jsx)(n.code,{children:"k"}),", the final constraint is the conjunction of the constraints for ",(0,a.jsx)(n.code,{children:"e"})," and ",(0,a.jsx)(n.code,{children:"k"}),". The basic rule to add a constraint is:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"| Equal (x1 x2 : Z) :\n  {{ M.Equal x1 x2 \ud83d\udd3d tt, x1 = x2 }}\n"})}),"\n",(0,a.jsx)(n.p,{children:"We can also simplify the proposition by a potentially weaker one, as we are only interested in what the constraints imply to verify determinism:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"| Implies {A : Set} (e : M.t A) (value : A) (P1 P2 : Prop) :\n  {{ e \ud83d\udd3d value, P1 }} ->\n  (P1 -> P2) ->\n  {{ e \ud83d\udd3d value, P2 }}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can find the full list of rules in the file ",(0,a.jsx)(n.a,{href:"https://github.com/formal-land/garden/blob/main/Garden/Plonky3/M.v",children:"Garden/Plonky3/M.v"})," in the ",(0,a.jsx)(n.a,{href:"https://github.com/formal-land/garden",children:"Garden repository"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"-specification",children:"\ud83d\udcdd Specification"}),"\n",(0,a.jsxs)(n.p,{children:["We can now specify the code. You can read the full specification in the lemma ",(0,a.jsx)(n.code,{children:"eval_implies"})," in the file ",(0,a.jsx)(n.a,{href:"https://github.com/formal-land/garden/blob/main/Garden/OpenVM/BranchEq/core_with_monad.v",children:"Garden/OpenVM/BranchEq/core_with_monad.v"}),". We state:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["What is the expected output in a purely functional form for the output of the function in ",(0,a.jsx)(n.code,{children:"AdapterAirContext.t NUM_LIMBS"}),"?"]}),"\n",(0,a.jsxs)(n.li,{children:["What are the constraints on the columns in ",(0,a.jsx)(n.code,{children:"local"}),"?"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Here is the type of the ",(0,a.jsx)(n.code,{children:"local"})," parameter:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"Record t {NUM_LIMBS : Z} : Set := {\n  a : Array.t Z NUM_LIMBS;\n  b : Array.t Z NUM_LIMBS;\n  cmp_result : Z;\n  imm : Z;\n  opcode_beq_flag : Z;\n  opcode_bne_flag : Z;\n  diff_inv_marker : Array.t Z NUM_LIMBS;\n}.\nArguments t : clear implicits.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We assume that either ",(0,a.jsx)(n.code,{children:"opcode_beq_flag"})," or ",(0,a.jsx)(n.code,{children:"opcode_bne_flag"})," is equal to ",(0,a.jsx)(n.code,{children:"1"}),", and that the other one is equal to ",(0,a.jsx)(n.code,{children:"0"}),". This flag controls whether we are checking the equality or the inequality of the two integers ",(0,a.jsx)(n.code,{children:"a"})," and ",(0,a.jsx)(n.code,{children:"b"}),". For the constraints, our specification says that:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"local.(BranchEqualCoreCols.cmp_result) = Z.b2z expected_cmp_result\n"})}),"\n",(0,a.jsxs)(n.p,{children:["meaning that the column ",(0,a.jsx)(n.code,{children:"cmp_result"})," must represent a boolean with value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"let expected_cmp_result : bool :=\n  match branch_equal_opcode with\n  | BranchEqualOpcode.BEQ =>\n    if Array.Eq.dec local.(BranchEqualCoreCols.a) local.(BranchEqualCoreCols.b) then\n      true\n    else\n      false\n  | BranchEqualOpcode.BNE =>\n    if Array.Eq.dec local.(BranchEqualCoreCols.a) local.(BranchEqualCoreCols.b) then\n      false\n    else\n      true\n  end\n"})}),"\n",(0,a.jsx)(n.p,{children:"which is the result of the comparison check, depending on the opcode flag."}),"\n",(0,a.jsx)(n.h2,{id:"-proof",children:"\ud83d\udd0d Proof"}),"\n",(0,a.jsxs)(n.p,{children:["We verify the specification by applying the reasoning rules to accumulate the constraints on each monadic bind ",(0,a.jsx)(n.code,{children:"let*"}),". For example, for:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"let* _ := M.assert_bool local.(BranchEqualCoreCols.cmp_result) in\n"})}),"\n",(0,a.jsx)(n.p,{children:"we do:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"eapply Run.LetAccumulate. {\n  constructor.\n}\nintros H_cmp_result.\n"})}),"\n",(0,a.jsx)(n.p,{children:"This gives us, in the proof context, the additional hypothesis:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"H_cmp_result: IsBool.t local.(BranchEqualCoreCols.cmp_result)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It states that the column ",(0,a.jsx)(n.code,{children:"cmp_result"})," is either ",(0,a.jsx)(n.code,{children:"0"})," or ",(0,a.jsx)(n.code,{children:"1"}),". For most of the rest of the reasoning, we apply similar rules and reason exhaustively for all the possible cases over the boolean variables and the equality of ",(0,a.jsx)(n.code,{children:"a"})," and ",(0,a.jsx)(n.code,{children:"b"}),", eliminating impossible cases and showing that the column ",(0,a.jsx)(n.code,{children:"cmp_result"})," always contains the expected value."]}),"\n",(0,a.jsxs)(n.p,{children:["To verify this circuit, we also made the choice to use a specific value for the prime number\xa0",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"p"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]})," with the Goldilocks prime. This is making the proof simpler in some cases, as we can explicitly compute the result of modulo operations on boolean values, without relying on field reasoning. We think it is safe to assume a specific prime, as circuits generally use a single fixed prime value."]}),"\n",(0,a.jsxs)(n.p,{children:["For the expected output, for example, for the ",(0,a.jsx)(n.code,{children:"pc"})," variable, which is modified if we decide to jump, we state that we must have the expected value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coq",children:"AdapterAirContext.to_pc :=\n  Some (BinOp.add from_pc (\n    if expected_cmp_result then\n      local.(BranchEqualCoreCols.imm)\n    else\n      self.(BranchEqualCoreAir.pc_step)\n  ));\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Once we have specified the ",(0,a.jsx)(n.code,{children:"cmp_result"})," column, this amounts to showing the equality of two expressions using field elements, which is done through automation procedures."]}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"info",children:(0,a.jsxs)(n.p,{children:["For this circuit, the completeness is not obvious, as there is an oracle variable ",(0,a.jsx)(n.code,{children:"diff_inv_marker"})," which must have a correct value provided by the prover. We should also verify the completeness of the circuit with appropriate reasoning rules."]})}),"\n",(0,a.jsx)(n.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,a.jsxs)(n.p,{children:["We have seen how to specify the determinism of the ",(0,a.jsx)(n.code,{children:"branch_eq"})," chip of OpenVM, and to formally verify that this is the case for any possible parameters and column values."]}),"\n",(0,a.jsx)(n.p,{children:"Next, we will see how to make sure that our Rocq formalization corresponds to the Rust implementation of the chip."}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["You want to discuss security? Contact us! \u21e8 ",(0,a.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"For more",type:"success",children:(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["Follow us on ",(0,a.jsx)(n.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,a.jsx)(n.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions!"]})})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},14350:(e,n,o)=>{o.d(n,{A:()=>a});const a=o.p+"assets/images/forest-7277f0aa94d535a998bc0f66da212999.png"},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>l});var a=o(96540);const t={},i=a.createContext(t);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);