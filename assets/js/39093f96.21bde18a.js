"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2968],{80330:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>f,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var n=t(74848),r=t(28453);const s={title:"\ud83e\ude81 Enhancements to coq-of-solidity \u2013 1",tags:["Solidity","monad","effects","Yul","loops","mutations"],authors:[]},i=void 0,a={permalink:"/blog/2024/10/16/coq-of-solidity-enhanced-version-1",source:"@site/blog/2024-10-16-coq-of-solidity-enhanced-version-1.md",title:"\ud83e\ude81 Enhancements to coq-of-solidity \u2013 1",description:"We present improvements we made to our tool coq-of-solidity to formally verify Solidity smart contracts for any advanced properties, relying on the proof assistant \ud83d\udc13&nbsp;Coq. The idea is to be able to prove the full absence of bugs&nbsp;\u2728 in very complex contracts, like L1 verifiers for zero-knowledge L2s&nbsp;\ud83d\udd75\ufe0f, or contracts with very large amounts of money&nbsp;\ud83d\udcb0 (in the billions).",date:"2024-10-16T00:00:00.000Z",formattedDate:"October 16, 2024",tags:[{label:"Solidity",permalink:"/blog/tags/solidity"},{label:"monad",permalink:"/blog/tags/monad"},{label:"effects",permalink:"/blog/tags/effects"},{label:"Yul",permalink:"/blog/tags/yul"},{label:"loops",permalink:"/blog/tags/loops"},{label:"mutations",permalink:"/blog/tags/mutations"}],readingTime:8.82,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\ude81 Enhancements to coq-of-solidity \u2013 1",tags:["Solidity","monad","effects","Yul","loops","mutations"],authors:[]},unlisted:!1,prevItem:{title:"\u2688 Verification of the Smoo.th library \u2013 1",permalink:"/blog/2024/10/21/verification-smooth-library-1"},nextItem:{title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 3",permalink:"/blog/2024/10/15/verification-move-sui-type-checker-3"}},l={authorsImageUrls:[]},c=[];function d(e){const o={a:"a",code:"code",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(o.p,{children:["We present improvements we made to our tool ",(0,n.jsx)(o.a,{href:"https://github.com/formal-land/rocq-of-solidity",children:"coq-of-solidity"})," to formally verify ",(0,n.jsx)(o.a,{href:"https://soliditylang.org/",children:"Solidity"})," smart contracts for any advanced properties, relying on the proof assistant ",(0,n.jsx)(o.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),". The idea is to be able to prove the ",(0,n.jsx)(o.strong,{children:"full absence of bugs\xa0\u2728"})," in ",(0,n.jsx)(o.strong,{children:"very complex contracts"}),", like L1 verifiers for ",(0,n.jsx)(o.strong,{children:"zero-knowledge L2s\xa0\ud83d\udd75\ufe0f"}),", or contracts with ",(0,n.jsx)(o.strong,{children:"very large amounts of money\xa0\ud83d\udcb0"})," (in the billions)."]}),"\n",(0,n.jsxs)(o.p,{children:["In this blog post, we present how we developed an effect inference mechanism to translate optimized ",(0,n.jsx)(o.a,{href:"https://docs.soliditylang.org/en/latest/yul.html",children:"Yul"})," code combining variable mutations and control flow with loops and nested premature returns (",(0,n.jsx)(o.code,{children:"break"}),", ",(0,n.jsx)(o.code,{children:"continue"}),", and ",(0,n.jsx)(o.code,{children:"leave"}),") to a clean\xa0\ud83e\uddfc purely functional representation in the proof system Coq."]})]})}function f(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,o,t)=>{t.d(o,{R:()=>i,x:()=>a});var n=t(96540);const r={},s=n.createContext(r);function i(e){const o=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:o},e.children)}}}]);