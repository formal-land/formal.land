"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2446],{821:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=o(4848),n=o(8453);const s={title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 1",tags:["Sui","formal verification","Coq","Rust","Move","type checker"],authors:[]},r=void 0,a={permalink:"/blog/2024/08/19/verification-move-sui-type-checker-1",source:"@site/blog/2024-08-19-verification-move-sui-type-checker-1.md",title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 1",description:"In this blog post, we present our project to formally verify the implementation of the type checker for smart contracts of the \ud83d\udca7&nbsp;Sui blockchain. The Sui blockchain uses the Move language to express smart contracts. This language is implemented in \ud83e\udd80&nbsp;Rust and compiles down to the Move bytecode that is loaded in memory when executing the smart contracts.",date:"2024-08-19T00:00:00.000Z",formattedDate:"August 19, 2024",tags:[{label:"Sui",permalink:"/blog/tags/sui"},{label:"formal verification",permalink:"/blog/tags/formal-verification"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Move",permalink:"/blog/tags/move"},{label:"type checker",permalink:"/blog/tags/type-checker"}],readingTime:2.575,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 1",tags:["Sui","formal verification","Coq","Rust","Move","type checker"],authors:[]},unlisted:!1,prevItem:{title:"\ud83c\udf32 What we do at Formal Land",permalink:"/blog/2024/10/13/class-what-we-do"},nextItem:{title:"\ud83e\ude81 Coq of Solidity \u2013 part 4",permalink:"/blog/2024/08/13/coq-of-solidity-4"}},l={authorsImageUrls:[]},c=[{value:"Plan",id:"plan",level:2},{value:"What is done",id:"what-is-done",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["In this blog post, we present our project to formally verify the implementation of the type checker for smart contracts of the ",(0,i.jsx)(t.a,{href:"https://sui.io/",children:"\ud83d\udca7\xa0Sui blockchain"}),". The Sui blockchain uses the ",(0,i.jsx)(t.a,{href:"https://sui.io/move",children:"Move"})," language to express smart contracts. This language is implemented in ",(0,i.jsx)(t.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"})," and compiles down to the Move bytecode that is loaded in memory when executing the smart contracts."]}),"\n",(0,i.jsxs)(t.p,{children:["We will formally verify the part that checks that the bytecode is well-typed, so that when a smart contract is executed it cannot encounter critical errors. The ",(0,i.jsx)(t.a,{href:"https://github.com/move-language/move-sui/blob/main/crates/move-bytecode-verifier/src/type_safety.rs",children:"type checker itself"})," is also written in Rust, and we will verify it using the proof assistant ",(0,i.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq\xa0\ud83d\udc13"})," and our tool ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," that translates Rust programs to Coq."]}),"\n",(0,i.jsxs)(t.admonition,{title:"Get started",type:"success",children:[(0,i.jsxs)(t.p,{children:["To formally verify your Rust code and ensure it contains no bugs or vulnerabilities, contact us at\xa0",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udce7contact@formal.land"}),"."]}),(0,i.jsx)(t.p,{children:"The cost is \u20ac10 per line of Rust code (excluding comments) and \u20ac20 per line for concurrent code."})]}),"\n",(0,i.jsx)("figure",{children:(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Sui in forest",src:o(8994).A+"",width:"1024",height:"1024"})})}),"\n",(0,i.jsx)(t.h2,{id:"plan",children:"Plan"}),"\n",(0,i.jsx)(t.p,{children:"The plan for this project is as follows:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Write simulations\xa0\ud83e\uddee"})," of the Rust code we want to verify in Coq, namely the ",(0,i.jsx)(t.a,{href:"https://github.com/move-language/move-sui/blob/main/crates/move-bytecode-verifier/src/type_safety.rs",children:"type checker"})," and the ",(0,i.jsx)(t.a,{href:"https://github.com/move-language/move-sui/blob/main/crates/move-vm-runtime/src/interpreter.rs",children:"interpreter of bytecode"}),". The simulations are functions that are equivalent to the ones in the original Rust program, but written in a style that is more amenable to formal verification. The changes can be:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"very simple, for example renaming variables to avoid name collisions in Coq,"}),"\n",(0,i.jsx)(t.li,{children:"more involved like solving the trait instances or replacing Rust references with purely functional code, or"}),"\n",(0,i.jsx)(t.li,{children:"specific to the project, like reversing the order of the bytecode's stack to simplify the proofs."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Test these simulations\xa0\ud83d\udd0d"})," to show they behave like the original Rust code on examples covering all the opcodes of the Move bytecode."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Prove the equivalence\xa0\ud83d\udff0"})," between the Coq simulations and the Rust code as translated to Coq by ",(0,i.jsx)(t.code,{children:"coq-of-rust"}),". This part will give more precise results than the tests, as it will cover all possible inputs and states of the program. The complexity of this part is to go through all the details that exist in the Rust code, like the use of references to manipulate the memory, the macros after expansion, and the parts of the Rust standard library that the code depends on."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Prove that the type checker is correct\xa0\ud83d\udee1\ufe0f"})," in Coq. The main properties we want to check are:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"the interpreter preserves the well-typedness of the code as it steps through the opcodes,"}),"\n",(0,i.jsx)(t.li,{children:"when a program is accepted by the type checker, the interpreter will not fail at runtime with a type error."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"what-is-done",children:"What is done"}),"\n",(0,i.jsxs)(t.p,{children:["For now, we have written a simulation for the type checker in ",(0,i.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/simulations/move_bytecode_verifier/type_safety.v",children:"CoqOfRust/move_sui/simulations/move_bytecode_verifier/type_safety.v"}),". We are now:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"adding tests to compare this simulation with the original Rust code,"}),"\n",(0,i.jsx)(t.li,{children:"writing the simulation for the interpreter of the Move bytecode."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"In the following blog posts, we will describe how we structured the simulations and how we are testing or verifying them."}),"\n",(0,i.jsx)(t.admonition,{title:"Thanks",type:"success",children:(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["This project is kindly founded by the ",(0,i.jsx)(t.a,{href:"https://sui.io/about",children:"Sui Foundation"})," which we thank for their trust and support."]})})})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8994:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/sui-in-forest-b4fec454e1242e1450019d738d2a8ac5.webp"},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var i=o(6540);const n={},s=i.createContext(n);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);