"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8005],{7600:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(4848),r=n(8453);const a={title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 2",tags:["monad","Rust","Sui"],authors:[]},i=void 0,s={permalink:"/blog/2024/10/14/verification-move-sui-type-checker-2",source:"@site/blog/2024-10-14-verification-move-sui-type-checker-2.md",title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 2",description:"We are working on formally verifying the \ud83e\udd80&nbsp;Rust implementation of the Move type-checker for bytecode in the proof system \ud83d\udc13&nbsp;Coq. You can find the code of this type-checker in the crate move-bytecode-verifier.",date:"2024-10-14T00:00:00.000Z",formattedDate:"October 14, 2024",tags:[{label:"monad",permalink:"/blog/tags/monad"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Sui",permalink:"/blog/tags/sui"}],readingTime:9.045,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 2",tags:["monad","Rust","Sui"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 3",permalink:"/blog/2024/10/15/verification-move-sui-type-checker-3"},nextItem:{title:"\ud83c\udf32 What we do at Formal Land",permalink:"/blog/2024/10/13/class-what-we-do"}},l={authorsImageUrls:[]},c=[{value:"Primitive effects",id:"primitive-effects",level:2},{value:"Panic",id:"panic",level:3},{value:"Result",id:"result",level:3},{value:"State",id:"state",level:3},{value:"Combinaisons",id:"combinaisons",level:2},{value:"Iterations",id:"iterations",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["We are working on formally verifying the ",(0,o.jsx)(t.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"})," implementation of the ",(0,o.jsx)(t.a,{href:"https://sui.io/move",children:"Move"})," type-checker for bytecode in the proof system ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),". You can find the code of this type-checker in the crate ",(0,o.jsx)(t.a,{href:"https://github.com/move-language/move-sui/tree/main/crates/move-bytecode-verifier",children:"move-bytecode-verifier"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["This requires translating all the Rust code in idiomatic Coq on which we will write our specifications and proofs. We write this translation by hand relying as much as possible on generative AI tools such as ",(0,o.jsx)(t.a,{href:"https://github.com/features/copilot",children:"GitHub Copilot"}),", as there are many particular cases. We plan, eventually, to prove it equivalent to the translation automatically generated by ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"In this blog post we present how we organize our \ud83d\udd2e\xa0monad to represent the side-effects used in this Rust code. We believe this organization should work for other Rust projects as well."}),"\n",(0,o.jsxs)(t.admonition,{title:"Get started",type:"success",children:[(0,o.jsxs)(t.p,{children:["To ensure your code is secure today, contact us at\xa0",(0,o.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udce7contact@formal.land"}),"!\xa0\ud83d\ude80"]}),(0,o.jsx)(t.p,{children:"Formal verification goes further than traditional audits to make 100% sure you cannot lose your funds. It can be integrated into your CI pipeline to make sure that every commit is correct without running a full audit again."}),(0,o.jsxs)(t.p,{children:["We make bugs such as the ",(0,o.jsx)(t.a,{href:"https://www.gemini.com/fr-fr/cryptopedia/the-dao-hack-makerdao",children:"DAO hack"})," ($60 million stolen) virtually impossible to happen again."]})]}),"\n",(0,o.jsx)("figure",{children:(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Forge in forest",src:n(2727).A+"",width:"1024",height:"1024"})})}),"\n",(0,o.jsx)(t.h2,{id:"primitive-effects",children:"Primitive effects"}),"\n",(0,o.jsxs)(t.p,{children:["In functional programming, effects (or side-effects) are every operation that cannot be directly represented as a mathematical function, that is to say, a procedure that returns an output purely based on the value of its inputs and does nothing else. For example, the function returning the current time makes an effect as it depends on a hidden state (the current time) that is not passed as an argument. The function printing a message to the console makes an effect as it modifies the state of the console, in addition to returning a value that is generally either empty or a confirmation of the printing. Arithmetic operations (",(0,o.jsx)(t.code,{children:"+"}),", ",(0,o.jsx)(t.code,{children:"*"}),", ...) are an example of pure functions."]}),"\n",(0,o.jsx)(t.p,{children:"We consider three primitive effects in our Rust code:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Panic"})," For many reasons, a Rust program can panic, as a result of an out-of-bounds access to an array or a wrong ",(0,o.jsx)(t.a,{href:"https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap",children:"unwrap"}),", for example. This is an effect as no outputs are returned in case of a panic."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Result"})," The ",(0,o.jsx)(t.code,{children:"Result"})," type is used to represent the result of a computation that can fail. It is a sum type with two constructors: ",(0,o.jsx)(t.code,{children:"Ok"})," for the successful result and ",(0,o.jsx)(t.code,{children:"Err"})," for the error. The ",(0,o.jsxs)(t.a,{href:"https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html",children:["Rust operator ",(0,o.jsx)(t.code,{children:"?"})]})," is used to propagate errors in a function that returns a ",(0,o.jsx)(t.code,{children:"Result"}),". This is another effect for us."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"State"})," Finally, we consider the functions that mutate one of their arguments as effectful. The mutated parameter is generally typed as a mutable reference ",(0,o.jsx)(t.code,{children:"&mut"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["All our Coq definitions to represent the effects are in the file ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/guillaume-claret%40fix-remaining-tests/CoqOfRust/simulations/M.v",children:"simulations/M.v"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"panic",children:"Panic"}),"\n",(0,o.jsxs)(t.p,{children:["We define a monad ",(0,o.jsx)(t.code,{children:"Panic.t"})," to represent the effect of a panic with:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Module Panic.\n  Inductive t (A : Set) : Set :=\n  | Value : A -> t A\n  | Panic {Error : Set} : Error -> t A.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Note that the type ",(0,o.jsx)(t.code,{children:"Error"})," in this position is an existential type. This has a few consequences:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We do not need to annotate the type ",(0,o.jsx)(t.code,{children:"Panic.t"})," with the type of the error."]}),"\n",(0,o.jsxs)(t.li,{children:["We can use any type for ",(0,o.jsx)(t.code,{children:"Error"})," when we trigger a panic operation. This is useful for debugging, as we can add any payload to the panic message to help us understand what went wrong."]}),"\n",(0,o.jsx)(t.li,{children:"We cannot compute on the panic payload. We do not consider this as a limitation, as panics should not be caught and handled in a Rust program, only propagated."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["We define the monadic ",(0,o.jsx)(t.em,{children:"return"})," and ",(0,o.jsx)(t.em,{children:"bind"})," operations as usual:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Definition return_ {A : Set} (value : A) : t A := Value value.\n\nDefinition bind {A B : Set} (value : t A) (f : A -> t B) : t B :=\n  match value with\n  | Value value => f value\n  | Panic error => Panic error\n  end.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We introduce notations based on the exclamation mark ",(0,o.jsx)(t.code,{children:"!"})," to make the code more readable:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Notation \"M!\" := Panic.t.\n\nNotation \"return!\" := Panic.return_.\n\nNotation \"'let!' x ':=' X 'in' Y\" :=\n  (Panic.bind X (fun x => Y))\n  (at level 200, x pattern, X at level 100, Y at level 200).\n"})}),"\n",(0,o.jsx)(t.h3,{id:"result",children:"Result"}),"\n",(0,o.jsxs)(t.p,{children:["We define the monad ",(0,o.jsx)(t.code,{children:"Result.t"})," to represent the propagation of errors with the ",(0,o.jsx)(t.code,{children:"?"})," operator with:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Module Result.\n  Inductive t (A Error : Set) : Set :=\n  | Ok : A -> t A Error\n  | Err : Error -> t A Error.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The difference with the ",(0,o.jsx)(t.code,{children:"Panic.t"})," monad is that the error type is not existential anymore. This is because we want to be able to compute on the error payload, as some functions depend on the error value."]}),"\n",(0,o.jsxs)(t.p,{children:["We define the ",(0,o.jsx)(t.em,{children:"return"})," and ",(0,o.jsx)(t.em,{children:"bind"})," operations as:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Definition return_ {A Error : Set} (value : A) : t A Error := Ok value.\n\nDefinition bind {Error A B : Set} (value : t A Error) (f : A -> t B Error) : t B Error :=\n  match value with\n  | Ok value => f value\n  | Err error => Err error\n  end.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.em,{children:"bind"})," corresponds to the question mark operator ",(0,o.jsx)(t.code,{children:"?"})," in Rust. We also introduce notation to make the code more readable:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Notation \"M?\" := (fun A Error => Result.t Error A).\n\nNotation \"return?\" := Result.return_.\n\nNotation \"'let?' x ':=' X 'in' Y\" := ...\n"})}),"\n",(0,o.jsx)(t.h3,{id:"state",children:"State"}),"\n",(0,o.jsxs)(t.p,{children:["Finally, we define the monad ",(0,o.jsx)(t.code,{children:"State.t"}),"\xa0\ud83c\uddfa\ud83c\uddf8 to represent the effect of one or several mutable references with a mutable state type\xa0",(0,o.jsx)(t.code,{children:"S"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Module State.\n  Definition t (State A : Set) : Set := State -> A * State.\n\n  Definition return_ {State A : Set} (value : A) : t State A :=\n    fun state => (value, state).\n\n  Definition bind {State A B : Set} (value : t State A) (f : A -> t State B) : t State B :=\n    fun state =>\n      let (value, state) := value state in\n      f value state.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The state\xa0",(0,o.jsx)(t.code,{children:"S"})," will typically be the tuple of all the current mutable references in the Rust code. We use notations based on the letter\xa0",(0,o.jsx)(t.code,{children:"S"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"We also introduce lens operations that mimic how we can extract a mutable reference to the part of a data structure from a mutable reference to the whole data structure in Rust. Here is the definition of the lens type:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Record t {Big_A A : Set} : Set := {\n  read : Big_A -> M! A;\n  write : Big_A -> A -> M! Big_A\n}.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"read"})," and ",(0,o.jsx)(t.code,{children:"write"})," operations correspond to the dereferencing and the assignment of a mutable reference in Rust. The type ",(0,o.jsx)(t.code,{children:"Big_A"})," is the type of the whole data structure, and the type ",(0,o.jsx)(t.code,{children:"A"})," is the type of the part that we are referencing. These primitives might fail (there are in the panic monad) if the mutable reference is not valid, for example, for an out-of-bounds access in an array or an invalid case in an enum."]}),"\n",(0,o.jsxs)(t.p,{children:["We can use a lens to lift a computation that operates on a part of a data structure to a computation that operates on the whole data structure. We provide various ",(0,o.jsx)(t.em,{children:"lift"})," operators to help with this."]}),"\n",(0,o.jsx)(t.h2,{id:"combinaisons",children:"Combinaisons"}),"\n",(0,o.jsx)(t.p,{children:"Depending on the Rust code we want to translate, we might need to use none, one, or several of the effects above. We explicitly define all the possible combinations of the above monads, as well as return operations to go from one monad to another, more general monad."}),"\n",(0,o.jsx)(t.p,{children:"The special case is for the combination of the panic and state effect. When a panic occurs, we do not return the resulting state, as we are not supposed to continue the evaluation after a panic so the current state should not be relevant. We lose the information about the state of the program when a panic occurs, which can be a limitation for debugging, but:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"It simplifies some definitions of simulations, and forces us not to speak about the specification of a state after a panic, what should not be relevant."}),"\n",(0,o.jsx)(t.li,{children:"We can still return the current state as an additional payload in the panic operator. This is actually what our panic operator does by default."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The most complete monad combines all the effects:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Module StatePanicResult.\n  Definition t (State Error A : Set) : Set :=\n    MS! State (M? Error A).\n\n  Definition return_ {State Error A : Set} (value : A) : t State Error A :=\n    returnS! (Result.Ok value).\n\n  Definition bind {State Error A B : Set}\n      (value : t State Error A)\n      (f : A -> t State Error B) :\n      t State Error B :=\n    letS! value := value in\n    match value with\n    | Result.Ok value => f value\n    | Result.Err error => returnS! (Result.Err error)\n    end.\n"})}),"\n",(0,o.jsx)(t.p,{children:"with the notations:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Notation \"MS!?\" := StatePanicResult.t.\n\nNotation \"returnS!?\" := StatePanicResult.return_.\n\nNotation \"'letS!?' x ':=' X 'in' Y\" := ...\n"})}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsx)(t.p,{children:"We are repeating our notations a lot, as our three effects and their combinations are very similar. In addition, we always have to explicitly choose in our code which monad we use and add explicit conversions to go from one to another. A future enhancement could be to add some automation at this level, through the use of type-classes, for example, to automatically infer the monad to use based on the operations used in the code\xa0\ud83e\uddbe. For now, we prefer to stay explicit."})}),"\n",(0,o.jsx)(t.h2,{id:"iterations",children:"Iterations"}),"\n",(0,o.jsxs)(t.p,{children:["To convert code involving ",(0,o.jsx)(t.code,{children:"for"})," loops\xa0\ud83d\udd01 or manipulations with the ",(0,o.jsx)(t.code,{children:".map"})," method of iterators, we introduce the effectful version of the ",(0,o.jsx)(t.code,{children:"for"})," loop (",(0,o.jsx)(t.em,{children:"fold"})," or ",(0,o.jsx)(t.em,{children:"reduce"})," in functional languages) and the ",(0,o.jsx)(t.code,{children:"map"})," method. For example, for the folding operation:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"(** The order of parameters is the same as in the source `for` loops. *)\nDefinition fold_left {State Error A B : Set}\n    (init : A)\n    (l : list B)\n    (f : A -> B -> t State Error A) :\n    t State Error A :=\n  List.fold_left (fun acc x => bind acc (fun acc => f acc x)) l (return_ init).\n"})}),"\n",(0,o.jsx)(t.p,{children:"with the notation:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:'Notation "foldS!?" := StatePanicResult.fold_left.\n'})}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(t.p,{children:["Thanks to the definitions and notations above, we were able to translate (manually/with GitHub Copilot) all the code of the type-checker for the Move bytecode to Coq in an idiomatic Coq code of a size roughly similar to the original Rust code. This translation is available in our folder ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/tree/guillaume-claret%40fix-remaining-tests/CoqOfRust/move_sui/simulations/move_bytecode_verifier",children:"move_sui/simulations/move_bytecode_verifier"}),"\xa0\ud83d\ude80."]}),"\n",(0,o.jsx)(t.p,{children:"In the next post we will present how we tested this translation to be faithful to the original Rust code, waiting to have an efficient way to prove it equivalent."}),"\n",(0,o.jsx)(t.admonition,{title:"For more",type:"success",children:(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:["Follow us on ",(0,o.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,o.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"}),", or comment on this post below! Feel free to DM us for any services you need."]})})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},2727:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/symbol-in-forest-2736087d13abf00b43371addf04a619d.webp"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var o=n(6540);const r={},a=o.createContext(r);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);