"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[6079],{2135:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>n,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=o(4848),a=o(8453);const i={title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 1",tags:["Sui","formal verification","Coq","Rust","Move","type checker"],authors:[]},n=void 0,s={permalink:"/blog/2024/08/19/verification-move-sui-type-checker-1",source:"@site/blog/2024-08-19-verification-move-sui-type-checker-1.md",title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 1",description:"In this blog post, we present our project to formally verify the implementation of the type checker for smart contracts of the \ud83d\udca7&nbsp;Sui blockchain. The Sui blockchain uses the Move language to express smart contracts. This language is implemented in \ud83e\udd80&nbsp;Rust and compiles down to the Move bytecode that is loaded in memory when executing the smart contracts.",date:"2024-08-19T00:00:00.000Z",formattedDate:"August 19, 2024",tags:[{label:"Sui",permalink:"/blog/tags/sui"},{label:"formal verification",permalink:"/blog/tags/formal-verification"},{label:"Coq",permalink:"/blog/tags/coq"},{label:"Rust",permalink:"/blog/tags/rust"},{label:"Move",permalink:"/blog/tags/move"},{label:"type checker",permalink:"/blog/tags/type-checker"}],readingTime:2.575,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Formal verification of the type checker of Sui \u2013 part 1",tags:["Sui","formal verification","Coq","Rust","Move","type checker"],authors:[]},unlisted:!1,prevItem:{title:"\ud83c\udf32 What we do at Formal Land",permalink:"/blog/2024/10/13/class-what-we-do"},nextItem:{title:"\ud83e\ude81 Coq of Solidity \u2013 part 4",permalink:"/blog/2024/08/13/coq-of-solidity-4"}},c={authorsImageUrls:[]},l=[];function h(e){const t={a:"a",p:"p",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["In this blog post, we present our project to formally verify the implementation of the type checker for smart contracts of the ",(0,r.jsx)(t.a,{href:"https://sui.io/",children:"\ud83d\udca7\xa0Sui blockchain"}),". The Sui blockchain uses the ",(0,r.jsx)(t.a,{href:"https://sui.io/move",children:"Move"})," language to express smart contracts. This language is implemented in ",(0,r.jsx)(t.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"})," and compiles down to the Move bytecode that is loaded in memory when executing the smart contracts."]}),"\n",(0,r.jsxs)(t.p,{children:["We will formally verify the part that checks that the bytecode is well-typed, so that when a smart contract is executed it cannot encounter critical errors. The ",(0,r.jsx)(t.a,{href:"https://github.com/move-language/move-sui/blob/main/crates/move-bytecode-verifier/src/type_safety.rs",children:"type checker itself"})," is also written in Rust, and we will verify it using the proof assistant ",(0,r.jsx)(t.a,{href:"https://coq.inria.fr/",children:"Coq\xa0\ud83d\udc13"})," and our tool ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," that translates Rust programs to Coq."]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>n,x:()=>s});var r=o(6540);const a={},i=r.createContext(a);function n(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);