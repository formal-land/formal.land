"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2875],{451:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var n=t(4848),a=t(8453);const i={title:"\u2688 Verification of the Smoo.th library \u2013 2",tags:["Solidity","Yul","elliptic curves"],authors:[]},o=void 0,r={permalink:"/blog/2024/10/28/verification-smooth-library-2",source:"@site/blog/2024-10-28-verification-smooth-library-2.md",title:"\u2688 Verification of the Smoo.th library \u2013 2",description:"In this blog post, we detail the continuation of our work to formally verify the \u2688&nbsp;Smoo.th library, which is an optimized implementation of elliptic curve operations in Solidity. We use our tool coq-of-solidity, representing any Solidity code in the generic proof assistant \ud83d\udc13&nbsp;Coq, to verify the code for any execution path.",date:"2024-10-28T00:00:00.000Z",formattedDate:"October 28, 2024",tags:[{label:"Solidity",permalink:"/blog/tags/solidity"},{label:"Yul",permalink:"/blog/tags/yul"},{label:"elliptic curves",permalink:"/blog/tags/elliptic-curves"}],readingTime:6.86,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\u2688 Verification of the Smoo.th library \u2013 2",tags:["Solidity","Yul","elliptic curves"],authors:[]},unlisted:!1,prevItem:{title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 1",permalink:"/blog/2024/11/01/tool-for-noir-1"},nextItem:{title:"\ud83c\udf32 What we bring you",permalink:"/blog/2024/10/22/what-we-bring-to-you"}},l={authorsImageUrls:[]},c=[{value:"\ud83d\udc0c Unoptimized Yul",id:"-unoptimized-yul",level:2},{value:"\ud83c\udf97\ufe0f Verification of the loop",id:"\ufe0f-verification-of-the-loop",level:2},{value:"\ud83d\udca1 Reasoning rule",id:"-reasoning-rule",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function h(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",img:"img",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.p,{children:["In this blog post, we detail the continuation of our work to formally verify the ",(0,n.jsx)(s.a,{href:"https://smoo.th/",children:"\u2688\xa0Smoo.th"})," library, which is an optimized implementation of elliptic curve operations in Solidity. We use our tool ",(0,n.jsx)(s.a,{href:"https://github.com/formal-land/coq-of-solidity",children:"coq-of-solidity"}),", representing any Solidity code in the generic proof assistant ",(0,n.jsx)(s.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),", to verify the code for any execution path."]}),"\n",(0,n.jsx)(s.p,{children:"In particular, we cover the changes we made to use unoptimized Yul code and how we made a functional representation of the loop to compute the most significant bit of the scalars."}),"\n",(0,n.jsxs)(s.admonition,{title:"Get started",type:"success",children:[(0,n.jsxs)(s.p,{children:["To ensure your code is secure today, contact us at\xa0",(0,n.jsx)(s.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"}),"!\xa0\ud83d\ude80"]}),(0,n.jsxs)(s.p,{children:["Formal verification goes further than traditional audits to make 100% sure you cannot lose your funds, thanks to ",(0,n.jsx)(s.strong,{children:"mathematical reasoning on the code"}),". It can be integrated into your CI pipeline to check that every commit is fully correct ",(0,n.jsx)(s.strong,{children:"without doing a whole audit again"}),"."]}),(0,n.jsxs)(s.p,{children:["We make bugs such as the ",(0,n.jsx)(s.a,{href:"https://www.gemini.com/fr-fr/cryptopedia/the-dao-hack-makerdao",children:"DAO hack"})," ($60 million stolen) virtually ",(0,n.jsx)(s.strong,{children:"impossible to happen again"}),"."]})]}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Smooth in forest",src:t(4578).A+"",width:"1024",height:"1024"})})}),"\n",(0,n.jsx)(s.h2,{id:"-unoptimized-yul",children:"\ud83d\udc0c Unoptimized Yul"}),"\n",(0,n.jsxs)(s.p,{children:["We are now verifying the code based on the unoptimized ",(0,n.jsx)(s.a,{href:"https://docs.soliditylang.org/en/latest/yul.html",children:"Yul"})," output of the Solidity compiler instead of the optimized one. As a consequence the code is a little bit more verbose, although in our present case the difference is limited as we are verifying a code that is already hand-optimized. The main advantage is that the variables are preserved instead of being moved to locations in the memory, which makes the verification easier, especially when handling loop invariants. A downside is that we now have to trust the correctness of the Solidity compiler's optimization passes."]}),"\n",(0,n.jsx)(s.p,{children:"As an example, here is how we now translate in Coq the loop to compute the most significant bit of the scalars with the unoptimized Yul code:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-coq",children:"let~ var_ZZZ_83 := [[ 0 ]] in\nlet_state~ '(var_ZZZ_83, var_mask_63) :=\n  (* for loop *)\n  Shallow.for_\n    (* init state *)\n    (var_ZZZ_83, var_mask_63)\n    (* condition *)\n    (fun '(var_ZZZ_83, var_mask_63) => [[\n      iszero ~(| var_ZZZ_83 |)\n    ]])\n    (* body *)\n    (fun '(var_ZZZ_83, var_mask_63) =>\n      Shallow.lift_state_update\n        (fun var_ZZZ_83 => (var_ZZZ_83, var_mask_63))\n        (let~ var_ZZZ_83 := [[ add ~(| add ~(| sub ~(| 1, iszero ~(| and ~(| var_scalar_u_55, var_mask_63 |) |) |), shl ~(| 1, sub ~(| 1, iszero ~(| and ~(| shr ~(| 128, var_scalar_u_55 |), var_mask_63 |) |) |) |) |), add ~(| shl ~(| 2, sub ~(| 1, iszero ~(| and ~(| var_scalar_v_57, var_mask_63 |) |) |) |), shl ~(| 3, sub ~(| 1, iszero ~(| and ~(| shr ~(| 128, var_scalar_v_57 |), var_mask_63 |) |) |) |) |) |) ]] in\n        M.pure (BlockUnit.Tt, var_ZZZ_83)))\n    (* post *)\n    (fun '(var_ZZZ_83, var_mask_63) =>\n      Shallow.lift_state_update\n        (fun var_mask_63 => (var_ZZZ_83, var_mask_63))\n        (let~ var_mask_63 := [[ shr ~(| 1, var_mask_63 |) ]] in\n        M.pure (BlockUnit.Tt, var_mask_63)))\n"})}),"\n",(0,n.jsx)(s.p,{children:"As a reference, here is the original smart contract code, in hand-written Yul:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-go",children:"ZZZ := 0\nfor {} iszero(ZZZ) { mask := shr(1, mask) } {\n  ZZZ := add(\n    add(\n      sub(1, iszero(and(scalar_u, mask))),\n      shl(1, sub(1, iszero(and(shr(128, scalar_u), mask))))\n    ),\n    add(\n      shl(2, sub(1, iszero(and(scalar_v, mask)))),\n      shl(3, sub(1, iszero(and(shr(128, scalar_v), mask))))\n    )\n  )\n}\n"})}),"\n",(0,n.jsxs)(s.p,{children:["We recognize the variables ",(0,n.jsx)(s.code,{children:"var_ZZZ_83"})," and ",(0,n.jsx)(s.code,{children:"var_mask_63"}),", corresponding to ",(0,n.jsx)(s.code,{children:"ZZZ"})," and ",(0,n.jsx)(s.code,{children:"mask"})," in the original code. They are made explicit in a state monad with the state ",(0,n.jsx)(s.code,{children:"(var_ZZZ_83, var_mask_63)"})," for the loop."]}),"\n",(0,n.jsxs)(s.p,{children:["We had some constructs we were not handling in ",(0,n.jsx)(s.code,{children:"coq-of-solidity"}),", for constructs that appeared in the optimized code but not in the unoptimized one. An example is the initialization part of the ",(0,n.jsx)(s.code,{children:"for"})," loop that seems to be always move away in the optimized code. We added those missing cases to our tool to be able to translate the unoptimized Yul code of Smoo.th."]}),"\n",(0,n.jsx)(s.h2,{id:"\ufe0f-verification-of-the-loop",children:"\ud83c\udf97\ufe0f Verification of the loop"}),"\n",(0,n.jsxs)(s.p,{children:["Verifying the\xa0",(0,n.jsx)(s.code,{children:"for"})," loop above can be challenging. Automated verification tools for Solidity typically do not fully handle loops, and instead unroll them three or four times to check the first iterations, which can miss some bugs."]}),"\n",(0,n.jsxs)(s.p,{children:["The first step is to prove the loop is equivalent to a recursive function, as this will simplify reasoning. Here is a recursive function that computes the most significant bit of the scalars ",(0,n.jsx)(s.code,{children:"u"})," and ",(0,n.jsx)(s.code,{children:"v"}),":"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-coq",children:"Fixpoint get\n  (u_low u_high v_low v_high : U128.t) (over_index : nat) :\n  PointsSelector.t * nat :=\n  match over_index with\n  | O =>\n    (* We should never reach this case if the scalars\n       are not all zero *)\n    (PointsSelector.Build_t false false false false, O)\n  | S index =>\n    let selector := HighLow.get_selector\n      u_low u_high v_low v_high (Z.of_nat index) in\n    if PointsSelector.is_zero selector then\n      let new_over_index := index in\n      get u_low u_high v_low v_high new_over_index\n    else\n      let next_over_index := index in\n      (selector, next_over_index)\n  end.\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Here are some notable changes compared to the original ",(0,n.jsx)(s.code,{children:"for"})," loop:"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["We decompose the scalars ",(0,n.jsx)(s.code,{children:"u"})," and ",(0,n.jsx)(s.code,{children:"v"})," of 256 bits into their high and low parts, ",(0,n.jsx)(s.code,{children:"u_low"}),", ",(0,n.jsx)(s.code,{children:"u_high"}),", ",(0,n.jsx)(s.code,{children:"v_low"}),", and ",(0,n.jsx)(s.code,{children:"v_high"})," of 128 bits each."]}),"\n",(0,n.jsxs)(s.li,{children:["We make explicit the scalars that we select with the ",(0,n.jsx)(s.code,{children:"PointsSelector"})," type, which is a record with four boolean fields. In the original code, the ",(0,n.jsx)(s.code,{children:"ZZZ"})," variable is used to group these four booleans into a single integer."]}),"\n",(0,n.jsxs)(s.li,{children:["We use a natural number ",(0,n.jsx)(s.code,{children:"over_index"})," to represent the mask. We decrement it at each iteration until it reaches zero, proving by construction the termination of the function. The relation with the mask is:"]}),"\n"]}),"\n",(0,n.jsx)(s.span,{className:"katex-display",children:(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mtext,{children:"mask"}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsx)(s.mo,{stretchy:"false",children:"\u230a"}),(0,n.jsxs)(s.msup,{children:[(0,n.jsx)(s.mn,{children:"2"}),(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mtext,{children:"over_index"}),(0,n.jsx)(s.mo,{children:"\u2212"}),(0,n.jsx)(s.mn,{children:"1"})]})]}),(0,n.jsx)(s.mo,{stretchy:"false",children:"\u230b"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\text{mask} = \\lfloor 2^{\\text{over\\_index} - 1} \\rfloor"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6944em"}}),(0,n.jsx)(s.span,{className:"mord text",children:(0,n.jsx)(s.span,{className:"mord",children:"mask"})}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(s.span,{className:"mrel",children:"="}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1.1491em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mopen",children:"\u230a"}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord",children:"2"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsx)(s.span,{className:"vlist-t",children:(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.8991em"},children:(0,n.jsxs)(s.span,{style:{top:"-3.113em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsxs)(s.span,{className:"mord mtight",children:[(0,n.jsx)(s.span,{className:"mord text mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"over_index"})}),(0,n.jsx)(s.span,{className:"mbin mtight",children:"\u2212"}),(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})]})})]})})})})})]}),(0,n.jsx)(s.span,{className:"mclose",children:"\u230b"})]})]})]})}),"\n",(0,n.jsxs)(s.p,{children:["Note that this means that when the ",(0,n.jsx)(s.code,{children:"over_index"})," is zero, then the ",(0,n.jsx)(s.code,{children:"mask"})," is zero. This corresponds to the last case of the loop. We use the variable name ",(0,n.jsx)(s.code,{children:"over_index"})," so that if we define:"]}),"\n",(0,n.jsx)(s.span,{className:"katex-display",children:(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mtext,{children:"over_index"}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsx)(s.mtext,{children:"index"}),(0,n.jsx)(s.mo,{children:"+"}),(0,n.jsx)(s.mn,{children:"1"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\text{over\\_index} = \\text{index} + 1"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1.0044em",verticalAlign:"-0.31em"}}),(0,n.jsx)(s.span,{className:"mord text",children:(0,n.jsx)(s.span,{className:"mord",children:"over_index"})}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(s.span,{className:"mrel",children:"="}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.7778em",verticalAlign:"-0.0833em"}}),(0,n.jsx)(s.span,{className:"mord text",children:(0,n.jsx)(s.span,{className:"mord",children:"index"})}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,n.jsx)(s.span,{className:"mbin",children:"+"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(s.span,{className:"mord",children:"1"})]})]})]})}),"\n",(0,n.jsx)(s.p,{children:"then the relation with the mask is:"}),"\n",(0,n.jsx)(s.span,{className:"katex-display",children:(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mtext,{children:"mask"}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsxs)(s.msup,{children:[(0,n.jsx)(s.mn,{children:"2"}),(0,n.jsx)(s.mtext,{children:"index"})]})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\text{mask} = 2^{\\text{index}}"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6944em"}}),(0,n.jsx)(s.span,{className:"mord text",children:(0,n.jsx)(s.span,{className:"mord",children:"mask"})}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(s.span,{className:"mrel",children:"="}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8991em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord",children:"2"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsx)(s.span,{className:"vlist-t",children:(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.8991em"},children:(0,n.jsxs)(s.span,{style:{top:"-3.113em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:(0,n.jsx)(s.span,{className:"mord text mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"index"})})})})]})})})})})]})]})]})]})}),"\n",(0,n.jsx)(s.p,{children:"for all cases except the last one."}),"\n",(0,n.jsx)(s.h2,{id:"-reasoning-rule",children:"\ud83d\udca1 Reasoning rule"}),"\n",(0,n.jsx)(s.p,{children:"Here is the reasoning rule for the smart contract loops in Coq:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-coq",children:"Lemma LoopStep codes environment {In Out : Set}\n    (init : In)\n    (body : In -> LowM.t Out)\n    (break_with : Out -> In + Out)\n    (k : Out -> LowM.t Out)\n    (output output_inter : Out)\n    state state_inter state'\n    (H_body :\n      {{? codes, environment, state |\n        body init \u21d3 output_inter\n      | state_inter ?}}\n    )\n    (H_break_with :\n      match break_with output_inter with\n      | inr output_inter' =>\n        {{? codes, environment, state_inter |\n          k output_inter' \u21d3 output\n        | state' ?}}\n      | inl next_init =>\n        {{? codes, environment, state_inter |\n          LowM.Loop next_init body break_with k \u21d3 output\n        | state' ?}}\n      end\n    ) :\n  {{? codes, environment, state |\n    LowM.Loop init body break_with k \u21d3 output\n  | state' ?}}.\n"})}),"\n",(0,n.jsxs)(s.p,{children:["This rule, to be used in combination with some reasoning by induction, allows us to verify that a certain property is true for any number of iterations of the loop. In the present case, we use it to prove that the recursive function ",(0,n.jsx)(s.code,{children:"get"})," is equivalent to the ",(0,n.jsx)(s.code,{children:"for"})," loop. Basically, it states that:"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Assuming that the ",(0,n.jsx)(s.code,{children:"body"})," of the loop evaluates to some output ",(0,n.jsx)(s.code,{children:"output_inter"}),","]}),"\n",(0,n.jsxs)(s.li,{children:["if the ",(0,n.jsx)(s.code,{children:"break_with"})," helper, which wraps the end of the end of the loop to either continue the loop or break it, evaluates to ",(0,n.jsx)(s.code,{children:"output"}),","]}),"\n",(0,n.jsxs)(s.li,{children:["then the whole loop evaluates to ",(0,n.jsx)(s.code,{children:"output"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["Here, the output of the body of the loop contains the state of the state monad, that is to say, the two variables ",(0,n.jsx)(s.code,{children:"ZZZ"})," and ",(0,n.jsx)(s.code,{children:"mask"}),", and a special variable to break or continue the ",(0,n.jsx)(s.code,{children:"for"})," loop iterations."]}),"\n",(0,n.jsxs)(s.p,{children:["Due to a lack of time, we only made a sketch of the proof of evaluation of this loop, admitting some intermediate lemmas about identities over the selector function. This work is available in the file ",(0,n.jsx)(s.a,{href:"https://github.com/formal-land/coq-of-solidity/blob/develop/coq/CoqOfSolidity/contracts/scl/mulmuladdX_fullgen_b4/run.v",children:"coq/CoqOfSolidity/contracts/scl/mulmuladdX_fullgen_b4/run.v"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,n.jsxs)(s.p,{children:["We have seen how to reason about loops with ",(0,n.jsx)(s.code,{children:"coq-of-solidity"}),". This example with bit-level arithmetic was rather complex, but the general idea is still to reason by induction, showing the equivalence with a recursive function, using the reasoning rule ",(0,n.jsx)(s.code,{children:"LoopStep"})," above to step through the loop."]}),"\n",(0,n.jsx)(s.p,{children:"If you have smart contracts that you need to secure, talk to us!\xa0\ud83e\udd1d The cost of an attack always far outweights the cost of an audit, and our solution, with full formal verification, is the more extensive in terms of coverage."}),"\n",(0,n.jsx)(s.admonition,{title:"For more",type:"success",children:(0,n.jsx)(s.p,{children:(0,n.jsxs)(s.em,{children:["Follow us on ",(0,n.jsx)(s.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,n.jsx)(s.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions or requests!"]})})})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},4578:(e,s,t)=>{t.d(s,{A:()=>n});const n=t.p+"assets/images/forest-smooth-9d52a7b4fe8f74b78bba9c29384633bf.webp"},8453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>r});var n=t(6540);const a={},i=n.createContext(a);function o(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);