"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[6555],{45752:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=n(74848),i=n(28453);const s={title:"\ud83e\udd77 Formal verification of LLZK circuits in Rocq",tags:["LLZK","formal verification","zero-knowledge"],authors:[]},a=void 0,o={permalink:"/blog/2025/07/31/llzk-to-rocq-verification",source:"@site/blog/2025-07-31-llzk-to-rocq-verification.md",title:"\ud83e\udd77 Formal verification of LLZK circuits in Rocq",description:"In this blog post, we present a short example about how we define reasoning rules in Rocq to formally verify the safety of zero-knowledge circuits written in LLZK.",date:"2025-07-31T00:00:00.000Z",formattedDate:"July 31, 2025",tags:[{label:"LLZK",permalink:"/blog/tags/llzk"},{label:"formal verification",permalink:"/blog/tags/formal-verification"},{label:"zero-knowledge",permalink:"/blog/tags/zero-knowledge"}],readingTime:9.05,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd77 Formal verification of LLZK circuits in Rocq",tags:["LLZK","formal verification","zero-knowledge"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd84 Short introduction to Rocq",permalink:"/blog/2025/08/11/quick-rocq-in-a-hurry"},nextItem:{title:"\ud83e\udd77 Semantics for LLZK in Rocq",permalink:"/blog/2025/07/30/llzk-to-rocq-semantics"}},l={authorsImageUrls:[]},c=[{value:"\ud83e\uddee Reasoning rules",id:"-reasoning-rules",level:2},{value:"<code>Pure</code>",id:"pure",level:3},{value:"<code>AssertEqual</code>",id:"assertequal",level:3},{value:"<code>CreateStruct</code>",id:"createstruct",level:3},{value:"<code>FieldWrite</code>",id:"fieldwrite",level:3},{value:"<code>Let</code>",id:"let",level:3},{value:"<code>Implies</code>",id:"implies",level:3},{value:"\ud83d\udcdd Example",id:"-example",level:2},{value:"<code>global_add</code>",id:"global_add",level:3},{value:"<code>compute</code>",id:"compute",level:3},{value:"<code>constrain</code>",id:"constrain",level:3},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function d(e){const t={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mo:"mo",mrow:"mrow",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["In this blog post, we present a short example about how we define reasoning rules in ",(0,r.jsx)(t.a,{href:"https://rocq-prover.org/",children:"Rocq"})," to formally verify the safety of zero-knowledge circuits written in ",(0,r.jsx)(t.a,{href:"https://github.com/Veridise/llzk-lib",children:"LLZK"}),"."]}),"\n",(0,r.jsxs)(t.admonition,{title:"Follow-up",type:"info",children:[(0,r.jsx)(t.p,{children:"This blog post is a follow-up to:"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/blog/2025/07/30/llzk-to-rocq-semantics",children:"\ud83e\udd77 Semantics for LLZK in Rocq"})}),"\n"]}),(0,r.jsxs)(t.p,{children:["The code we are referring to in this post is available in ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/garden/tree/main/Garden/LLZK",children:"github.com/formal-land/garden/Garden/LLZK"}),"."]})]}),"\n",(0,r.jsx)("figure",{children:(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Green forest",src:n(69653).A+"",width:"1024",height:"1024"})})}),"\n",(0,r.jsx)(t.h2,{id:"-reasoning-rules",children:"\ud83e\uddee Reasoning rules"}),"\n",(0,r.jsx)(t.p,{children:"As we use a free monad to represent the effectful operations of LLZK, we need to define reasoning rules to evaluate each operator."}),"\n",(0,r.jsx)(t.p,{children:"In order to optimize the proofs for the verification of safety properties (no under-constraints), we will assume that the execution of LLZK terms is always complete. By complete, we mean that there are no out-of-bound accesses in arrays. We also mean that we initialize each value exactly once, for the pattern where we declare an array and then set its elements in a second step, for example."}),"\n",(0,r.jsxs)(t.p,{children:["For the circuits, this is a reasonable assumption, as they are executed only once, unrolling all the loops and function calls in a large set of polynomial equations. For the ",(0,r.jsx)(t.code,{children:"compute"})," functions that generate the witnesses, since they are stored off-chain, we can always upgrade them if we realize they are not complete. A proof of completeness for the ",(0,r.jsx)(t.code,{children:"compute"})," functions could be done independently using a dedicated semantics."]}),"\n",(0,r.jsx)(t.p,{children:"We define a predicate:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"{{ e \ud83d\udd3d result , P }}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["saying that a monadic computation ",(0,r.jsx)(t.code,{children:"e"})," can reduce to the value ",(0,r.jsx)(t.code,{children:"output"}),", and that its successful execution implies that the predicate ",(0,r.jsx)(t.code,{children:"P"})," holds. The predicate ",(0,r.jsx)(t.code,{children:"P"})," typically applies to the input and output field variables of the circuit. A typical predicate is:"]}),"\n",(0,r.jsx)(t.span,{className:"katex-display",children:(0,r.jsxs)(t.span,{className:"katex",children:[(0,r.jsx)(t.span,{className:"katex-mathml",children:(0,r.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,r.jsxs)(t.semantics,{children:[(0,r.jsxs)(t.mrow,{children:[(0,r.jsx)(t.mtext,{children:"output"}),(0,r.jsx)(t.mo,{children:"="}),(0,r.jsx)(t.mtext,{children:"expected_output(input)"})]}),(0,r.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\text{output} = \\text{expected\\_output(\\text{input})}"})]})})}),(0,r.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(t.span,{className:"base",children:[(0,r.jsx)(t.span,{className:"strut",style:{height:"0.8095em",verticalAlign:"-0.1944em"}}),(0,r.jsx)(t.span,{className:"mord text",children:(0,r.jsx)(t.span,{className:"mord",children:"output"})}),(0,r.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.jsx)(t.span,{className:"mrel",children:"="}),(0,r.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,r.jsxs)(t.span,{className:"base",children:[(0,r.jsx)(t.span,{className:"strut",style:{height:"1.06em",verticalAlign:"-0.31em"}}),(0,r.jsxs)(t.span,{className:"mord text",children:[(0,r.jsx)(t.span,{className:"mord",children:"expected_output("}),(0,r.jsx)(t.span,{className:"mord text",children:(0,r.jsx)(t.span,{className:"mord",children:"input"})}),(0,r.jsx)(t.span,{className:"mord",children:")"})]})]})]})]})}),"\n",(0,r.jsx)(t.p,{children:"stating that the circuit is deterministic."}),"\n",(0,r.jsx)(t.p,{children:"The main reasoning rules are, in Rocq code:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:'Inductive t : forall {A : Set}, M.t A -> A -> Prop -> Prop :=\n| Pure {A : Set} (value : A) :\n  {{ M.Pure value \ud83d\udd3d value, True }}\n| AssertEqual {A : Set} (x1 x2 : A) :\n  {{ M.AssertEqual x1 x2 \ud83d\udd3d tt, x1 = x2 }}\n| CreateStruct {A : Set} (value : A) :\n  {{ M.CreateStruct \ud83d\udd3d value, True }}\n| FieldWrite {A : Set} (field : A) :\n  {{ M.FieldWrite field field \ud83d\udd3d tt, True }}\n| Let {A B : Set} (e : M.t A) (k : A -> M.t B) (value : A) (output : B) (P1 P2 : Prop) :\n  {{ e \ud83d\udd3d value, P1 }} ->\n  (P1 -> {{ k value \ud83d\udd3d output, P2 }}) ->\n  {{ M.Let e k \ud83d\udd3d output, P1 /\\ P2 }}\n| Implies {A : Set} (e : M.t A) (value : A) (P1 P2 : Prop) :\n  {{ e \ud83d\udd3d value, P1 }} ->\n  (P1 -> P2) ->\n  {{ e \ud83d\udd3d value, P2 }}\n\nwhere "{{ e \ud83d\udd3d output , P }}" := (t e output P).\n'})}),"\n",(0,r.jsx)(t.h3,{id:"pure",children:(0,r.jsx)(t.code,{children:"Pure"})}),"\n",(0,r.jsxs)(t.p,{children:["There is nothing special to say about the rule of the ",(0,r.jsx)(t.code,{children:"M.Pure"})," operator of the monad. We return the ",(0,r.jsx)(t.code,{children:"value"})," that we are supposed to return, whether it is in a fully evaluated form or still as an expression with some free variables. The predicate is ",(0,r.jsx)(t.code,{children:"True"})," as we do not assert any constraints."]}),"\n",(0,r.jsx)(t.h3,{id:"assertequal",children:(0,r.jsx)(t.code,{children:"AssertEqual"})}),"\n",(0,r.jsxs)(t.p,{children:["For the ",(0,r.jsx)(t.code,{children:"M.AssertEqual"})," operator, we always return the unit value ",(0,r.jsx)(t.code,{children:"tt"}),", and we assert that the two parameters are equal. The predicate is the equality between the two parameters, as this is the condition to successfully execute the operator."]}),"\n",(0,r.jsx)(t.h3,{id:"createstruct",children:(0,r.jsx)(t.code,{children:"CreateStruct"})}),"\n",(0,r.jsx)(t.p,{children:"With this operator, we can declare a new structure element, whose fields are to be set later. This is a non-deterministic operation, and we let the user choose the value of the structure when verifying the circuit. However, in practice, there is only one possible choice as the value of the structure must be compatible with the write operations that will follow."}),"\n",(0,r.jsx)(t.h3,{id:"fieldwrite",children:(0,r.jsx)(t.code,{children:"FieldWrite"})}),"\n",(0,r.jsx)(t.p,{children:"This operator is used to write a value in a field of a structure. We can apply this rule only if we have chosen the right value for the structure. We assume that all LLZK functions are complete, which can be checked at runtime, so that each declared structure has exactly one write operation, and we cannot make a read before the write."}),"\n",(0,r.jsx)(t.h3,{id:"let",children:(0,r.jsx)(t.code,{children:"Let"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"Let"})," rule is for the binding operator of the monad. It combines the conditions ",(0,r.jsx)(t.code,{children:"P1"})," and ",(0,r.jsx)(t.code,{children:"P2"})," to form a new predicate ",(0,r.jsx)(t.code,{children:"P1 /\\ P2"})," for the execution of ",(0,r.jsx)(t.code,{children:"e"})," and ",(0,r.jsx)(t.code,{children:"k"}),". We can also use the knowledge of ",(0,r.jsx)(t.code,{children:"P1"})," to reason about the execution of ",(0,r.jsx)(t.code,{children:"k"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"implies",children:(0,r.jsx)(t.code,{children:"Implies"})}),"\n",(0,r.jsxs)(t.p,{children:["Finally, the ",(0,r.jsx)(t.code,{children:"Implies"})," rule is used to simplify the expression of the predicate ",(0,r.jsx)(t.code,{children:"P"}),". We generally wrap our proofs in an ",(0,r.jsx)(t.code,{children:"Implies"})," call to have a clean predicate at the end. Otherwise, the final expression would contain a lot of clutter, like ",(0,r.jsx)(t.code,{children:"True /\\ ..."})," operations."]}),"\n",(0,r.jsx)(t.h2,{id:"-example",children:"\ud83d\udcdd Example"}),"\n",(0,r.jsx)(t.p,{children:"We now look at the specification and verification of the LLZK example we took at the beginning of this blog post series:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-mlir",children:"function.def @global_add(%a: !felt.type, %b: !felt.type) -> !felt.type {\n  %c = felt.add %a, %b\n  function.return %c : !felt.type\n}\n\nstruct.def @Adder {\n  struct.field @sum : !felt.type {llzk.pub}\n\n  function.def @compute(%a: !felt.type, %b: !felt.type) -> !struct.type<@Adder> {\n    %self = struct.new : !struct.type<@Adder>\n    %sum = function.call @global_add(%a, %b) : (!felt.type, !felt.type) -> (!felt.type)\n    struct.writef %self[@sum] = %sum : !struct.type<@Adder>, !felt.type\n    function.return %self : !struct.type<@Adder>\n  }\n\n  function.def @constrain(%self: !struct.type<@Adder>, %a: !felt.type, %b: !felt.type) {\n    %sum = struct.readf %self[@sum] : !struct.type<@Adder>, !felt.type\n    %c = function.call @global_add(%a, %b) : (!felt.type, !felt.type) -> (!felt.type)\n    constrain.eq %sum, %c : !felt.type\n    function.return\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"global_add",children:(0,r.jsx)(t.code,{children:"global_add"})}),"\n",(0,r.jsxs)(t.p,{children:["For the ",(0,r.jsx)(t.code,{children:"global_add"})," function, we write the following specification in the file ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/garden/blob/main/Garden/LLZK/verification.v",children:"Garden/LLZK/verification.v"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Lemma global_add_eq {p} `{Prime p} (x y : Felt.t) :\n    {{ global_add x y \ud83d\udd3d (x + y) mod p, True }}.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The generated Rocq translation of the ",(0,r.jsx)(t.code,{children:"global_add"})," function is:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Definition global_add {p} `{Prime p} (arg_fun_0 : Felt.t) (arg_fun_1 : Felt.t) : M.t Felt.t :=\n  let var_0 : Felt.t := BinOp.add arg_fun_0 arg_fun_1 in\n  M.Pure var_0.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We can now prove the specification with the application of the single rule ",(0,r.jsx)(t.code,{children:"Run.Pure"}),", as the code is purely functional:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Proof.\n  apply Run.Pure.\nQed.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Most of the auxiliary functions or the ",(0,r.jsx)(t.code,{children:"compute"})," functions will have a specification of a similar form, where the predicate is ",(0,r.jsx)(t.code,{children:"True"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"compute",children:(0,r.jsx)(t.code,{children:"compute"})}),"\n",(0,r.jsxs)(t.p,{children:["The translation of the ",(0,r.jsx)(t.code,{children:"compute"})," function is:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Definition compute {p} `{Prime p} (arg_fun_0 : Felt.t) (arg_fun_1 : Felt.t) : M.t Adder.t :=\n  let* var_self : Adder.t := M.CreateStruct in\n  let* var_0 : Felt.t := global_add arg_fun_0 arg_fun_1 in\n  let* _ : unit := M.FieldWrite var_self.(Adder.sum) var_0 in\n  M.Pure var_self.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Here, there are some side-effects composed with the ",(0,r.jsx)(t.code,{children:"M.Let"})," operator, noted ",(0,r.jsx)(t.code,{children:"let*"}),". We can apply the ",(0,r.jsx)(t.code,{children:"Run.Let"})," rule to prove the specification:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Definition spec {p} `{Prime p} (x y : Felt.t) : Adder.t :=\n  {|\n    Adder.sum := (x + y) mod p;\n  |}.\n\nLemma compute_eq {p} `{Prime p} (x y : Felt.t) :\n  {{ Adder.compute x y \ud83d\udd3d\n    spec x y, True\n  }}.\nProof.\n  unfold Adder.compute.\n  eapply Run.Implies. {\n    eapply Run.Let. {\n      eapply Run.CreateStruct with (value := Adder.Build_t _).\n    }\n    intros _.\n    eapply Run.Let. {\n      apply global_add_eq.\n    }\n    intros _.\n    eapply Run.Let. {\n      eapply Run.FieldWrite.\n    }\n    intros _.\n    apply Run.Pure.\n  }\n  easy.\nQed.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The specification states that we are creating a structure with the addition modulo ",(0,r.jsx)(t.code,{children:"p"})," of the two input parameters. We make the proof with a succession of ",(0,r.jsx)(t.code,{children:"Run.Let"})," rules. For the line:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"let* var_self : Adder.t := M.CreateStruct in\n"})}),"\n",(0,r.jsxs)(t.p,{children:["we apply the ",(0,r.jsx)(t.code,{children:"Run.CreateStruct"})," rule, with an existential variable ",(0,r.jsx)(t.code,{children:"_"})," for the field of the structure. This existential variable is later unified with the right value when we evaluate the line:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"let* _ : unit := M.FieldWrite var_self.(Adder.sum) var_0 in\n"})}),"\n",(0,r.jsxs)(t.p,{children:["which forces its value to be ",(0,r.jsx)(t.code,{children:"var_0"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"The last tactic:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"easy.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["at the end of the proof is there to aggregate the predicate ",(0,r.jsx)(t.code,{children:"True /\\ ... /\\ True"})," that we obtain from the ",(0,r.jsx)(t.code,{children:"Run.Let"})," rules into a single ",(0,r.jsx)(t.code,{children:"True"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"constrain",children:(0,r.jsx)(t.code,{children:"constrain"})}),"\n",(0,r.jsxs)(t.p,{children:["The translation of the ",(0,r.jsx)(t.code,{children:"constrain"})," function is:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Definition constrain {p} `{Prime p}\n    (arg_fun_0 : Adder.t) (arg_fun_1 : Felt.t) (arg_fun_2 : Felt.t) :\n    M.t unit :=\n  let var_0 : Felt.t := arg_fun_0.(Adder.sum) in\n  let* var_1 : Felt.t := global_add arg_fun_1 arg_fun_2 in\n  let* _ : unit := M.AssertEqual var_0 var_1 in\n  M.Pure tt.\n"})}),"\n",(0,r.jsx)(t.p,{children:"We specify it as follows:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Lemma contrain_implies {p} `{Prime p}\n    (self : Adder.t)\n    (x y : Felt.t) :\n  let self := map_mod self in\n  {{ Adder.constrain self x y \ud83d\udd3d\n    tt,\n    self = spec x y\n  }}.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Here, we always return the unit value ",(0,r.jsx)(t.code,{children:"tt"}),", and we assert that the ",(0,r.jsx)(t.code,{children:"self"})," parameter must be equal to the expected structure containing the sum of the two input parameters. Note that we use the ",(0,r.jsx)(t.code,{children:"map_mod"})," function to make sure to apply the modulo operation to the fields of the structure, as otherwise they could be arbitrary ",(0,r.jsx)(t.code,{children:"Z"})," values. This is a way to express that we consider equality to be modulo ",(0,r.jsx)(t.code,{children:"p"}),"."]}),"\n",(0,r.jsxs)(t.admonition,{title:"No under-constraints",type:"note",children:[(0,r.jsxs)(t.p,{children:["This specification states that there are no under-constraints in the ",(0,r.jsx)(t.code,{children:"constrain"})," function. Indeed, the ",(0,r.jsx)(t.code,{children:"self"})," parameter is only allowed to be equal to a single value ",(0,r.jsx)(t.code,{children:"spec x y"}),". However, we do not show that the circuit is not over-constrained: we show that all solutions must be equal to ",(0,r.jsx)(t.code,{children:"spec x y"}),", but there might be no solutions, and this statement would hold."]}),(0,r.jsx)(t.p,{children:"The no over-constraints property is generally considered less critical than the no under-constraints property, and easier to formally verify: it amounts to verifying that the expected output validates all the assertions of the circuit."})]}),"\n",(0,r.jsxs)(t.p,{children:["For the proof, we again apply the ",(0,r.jsx)(t.code,{children:"Run.t"})," rules in a straightforward way:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Proof.\n  unfold Adder.constrain.\n  eapply Run.Implies. {\n    eapply Run.Let. {\n      apply global_add_eq.\n    }\n    intros _.\n    eapply Run.Let. {\n      apply Run.AssertEqual.\n    }\n    intros _.\n    apply Run.Pure.\n  }\n  unfold spec.\n  hauto lq: on.\nQed.\n"})}),"\n",(0,r.jsx)(t.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,r.jsx)(t.p,{children:"We have seen how to formally specify and verify the safety of an LLZK circuit in Rocq. There are a few things that need to be improved now:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Adding more automation to the proofs: as you can see, they are rather verbose, even if LLM auto-complete catches repetitive patterns."}),"\n",(0,r.jsxs)(t.li,{children:["Adding more support for the LLZK language, translating bigger examples (in the thousands of lines, the one above is 500 lines long). Indeed, other ",(0,r.jsx)(t.code,{children:".llzk"})," files use features that we do not support yet, like arrays whose size is dynamic with respect to a ",(0,r.jsx)(t.code,{children:"for"})," loop counter. Our plan is to add dynamic typing rules capabilities in a refined version of our reasoning rules."]}),"\n"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["You want to secure your code? Contact us! \u21e8 ",(0,r.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})]}),"\n"]}),"\n",(0,r.jsx)(t.admonition,{title:"For more",type:"success",children:(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.em,{children:["Follow us on ",(0,r.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,r.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions!"]})})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},69653:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/green_forest-67a5dfcc71e922dadfd45e6929435a0d.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(96540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);