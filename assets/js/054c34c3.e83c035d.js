"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[2274],{70195:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=n(74848),a=n(28453);const o={title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 2",tags:["Noir","smart contract","circuits"],authors:[]},i=void 0,r={permalink:"/blog/2024/11/15/tool-for-noir-2",source:"@site/blog/2024-11-15-tool-for-noir-2.md",title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 2",description:"In this blog post, we continue our presentation about our formal verification tool for \u25fc\ufe0f&nbsp;Noir programs coq-of-noir. Noir is a Rust-like language to write programs designed to run efficiently in zero-knowledge environments. It has a growing popularity and a focus on providing optimized libraries for common needs, such as a base64 library using \ud83e\udde0&nbsp;field arithmetic that we use in this series of blog posts.",date:"2024-11-15T00:00:00.000Z",formattedDate:"November 15, 2024",tags:[{label:"Noir",permalink:"/blog/tags/noir"},{label:"smart contract",permalink:"/blog/tags/smart-contract"},{label:"circuits",permalink:"/blog/tags/circuits"}],readingTime:8.895,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 2",tags:["Noir","smart contract","circuits"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd84 How does formal verification of smart contracts work?",permalink:"/blog/2024/12/20/what-is-formal-verification-of-smart-contracts"},nextItem:{title:"\ud83e\udd80 Example of verification for the Move's checker of Sui",permalink:"/blog/2024/11/14/sui-move-checker-abstract-stack"}},l={authorsImageUrls:[]},c=[{value:"\u2699\ufe0f Semantic rules",id:"\ufe0f-semantic-rules",level:2},{value:"\ud83d\udc18 Memory handling",id:"-memory-handling",level:2},{value:"\u27b0 Loops",id:"-loops",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function d(e){const t={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In this blog post, we continue our presentation about our formal verification tool for ",(0,s.jsx)(t.a,{href:"https://noir-lang.org/",children:"\u25fc\ufe0f\xa0Noir"})," programs ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-noir",children:"coq-of-noir"}),". Noir is a Rust-like language to write programs designed to run efficiently in zero-knowledge environments. It has a growing popularity and a focus on providing optimized libraries for common needs, such as a ",(0,s.jsx)(t.a,{href:"https://github.com/noir-lang/noir_base64",children:"base64"})," library using \ud83e\udde0\xa0field arithmetic that we use in this series of blog posts."]}),"\n",(0,s.jsx)(t.p,{children:"Here we present the details of our semantic rules to show that a Noir program has an expected behavior for any possible parameters. We focus, in particular, on our memory-handling approach and the definition of loops."}),"\n",(0,s.jsxs)(t.admonition,{title:"Require the strongest security!",type:"success",children:[(0,s.jsxs)(t.p,{children:["To ensure your code is fully secure today, contact us at\xa0",(0,s.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"}),"!\xa0\ud83d\ude80"]}),(0,s.jsxs)(t.p,{children:["Formal verification goes further than traditional audits to make 100% sure you cannot lose your funds, thanks to ",(0,s.jsx)(t.strong,{children:"mathematical reasoning on the code"}),". It can be integrated into your CI pipeline to check that every commit is fully correct ",(0,s.jsx)(t.strong,{children:"without doing a whole audit again"}),"."]}),(0,s.jsxs)(t.p,{children:["We make bugs such as the ",(0,s.jsx)(t.a,{href:"https://www.gemini.com/fr-fr/cryptopedia/the-dao-hack-makerdao",children:"DAO hack"})," ($60 million stolen) virtually ",(0,s.jsx)(t.strong,{children:"impossible to happen again"}),"."]})]}),"\n",(0,s.jsx)("figure",{children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Noir",src:n(39227).A+"",width:"1792",height:"1024"})})}),"\n",(0,s.jsx)(t.h2,{id:"\ufe0f-semantic-rules",children:"\u2699\ufe0f Semantic rules"}),"\n",(0,s.jsxs)(t.p,{children:["In the previous blog post ",(0,s.jsx)(t.a,{href:"/blog/2024/11/01/tool-for-noir-1",children:"\u25fc\ufe0f A formal verification tool for Noir \u2013 1"})," we presented our general translation from the Noir syntax to ",(0,s.jsx)(t.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"}),", as well as the free monad we use to represent side-effects such as mutations. We now need to define semantic rules to be able to say that a particular translated Noir program evaluates to a certain value."]}),"\n",(0,s.jsx)(t.p,{children:"For expressions that do not have side effects we rely on the usual reduction rules of Coq. This is really convenient as we can then reuse the existing Coq tactics and automation to reason about pure expressions."}),"\n",(0,s.jsx)(t.p,{children:"For side-effects like mutations or function calls, which we also consider as side-effects as there might be infinite recursion, we use a big-step semantics with the following predicate:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"{{ p, state_in | e \u21d3 output | state_out }}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["It says that for a certain prime number\xa0",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"p"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"p"})]})})]})," which is the size of the arithmetic field, for an initial state\xa0",(0,s.jsx)(t.code,{children:"state_in"}),", the expression\xa0",(0,s.jsx)(t.code,{children:"e"})," evaluates to the output\xa0",(0,s.jsx)(t.code,{children:"output"})," and the final state\xa0",(0,s.jsx)(t.code,{children:"state_out"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["We define this rule with a Coq ",(0,s.jsx)(t.code,{children:"Inductive"})," with one case per case in our free monad for effects. This is similar to the work we have done for Rust with ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),". Here are the relevant rules."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Pure"}),"\nExpressions without side effects evaluate to their value and do not change the state. Note that in Coq, we do not distinguish between expressions and values, as all values are equal modulo evaluation rules, so we can directly use the expression as the output.","\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"| Pure :\n    {{ p, state_out | LowM.Pure output \u21d3 output | state_out }}\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"GetFieldPrime"}),"\nTo obtain the current size of the field\xa0",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"p"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"p"})]})})]})," we use the ",(0,s.jsx)(t.code,{children:"GetFieldPrime"})," primitive. This is a side-effect as it depends on the current settings to compile the Noir program in circuits. We use this operation as an internal operation to define the arithmetic operations in the field by computing modulo\xa0",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"p"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"p"})]})})]}),".","\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"| CallPrimitiveGetFieldPrime\n    (k : Z -> M.t)\n    (state_in : State) :\n  {{ p, state_in | k p \u21d3 output | state_out }} ->\n  {{ p, state_in |\n    LowM.CallPrimitive Primitive.GetFieldPrime k \u21d3 output\n  | state_out }}\n"})}),"\n","We use a semantics by continuation with a continuation\xa0",(0,s.jsx)(t.code,{children:"k"})," for most of the operations of the monad. Instead of directly returning some result, we pass it to the continuation and evaluate it. In our experience, this simplifies the reasoning on code instead of having to use another monadic operation to pass this value."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"CallClosure"}),"\nWe define a closure as a function from a list of values to some monadic expression. In our translation, terms are totally untyped; in particular we do not enforce any arity for the functions. In case a wrong number of arguments is passed to a function, we will have a runtime error. This is a trade-off to keep the translation simple and to avoid having to define a type system for Noir.","\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"| CallClosure\n    (f : list Value.t -> M.t) (args : list Value.t)\n    (k : Result.t -> M.t)\n    (output_inter : Result.t)\n    (state_in state_inter : State) :\n  let closure := Value.Closure (existS (_, _) f) in\n  {{ p, state_in | f args \u21d3 output_inter | state_inter }} ->\n  {{ p, state_inter | k output_inter \u21d3 output | state_out }} ->\n  {{ p, state_in | LowM.CallClosure closure args k \u21d3 output | state_out }}\n"})}),"\n","To call a function, we first evaluate its body on the arguments and then the continuation\xa0",(0,s.jsx)(t.code,{children:"k"}),". If the result is some ",(0,s.jsx)(t.code,{children:"output"})," and ",(0,s.jsx)(t.code,{children:"state_out"}),", we can say that the whole expression evaluates to ",(0,s.jsx)(t.code,{children:"output"})," and ",(0,s.jsx)(t.code,{children:"state_out"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Let"}),"\nThe ",(0,s.jsx)(t.code,{children:"Let"})," primitive is the monadic bind. It allows to sequentially compose the execution of two expressions. We first evaluate the first expression, then the second one with the result of the first one.","\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"| Let\n    (e : M.t)\n    (k : Result.t -> M.t)\n    (output_inter : Result.t)\n    (state_in state_inter : State) :\n  {{ p, state_in | e \u21d3 output_inter | state_inter }} ->\n  {{ p, state_inter | k output_inter \u21d3 output | state_out }} ->\n  {{ p, state_in | LowM.Let e k \u21d3 output | state_out }}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"-memory-handling",children:"\ud83d\udc18 Memory handling"}),"\n",(0,s.jsxs)(t.p,{children:["In Noir, you can make a new variable mutable with the keyword ",(0,s.jsx)(t.code,{children:"let mut"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"let mut result: [u8; InputElements] = [0; InputElements];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then you can assign a new value to this variable or its content with the ",(0,s.jsx)(t.code,{children:"="})," operator:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"result[i] = Base64Decoder.get(input_byte as Field);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["There is basic pointer manipulation with the ",(0,s.jsx)(t.code,{children:"&"})," operator to get a reference to a variable and the ",(0,s.jsx)(t.code,{children:"*"})," operator to dereference a pointer. You can even pass a mutable reference to a function to modify the value of a variable. There is no deallocation of memory, which entirely removes the need for a garbage collector or deallocation strategy. This is because Noir programs are supposed to be very short-lived."]}),"\n",(0,s.jsxs)(t.p,{children:["To handle all expressions in a uniform way, we consider that each Noir expression is an address to its content. For most (intermediate) values, which are not mutable, the address is the value itself. For mutable values, we use a fresh address for each ",(0,s.jsx)(t.code,{children:"let mut"})," assignment."]}),"\n",(0,s.jsx)(t.admonition,{title:"Thanks",type:"info",children:(0,s.jsxs)(t.p,{children:["As ",(0,s.jsx)(t.a,{href:"https://github.com/features/copilot",children:"GitHub Copilot"})," correctly suggests me, this is similar to the approach we have taken for Rust in ",(0,s.jsx)(t.code,{children:"coq-of-rust"}),". Thanks for following what we are doing!\xa0\ud83d\ude4f"]})}),"\n",(0,s.jsxs)(t.p,{children:["To simplify the proofs, we let the user input a memory model of its choice. The only constraint is to provide memory operations for ",(0,s.jsx)(t.code,{children:"read"}),", ",(0,s.jsx)(t.code,{children:"write"}),", and ",(0,s.jsx)(t.code,{children:"alloc"}),", and to make sure that these operations are consistent. Once it is done, here are the rules for the memory handling of mutable references:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"StateAlloc"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"| CallPrimitiveStateAlloc\n    (value : Value.t)\n    (address : Address)\n    (k : Value.t -> M.t)\n    (state_in state_in' : State) :\n  let pointer := Pointer.Mutable (Pointer.Mutable.Make address []) in\n  State.read address state_in = None ->\n  State.alloc_write address state_in value = Some state_in' ->\n  {{ p, state_in' | k (Value.Pointer pointer) \u21d3 output | state_out }} ->\n  {{ p, state_in | LowM.CallPrimitive (Primitive.StateAlloc value) k \u21d3 output | state_out }}\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"StateRead"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"| CallPrimitiveStateRead\n    (address : Address)\n    (value : Value.t)\n    (k : Value.t -> M.t)\n    (state_in : State) :\n  State.read address state_in = Some value ->\n  {{ p, state_in | k value \u21d3 output | state_out }} ->\n  {{ p, state_in | LowM.CallPrimitive (Primitive.StateRead address) k \u21d3 output | state_out }}\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"StateWrite"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"| CallPrimitiveStateWrite\n    (value : Value.t)\n    (address : Address)\n    (k : unit -> M.t)\n    (state_in state_in' : State) :\n  State.alloc_write address state_in value = Some state_in' ->\n  {{ p, state_in' | k tt \u21d3 output | state_out }} ->\n  {{ p, state_in |\n    LowM.CallPrimitive (Primitive.StateWrite address value) k \u21d3 output\n  | state_out }}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"When using these rules to show that a certain Noir program evaluates to an expression, one has to make the right choice for the address used to allocate the value. This choice is arbitrary but can make the proof more or less complex later. The read and write operations are deterministic."}),"\n",(0,s.jsx)(t.h2,{id:"-loops",children:"\u27b0 Loops"}),"\n",(0,s.jsxs)(t.p,{children:["There is only one kind of loop in Noir, bounded\xa0",(0,s.jsx)(t.code,{children:"for"})," loops:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"for i in 0..InputElements {\n    let input_byte = input[i];\n    result[i] = Base64Decoder.get(input_byte as Field);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The index\xa0",(0,s.jsx)(t.code,{children:"i"})," evolves in between statically known bounds. As such, these bounds always terminate, which is a requirement for formal verification to proceed! As a result, we do not need to introduce a dedicated monadic primitive for the loops and can define them with a recursive function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Fixpoint for_nat (end_ : Z) (fuel : nat) (body : Z -> M.t) {struct fuel} : M.t :=\n  match fuel with\n  | O => pure (Value.Tuple [])\n  | S fuel' =>\n    let* _ := body (end_ - Z.of_nat fuel) in\n    for_nat end_ fuel' body\n  end.\n\nDefinition for_Z (start end_ : Z) (body : Z -> M.t) : M.t :=\n  for_nat end_ (Z.to_nat (end_ - start)) body.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that we do not handle ",(0,s.jsx)(t.code,{children:"break"})," or ",(0,s.jsx)(t.code,{children:"continue"})," yet but propagate assert failures with ",(0,s.jsx)(t.code,{children:"let*"}),". We ",(0,s.jsx)(t.em,{children:"prove"})," the following reasoning rule for loops:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Lemma For {State Address : Set} `{State.Trait State Address}\n    (p : Z) (state_in : State)\n    (integer_kind : IntegerKind.t) (start : Z) (len : nat) (body : Value.t -> M.t)\n    {Accumulator : Set}\n    (inject : State -> Accumulator -> State)\n    (accumulator_in : Accumulator)\n    (body_expression : Z -> MS! Accumulator unit)\n    (H_body : forall (accumulator_in : Accumulator) (i : Z),\n      let output_accumulator_out := body_expression i accumulator_in in\n      {{ p, inject state_in accumulator_in |\n        body (M.alloc (Value.Integer integer_kind i)) \u21d3\n        Panic.to_result (fst output_accumulator_out)\n      | inject state_in (snd output_accumulator_out) }}\n    ) :\n  let output_accumulator_out :=\n    foldS!\n      tt\n      (List.map (fun offset => start + Z.of_nat offset) (List.seq 0 len))\n      (fun (_ : unit) => body_expression)\n      accumulator_in in\n  {{ p, inject state_in accumulator_in |\n    M.for_\n      (Value.Integer integer_kind start)\n      (Value.Integer integer_kind (start + Z.of_nat len))\n      body \u21d3\n    Panic.to_result (fst output_accumulator_out)\n  | inject state_in (snd output_accumulator_out) }}.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["It is a little bit involved but basically says that if the body of the loop evaluates to an expression for each possible iteration, then the whole loop evaluates to the recursive function ",(0,s.jsx)(t.code,{children:"foldS!"})," using the modified memory as an accumulator."]}),"\n",(0,s.jsx)(t.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"We have shown how we define the semantic rules for the Noir language in Coq, for the general monadic primitives, memory, and loops."}),"\n",(0,s.jsxs)(t.p,{children:["In the next blog post, we will apply these reasoning principles to give a semantics to the ",(0,s.jsx)(t.code,{children:"base64"})," library of Noir."]}),"\n",(0,s.jsx)(t.admonition,{title:"For more",type:"success",children:(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["Follow us on ",(0,s.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,s.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions or requests!"]})})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},39227:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/noir-568e4d7ad7afc47d7fe0ace944d49307.webp"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(96540);const a={},o=s.createContext(a);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);