"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8121],{5639:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var r=n(74848),o=n(28453),i=(n(96540),n(13468));n(55975);i.t1.register(i.No,i.FN,i.kc,i.UA,i.m_,i.s$);const s={id:"revm-project",title:"Revm Project"},a=void 0,l={id:"tools/coq-of-rust/revm-project",title:"Revm Project",description:"\x3c!-- <ProgressChart data={[",source:"@site/docs/tools/coq-of-rust/revm-project.md",sourceDirName:"tools/coq-of-rust",slug:"/tools/coq-of-rust/revm-project",permalink:"/docs/tools/coq-of-rust/revm-project",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"revm-project",title:"Revm Project"},sidebar:"sidebar",previous:{title:"\ud83e\udd80 coq-of-rust",permalink:"/docs/tools/coq-of-rust/introduction"},next:{title:"Links",permalink:"/docs/tools/coq-of-rust/links"}},c={},h=[{value:"Status",id:"status",level:2},{value:"What we have",id:"what-we-have",level:2},{value:"Example",id:"example",level:2}];function p(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Our goal is to formally specify the implementation of ",(0,r.jsx)(t.a,{href:"https://github.com/bluealloy/revm",children:"Revm"}),", a Rust implementation of the EVM (the Ethereum Virtual Machine)."]}),"\n",(0,r.jsx)(t.p,{children:"This is the critical first step to enable:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The verification of full backward compatibility between Revm releases, lowering the rist of incorrect block handling \u2705."}),"\n",(0,r.jsx)(t.li,{children:"The verification of full absence of runtime errors, so that no blocks can halt the node \u2705."}),"\n",(0,r.jsxs)(t.li,{children:["The verification of full compatibility with ",(0,r.jsx)(t.a,{href:"https://github.com/ethereum/go-ethereum",children:"Geth"}),", the most popular Ethereum client \u2705."]}),"\n",(0,r.jsxs)(t.li,{children:["The verification of full correctness of the RISC-V binary of Revm, a necessary step to make the zkVMs running Revm to be ready for the L1 \u2705. See more details on ",(0,r.jsx)(t.a,{href:"https://ethproofs.org/",children:"Ethproofs.org"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["If you want to discuss about this project, contact us at\xa0",(0,r.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"}),"!"]}),"\n",(0,r.jsx)(t.admonition,{title:"Ethereum Foundation",type:"note",children:(0,r.jsxs)(t.p,{children:["This project is funded by the ",(0,r.jsx)(t.a,{href:"https://ethereum.foundation/",children:"\ud83e\ude81\xa0Ethereum Foundation"}),", to whom we are grateful."]})}),"\n",(0,r.jsx)(t.admonition,{title:"The source code",type:"tip",children:(0,r.jsxs)(t.p,{children:["The source code is on ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/revm",children:"github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/revm"})]})}),"\n",(0,r.jsx)(t.h2,{id:"status",children:"Status"}),"\n",(0,r.jsxs)(t.p,{children:["This project is under development. We represent the Rust code in the formal language ",(0,r.jsx)(t.a,{href:"https://rocq-prover.org/",children:"Rocq"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"The translation goes through three steps:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Make an automated translation of the Rust source code of Revm to Rocq using ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"}),". The generated code is a direct copy of the original Rust code, with all the macros and implicit operations expanded. It behaves as the original Rust code but it is about ten times more verbose."]}),"\n",(0,r.jsx)(t.li,{children:'Make a refinement of the translated code that we call a "link", which is equivalent to the original code but with type information and name resolution added back. There information are lost during the translation, as it is hard to come up with a general way to keep them.'}),"\n",(0,r.jsx)(t.li,{children:'Make a second refinement to a purely functional or monadic code, that we call a "simulation". This is the step in which we handle the Rust memory, by representing it as a state monad instead of a pointer-based memory.'}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"what-we-have",children:"What we have"}),"\n",(0,r.jsx)(t.p,{children:"The current completion of the three translation steps is as follows:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Rust to Rocq with ",(0,r.jsx)(t.code,{children:"coq-of-rust"}),": ",(0,r.jsx)(t.strong,{children:"100%"})]}),"\n",(0,r.jsxs)(t.li,{children:["Link: ",(0,r.jsx)(t.strong,{children:"95%"})]}),"\n",(0,r.jsxs)(t.li,{children:["Simulation: ",(0,r.jsx)(t.strong,{children:"2.5%"})]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["We continue working on the ",(0,r.jsx)(t.em,{children:"simulation"})," step, where we need to improve our method to make it more scalable."]}),"\n",(0,r.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(t.p,{children:["Let us look at the three translation steps for the ",(0,r.jsx)(t.code,{children:"ADD"})," instruction, for which the translation is complete."]}),"\n",(0,r.jsxs)(t.ol,{start:"0",children:["\n",(0,r.jsxs)(t.li,{children:["The original Rust code for the addition in ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/instructions/arithmetic.rs",children:"revm/revm_interpreter/instructions/arithmetic.rs"})," is:","\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub fn add<WIRE: InterpreterTypes, H: Host + ?Sized>(\n    interpreter: &mut Interpreter<WIRE>,\n    _host: &mut H,\n) {\n    gas!(interpreter, gas::VERYLOW);\n    popn_top!([op1], op2, interpreter);\n    *op2 = op1.wrapping_add(*op2);\n}\n"})}),"\n","Note the use of the macros ",(0,r.jsx)(t.code,{children:"gas!"})," and ",(0,r.jsx)(t.code,{children:"popn_top!"})," which generate a bit more code than it seems."]}),"\n",(0,r.jsxs)(t.li,{children:["The generated translation from ",(0,r.jsx)(t.code,{children:"coq-of-rust"})," is in ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/instructions/arithmetic.v",children:"arithmetic.v"})," and is a 334 lines long code, with the following beginning:","\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",metastring:"showLineNumbers",children:'Definition add (\u03b5 : list Value.t) (\u03c4 : list Ty.t) (\u03b1 : list Value.t) : M :=\n  match \u03b5, \u03c4, \u03b1 with\n  | [], [ WIRE; H ], [ interpreter; _host ] =>\n    ltac:(M.monadic\n      (let interpreter :=\n        M.alloc (|\n          Ty.apply\n            (Ty.path "&mut")\n            []\n            [ Ty.apply (Ty.path "revm_interpreter::interpreter::Interpreter") [] [ WIRE ] ],\n          interpreter\n        |) in\n      let _host := M.alloc (| Ty.apply (Ty.path "&mut") [] [ H ], _host |) in\n      M.catch_return (Ty.tuple []) (|\n        ltac:(M.monadic\n          (M.read (|\n            let~ _ : Ty.tuple [] :=\n              M.match_operator (|\n                Ty.tuple [],\n                M.alloc (| Ty.tuple [], Value.Tuple [] |),\n                [\n                  fun \u03b3 =>\n                    ltac:(M.monadic\n                      (let \u03b3 :=\n                        M.use\n                          (M.alloc (|\n                            Ty.path "bool",\n                            UnOp.not (|\n                              M.call_closure (|\n                                Ty.path "bool",\n                                M.get_associated_function (|\n                                  Ty.path "revm_interpreter::gas::Gas",\n                                  "record_cost",\n                                  [],\n                                  []\n                                |),\n                                [\n                                  M.borrow (|\n                                    Pointer.Kind.MutRef,\n                                    M.deref (|\n                                      M.call_closure (|\n                                        Ty.apply\n                                          (Ty.path "&mut")\n                                          []\n                                          [ Ty.path "revm_interpreter::gas::Gas" ],\n                                        M.get_trait_method (|\n                                          "revm_interpreter::interpreter_types::LoopControl",\n                                          Ty.associated_in_trait\n                                            "revm_interpreter::interpreter_types::InterpreterTypes"\n                                            []\n                                            []\n                                            WIRE\n                                            "Control",\n                                          [],\n                                          [],\n                                          "gas",\n                                          [],\n                                          []\n                                        |),\n'})}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["The link is in ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/instructions/links/arithmetic.v",children:"arithmetic.v"}),". It is a proof that the generated code above can be well-typed, with existing trait instances:","\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Instance run_add\n    {WIRE H : Set} `{Link WIRE} `{Link H}\n    {WIRE_types : InterpreterTypes.Types.t} `{InterpreterTypes.Types.AreLinks WIRE_types}\n    {H_types : Host.Types.t} `{Host.Types.AreLinks H_types}\n    (run_InterpreterTypes_for_WIRE : InterpreterTypes.Run WIRE WIRE_types)\n    (interpreter : Ref.t Pointer.Kind.MutRef (Interpreter.t WIRE WIRE_types))\n    (_host : Ref.t Pointer.Kind.MutRef H) :\n  Run.Trait\n    instructions.arithmetic.add [] [ \u03a6 WIRE; \u03a6 H ] [ \u03c6 interpreter; \u03c6 _host ]\n    unit.\nProof.\n  constructor.\n  destruct run_InterpreterTypes_for_WIRE.\n  destruct run_LoopControl_for_Control.\n  destruct run_StackTrait_for_Stack.\n  run_symbolic.\nDefined.\n"})}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Finally, the simulation is in ",(0,r.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/revm/revm_interpreter/instructions/simulate/arithmetic.v",children:"arithmetic.v"})," and is:","\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-coq",children:"Lemma add_eq\n    {WIRE H : Set} `{Link WIRE} `{Link H}\n    {WIRE_types : InterpreterTypes.Types.t} `{InterpreterTypes.Types.AreLinks WIRE_types}\n    {H_types : Host.Types.t} `{Host.Types.AreLinks H_types}\n    (run_InterpreterTypes_for_WIRE : InterpreterTypes.Run WIRE WIRE_types)\n    (IInterpreterTypes : InterpreterTypes.C WIRE_types)\n    (InterpreterTypesEq :\n      InterpreterTypes.Eq.t WIRE WIRE_types run_InterpreterTypes_for_WIRE IInterpreterTypes)\n    (interpreter : Interpreter.t WIRE WIRE_types)\n    (_host : H) :\n  let ref_interpreter := make_ref 0 in\n  let ref_host := make_ref 1 in\n  {{\n    SimulateM.eval_f (Stack := [_; _])\n      (run_add run_InterpreterTypes_for_WIRE ref_interpreter ref_host)\n      (interpreter, (_host, tt)) \ud83c\udf32\n    (\n      Output.Success tt,\n      (\n        gas_macro interpreter constants.VERYLOW (fun interpreter =>\n        popn_top_macro interpreter {| Integer.value := 1 |} (fun arr top interpreter =>\n          let '{| ArrayPair.x := op1 |} := arr.(array.value) in\n          let op2 := top.(RefStub.projection) interpreter.(Interpreter.stack) in\n          let stack :=\n            top.(RefStub.injection)\n              interpreter.(Interpreter.stack) (Impl_Uint.wrapping_add op1 op2) in\n          interpreter\n            <| Interpreter.stack := stack |>\n        )),\n        (_host, tt)\n      )\n    )\n  }}.\n"})}),"\n","Note that this is a lemma presenting the definition of the simulation and a statement stating that it is equivalent to the original Rust code."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);