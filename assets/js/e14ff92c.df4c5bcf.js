"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[4289],{32817:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var s=t(74848),a=t(28453);const i={title:"\ud83e\udd77 Verification of the completeness of an OpenVM chip",tags:["zkVM","zero-knowledge","completeness"],authors:[]},r=void 0,o={permalink:"/blog/2025/09/02/verification-completeness-open-vm-chip",source:"@site/blog/2025-09-02-verification-completeness-open-vm-chip.md",title:"\ud83e\udd77 Verification of the completeness of an OpenVM chip",description:"In our previous blog post \ud83e\udd77 Formal verification of an OpenVM chip, we have seen how to verify the determinism of the branch_eq chip of OpenVM. Now, we will see how to verify its completeness, meaning that it always accepts a valid witness for any possible input.",date:"2025-09-02T00:00:00.000Z",formattedDate:"September 2, 2025",tags:[{label:"zkVM",permalink:"/blog/tags/zk-vm"},{label:"zero-knowledge",permalink:"/blog/tags/zero-knowledge"},{label:"completeness",permalink:"/blog/tags/completeness"}],readingTime:7.405,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd77 Verification of the completeness of an OpenVM chip",tags:["zkVM","zero-knowledge","completeness"],authors:[]},unlisted:!1,nextItem:{title:"\ud83e\udd77 Pretty-printing of Rust ZK constraints",permalink:"/blog/2025/08/26/pretty-printing-rust-constraints"}},c={authorsImageUrls:[]},l=[{value:"\ud83c\udf84 Completeness for circuits",id:"-completeness-for-circuits",level:2},{value:"\ud83d\udee1\ufe0f For <code>branch_eq</code>",id:"\ufe0f-for-branch_eq",level:2},{value:"\ud83d\udd0d Proof",id:"-proof",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",mspace:"mspace",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In our previous blog post ",(0,s.jsx)(n.a,{href:"/blog/2025/08/13/verification-of-openvm-branch-eq",children:"\ud83e\udd77 Formal verification of an OpenVM chip"}),", we have seen how to verify the determinism of the ",(0,s.jsx)(n.code,{children:"branch_eq"})," chip of OpenVM. Now, we will see how to verify its completeness, meaning that it always accepts a valid witness for any possible input."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["This work was funded by a grant from the ",(0,s.jsx)(n.a,{href:"https://ethereum.foundation/",children:"Ethereum Foundation"})," to whom we are thankful, as part of the ",(0,s.jsx)(n.a,{href:"https://verified-zkevm.org/",children:"zkEVM Formal Verification Project"}),', to "accelerate the application of formal verification methods to zkEVMs".']})}),"\n",(0,s.jsx)("figure",{children:(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Green forest",src:t(22371).A+"",width:"1024",height:"1024"})})}),"\n",(0,s.jsx)(n.h2,{id:"-completeness-for-circuits",children:"\ud83c\udf84 Completeness for circuits"}),"\n",(0,s.jsx)(n.p,{children:"The completeness property for a circuit says that for any given set of well-formed input variables, there exists a set of output variables that satisfies the circuit."}),"\n",(0,s.jsx)(n.admonition,{title:"Security implications",type:"note",children:(0,s.jsx)(n.p,{children:"It means that the circuit, generally representing a VM, will never reach a state where it is blocked, which would be a denial of service attack."})}),"\n",(0,s.jsxs)(n.p,{children:["To state this property with quantifiers, let us consider a circuit ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{mathvariant:"script",children:"C"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathcal{C}"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(n.span,{className:"mord mathcal",style:{marginRight:"0.05834em"},children:"C"})]})})]})," parametrized by some variables that we group into the categories of input, output, and oracle variables (values given by the prover and verified by the circuit to speed up some computations). We say that the circuit is complete if:"]}),"\n",(0,s.jsx)(n.span,{className:"katex-display",children:(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{mathvariant:"normal",children:"\u2200"}),(0,s.jsx)(n.mtext,{children:"\xa0input"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mspace,{linebreak:"newline"}),(0,s.jsx)(n.mi,{mathvariant:"normal",children:"\u2203"}),(0,s.jsx)(n.mtext,{children:"\xa0output"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mtext,{children:"oracle"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mspace,{linebreak:"newline"}),(0,s.jsx)(n.mi,{mathvariant:"script",children:"C"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mtext,{children:"input"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mtext,{children:"output"}),(0,s.jsx)(n.mo,{separator:"true",children:","}),(0,s.jsx)(n.mtext,{children:"oracle"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"}),(0,s.jsx)(n.mtext,{children:"\xa0holds"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"  \\forall\\ \\text{input},\\\\\n  \\exists\\ \\text{output}, \\text{oracle},\\\\\n  \\mathcal{C}(\\text{input}, \\text{output}, \\text{oracle}) \\text{ holds}"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(n.span,{className:"mord",children:"\u2200"}),(0,s.jsx)(n.span,{className:"mspace",children:"\xa0"}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"input"})}),(0,s.jsx)(n.span,{className:"mpunct",children:","})]}),(0,s.jsx)(n.span,{className:"mspace newline"}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(n.span,{className:"mord",children:"\u2203"}),(0,s.jsx)(n.span,{className:"mspace",children:"\xa0"}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"output"})}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"oracle"})}),(0,s.jsx)(n.span,{className:"mpunct",children:","})]}),(0,s.jsx)(n.span,{className:"mspace newline"}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathcal",style:{marginRight:"0.05834em"},children:"C"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"input"})}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"output"})}),(0,s.jsx)(n.span,{className:"mpunct",children:","}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"oracle"})}),(0,s.jsx)(n.span,{className:"mclose",children:")"}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"\xa0holds"})})]})]})]})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Now, in our ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/garden",children:"Garden"})," framework for circuits' formal verification, how do we define reasoning rules to show completeness? \ud83e\udd14"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In practice, we have an explicit function representing the output variables that we want, as circuits are supposed to be deterministic for security reasons. So showing completeness amounts to verifying that for the expected output of the circuit, all constraints are satisfied."}),"\n",(0,s.jsx)(n.p,{children:"We define this predicate as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"{{ e \u2705 value }}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"e"})," is of type ",(0,s.jsx)(n.code,{children:"M.t A"})," and ",(0,s.jsx)(n.code,{children:"value"})," is of type ",(0,s.jsx)(n.code,{children:"A"}),". It says that a circuit ",(0,s.jsx)(n.code,{children:"e"})," in closed form, so applied to all its input and output variables, will evaluate to ",(0,s.jsx)(n.code,{children:"value"})," satisfying all the constraints."]}),"\n",(0,s.jsxs)(n.p,{children:["Generally the result value ",(0,s.jsx)(n.code,{children:"value"})," will be the unit value as circuits do not return anything, but for intermediate circuits it can be a structure of polynomial expressions, composed with other sub-circuits to build the final zkVM circuit."]}),"\n",(0,s.jsxs)(n.p,{children:["We define the completeness predicate following the constructors of the monad ",(0,s.jsx)(n.code,{children:"M.t"}),", with one rule per constructor:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Inductive t {A : Set} : M.t A -> A -> Prop :=\n| Pure (value : A) :\n  {{ M.Pure value \u2705 value }}\n| AssertZero (x : Z) (value : A) :\n  x = 0 ->\n  {{ M.AssertZero x value \u2705 value }}\n| Call (e : M.t A) (value : A) :\n  {{ e \u2705 value }} ->\n  {{ M.Call e \u2705 value }}\n| Let {B : Set} (e : M.t B) (value : B) (k : B -> M.t A) (value_k : A) :\n  {{ e \u2705 value }} ->\n  {{ k value \u2705 value_k }} ->\n  {{ M.Let e k \u2705 value_k }}\n| When (condition : Z) (e : M.t A) (value : A) :\n  (condition <> 0 -> {{ e \u2705 value }}) ->\n  {{ M.When condition e \u2705 value }}.\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here are some comments about the rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Pure"}),": we directly return the value ",(0,s.jsx)(n.code,{children:"value"})," that we are supposed to return. This is the case for purely functional circuits."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AssertZero"}),": we assert that the parameter ",(0,s.jsx)(n.code,{children:"x"})," is equal to ",(0,s.jsx)(n.code,{children:"0"}),". This is the main primitive to assert the constraints. We check the equality between the polynomial expression ",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"0"})," in ",(0,s.jsx)(n.code,{children:"Z"})," as we compute the modulo after each primitive polynomial operation, and we compare that all operations are correctly applied by comparison with the Rust implementation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Call"}),": this is a utility wrapper to simplify the composition of sub-circuits by giving an explicit way to mark limits. It does nothing except unwrap the ",(0,s.jsx)(n.code,{children:"M.Call"})," constructor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Let"}),": for the binding constructor, the most important constructor in a monad, we state that a circuit is complete if both the circuits ",(0,s.jsx)(n.code,{children:"e"})," and ",(0,s.jsx)(n.code,{children:"k"})," applied to the result of ",(0,s.jsx)(n.code,{children:"e"})," are complete."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"When"}),": we conditionally evaluate a sub-circuit ",(0,s.jsx)(n.code,{children:"e"})," and we assert that it evaluates to ",(0,s.jsx)(n.code,{children:"value"}),". We show the completeness of ",(0,s.jsx)(n.code,{children:"e"})," under the condition that ",(0,s.jsx)(n.code,{children:"condition"})," is not zero. In practice, ",(0,s.jsx)(n.code,{children:"value"})," will always by the unit value (this is the case on Plonky3 circuits)."]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"\ufe0f-for-branch_eq",children:["\ud83d\udee1\ufe0f For ",(0,s.jsx)(n.code,{children:"branch_eq"})]}),"\n",(0,s.jsxs)(n.p,{children:["If we take again the ",(0,s.jsx)(n.code,{children:"branch_eq"})," chip of ",(0,s.jsx)(n.a,{href:"https://openvm.dev/",children:"OpenVM"}),", located in ",(0,s.jsx)(n.a,{href:"https://github.com/openvm-org/openvm/blob/main/extensions/rv32im/circuit/src/branch_eq/core.rs",children:"github.com/openvm-org/openvm/extensions/rv32im/circuit/src/branch_eq/core.rs"}),", we state its completeness as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Lemma eval_complete `{Prime goldilocks_prime} {NUM_LIMBS : Z}\n    (self : BranchEqualCoreAir.t NUM_LIMBS)\n    (a' : Array.t Z NUM_LIMBS)\n    (b' : Array.t Z NUM_LIMBS)\n    (imm' : Z)\n    (diff_inv_marker' : Array.t Z NUM_LIMBS)\n    (from_pc' : Z)\n    (branch_equal_opcode : BranchEqualOpcode.t)\n    (H_NUM_LIMBS : 0 <= NUM_LIMBS) :\n  let a := M.map_mod a' in\n  let b := M.map_mod b' in\n  let imm := M.map_mod imm' in\n  let diff_inv_marker := M.map_mod diff_inv_marker' in\n  let from_pc := M.map_mod from_pc' in\n  let expected_cmp_result := get_expected_cmp_result branch_equal_opcode a b in\n  let local :=\n    {|\n      BranchEqualCoreCols.a := a;\n      BranchEqualCoreCols.b := b;\n      BranchEqualCoreCols.cmp_result := Z.b2z expected_cmp_result;\n      BranchEqualCoreCols.imm := imm;\n      BranchEqualCoreCols.opcode_beq_flag :=\n        match branch_equal_opcode with\n        | BranchEqualOpcode.BEQ => 1\n        | BranchEqualOpcode.BNE => 0\n        end;\n      BranchEqualCoreCols.opcode_bne_flag :=\n        match branch_equal_opcode with\n        | BranchEqualOpcode.BEQ => 0\n        | BranchEqualOpcode.BNE => 1\n        end;\n      BranchEqualCoreCols.diff_inv_marker := diff_inv_marker;\n    |} in\n  forall\n    (* We assume a [diff_inv_marker] oracle with the following property *)\n    (H_diff_inv_marker :\n      if Array.Eq.dec a b then\n        (* It can be anything in case of equality *)\n        True\n      else\n        (* Otherwise it is the inverse of the difference in exactly one case, zero elsewhere *)\n        exists k, 0 <= k < NUM_LIMBS /\\\n        forall i, 0 <= i < NUM_LIMBS ->\n        if i =? k then\n          BinOp.mul (BinOp.sub (a.[i]) (b.[i])) diff_inv_marker.[i] = 1\n        else\n          diff_inv_marker.[i] = 0\n    ),\n  {{ eval self local from_pc \u2705\n    get_expected_result self local from_pc expected_cmp_result\n  }}.\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is a long statement, but here is the gist of it:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We expect the final result to be the result of the function ",(0,s.jsx)(n.code,{children:"get_expected_result"})," applied to its parameters. This represents a structure containing various polynomial expressions, which will be useful later to combine this sub-circuit with others."]}),"\n",(0,s.jsxs)(n.li,{children:["The columns ",(0,s.jsx)(n.code,{children:"a"}),", ",(0,s.jsx)(n.code,{children:"b"}),", and ",(0,s.jsx)(n.code,{children:"imm"})," can be anything. They are input variables."]}),"\n",(0,s.jsxs)(n.li,{children:["The columns ",(0,s.jsx)(n.code,{children:"opcode_beq_flag"})," and ",(0,s.jsx)(n.code,{children:"opcode_bne_flag"})," are also input variables, but must be consistent: only one of them can be equal to ",(0,s.jsx)(n.code,{children:"1"}),"; the other one must be equal to ",(0,s.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The column ",(0,s.jsx)(n.code,{children:"diff_inv_marker"})," is an oracle variable. We assume that it has the expected property described by the predicate ",(0,s.jsx)(n.code,{children:"H_diff_inv_marker"}),". Note that with this statement we do not assume that an oracle value exists, and assume that this is obvious. It could be verified in a second step."]}),"\n",(0,s.jsxs)(n.li,{children:["The column ",(0,s.jsx)(n.code,{children:"cmp_result"})," is the only output variable. We compute it with ",(0,s.jsx)(n.code,{children:"get_expected_cmp_result"}),", and it must be a boolean (",(0,s.jsx)(n.code,{children:"0"})," or ",(0,s.jsx)(n.code,{children:"1"})," in the field modulo ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsx)(n.mrow,{children:(0,s.jsx)(n.mi,{children:"p"})}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"p"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"p"})]})})]}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This is thanks to the setting of the output value to ",(0,s.jsx)(n.code,{children:"get_expected_cmp_result"}),", which allows us to execute the circuit and validate all the constraints. The definition of this function is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"Definition get_expected_cmp_result {NUM_LIMBS : Z}\n    (branch_equal_opcode : BranchEqualOpcode.t)\n    (a b : Array.t Z NUM_LIMBS) :\n    bool :=\n  match branch_equal_opcode with\n  | BranchEqualOpcode.BEQ =>\n    if Array.Eq.dec a b then\n      true\n    else\n      false\n  | BranchEqualOpcode.BNE =>\n    if Array.Eq.dec a b then\n      false\n    else\n      true\n  end.\n"})}),"\n",(0,s.jsx)(n.p,{children:"When we have shown the determinism, we also used this function but in the other direction: to show that the constraints of the circuit imply that the output column must be equal to it."}),"\n",(0,s.jsx)(n.h2,{id:"-proof",children:"\ud83d\udd0d Proof"}),"\n",(0,s.jsxs)(n.p,{children:["The Rocq proof of the statement above is in ",(0,s.jsx)(n.a,{href:"https://github.com/formal-land/garden/blob/main/Garden/OpenVM/BranchEq/core_with_monad.v",children:"Garden/OpenVM/BranchEq/core_with_monad.v"}),". We apply the reasoning rules presented above to step through the definition of the ",(0,s.jsx)(n.code,{children:"branch_eq"})," circuit. For the main loop, which is parameterized by an arbitrary number of ",(0,s.jsx)(n.code,{children:"NUM_LIMBS"}),", we make a reasoning by induction to ensure that the constraints ",(0,s.jsx)(n.code,{children:"M.AssertZero"})," are always satisfied."]}),"\n",(0,s.jsx)(n.p,{children:"Here is an extract of the proof:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"eapply Complete.Let with (value := tt). {\n  repeat econstructor.\n  unfold local; destruct expected_cmp_result; reflexivity.\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"to verify the completeness of the line:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-coq",children:"let* _ := M.assert_bool local.(BranchEqualCoreCols.cmp_result) in\n"})}),"\n",(0,s.jsxs)(n.p,{children:["by case reasoning over the boolean variable ",(0,s.jsx)(n.code,{children:"cmp_result"}),".This works as we force the value of this output variable to be a boolean, as the result of the ",(0,s.jsx)(n.code,{children:"get_expected_cmp_result"})," function lifted to a field element."]}),"\n",(0,s.jsx)(n.p,{children:"There are no automations for now to verify the completeness, but we plan on adding some as we verify more circuits."}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["We have seen here what the definition of completeness is for a circuit, how we define it in our framework Garden through reasoning rules, and how we can verify it for the ",(0,s.jsx)(n.code,{children:"branch_eq"})," chip of OpenVM."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["You want to secure your zkVM? Discuss with us to check what is possible! \u21e8 ",(0,s.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"For more",type:"success",children:(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Follow us on ",(0,s.jsx)(n.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,s.jsx)(n.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions!"]})})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},22371:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/green-forest-c992f0c865d139086d04806ed3dd6de3.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);