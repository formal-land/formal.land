"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8281],{63604:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=s(74848),i=s(28453);const a={title:"\ud83e\udd77 Pretty-printing of Rust ZK constraints",tags:["zkVM","zero-knowledge","contraints"],authors:[]},r=void 0,l={permalink:"/blog/2025/08/26/pretty-printing-rust-constraints",source:"@site/blog/2025-08-26-pretty-printing-rust-constraints.md",title:"\ud83e\udd77 Pretty-printing of Rust ZK constraints",description:"Many zkVMs are implemented in Rust, using the Plonky3 library to describe their circuits. While Rust is efficient and expressive for describing complex circuits, it is a complex language when it comes to formal verification. We present here a way to pretty-print the list of constraints generated by a Plonky3 program. That way, we will be able to import the constraints in a formal verification system like Rocq to make sure they are safe and correct.",date:"2025-08-26T00:00:00.000Z",formattedDate:"August 26, 2025",tags:[{label:"zkVM",permalink:"/blog/tags/zk-vm"},{label:"zero-knowledge",permalink:"/blog/tags/zero-knowledge"},{label:"contraints",permalink:"/blog/tags/contraints"}],readingTime:5.465,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd77 Pretty-printing of Rust ZK constraints",tags:["zkVM","zero-knowledge","contraints"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd77 Verification of the completeness of an OpenVM chip",permalink:"/blog/2025/09/02/verification-completeness-open-vm-chip"},nextItem:{title:"\ud83e\udd77 Formal verification of an OpenVM chip",permalink:"/blog/2025/08/13/verification-of-openvm-branch-eq"}},o={authorsImageUrls:[]},c=[{value:"\ud83d\udee0\ufe0f Plonky3",id:"\ufe0f-plonky3",level:2},{value:"\ud83d\udcda Storing the constraints",id:"-storing-the-constraints",level:2},{value:"\ud83c\udfa8 Pretty-printing",id:"-pretty-printing",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",math:"math",mn:"mn",mo:"mo",mrow:"mrow",mstyle:"mstyle",mtable:"mtable",mtd:"mtd",mtext:"mtext",mtr:"mtr",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Many zkVMs are implemented in Rust, using the ",(0,t.jsx)(n.a,{href:"https://github.com/Plonky3/Plonky3",children:"Plonky3"})," library to describe their circuits. While Rust is efficient and expressive for describing complex circuits, it is a complex language when it comes to formal verification. We present here a way to pretty-print the list of constraints generated by a Plonky3 program. That way, we will be able to import the constraints in a formal verification system like ",(0,t.jsx)(n.a,{href:"https://rocq-prover.org/",children:"Rocq"})," to make sure they are safe and correct."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["This work was funded by a grant from the ",(0,t.jsx)(n.a,{href:"https://ethereum.foundation/",children:"Ethereum Foundation"})," to whom we are thankful, as part of the ",(0,t.jsx)(n.a,{href:"https://verified-zkevm.org/",children:"zkEVM Formal Verification Project"}),', to "accelerate the application of formal verification methods to zkEVMs".']})}),"\n",(0,t.jsx)("figure",{children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Green forest",src:s(37944).A+"",width:"1024",height:"1024"})})}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-plonky3",children:"\ud83d\udee0\ufe0f Plonky3"}),"\n",(0,t.jsxs)(n.p,{children:["This is one of the most popular libraries in use to describe circuits for zkVMs, with something like half of the projects using it. The main API to describe circuits is the trait ",(0,t.jsx)(n.code,{children:"AirBuilder"})," in ",(0,t.jsx)(n.a,{href:"https://github.com/Plonky3/Plonky3/blob/main/air/src/air.rs",children:"air/src/air.rs"}),", which we summarize and simplify here:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub trait AirBuilder: Sized {\n    /// Field element\n    type F;\n    /// Variable\n    type Var;\n    /// Polynomial expression\n    type Expr;\n    /// Matrix of the trace\n    type M: Matrix<Self::Var>;\n\n    /// Return the matrix representing the main (primary) trace registers.\n    fn main(&self) -> Self::M;\n\n    /// Expression evaluating to 1 on the first row, 0 elsewhere.\n    fn is_first_row(&self) -> Self::Expr;\n\n    /// Expression evaluating to 1 on the last row, 0 elsewhere.\n    fn is_last_row(&self) -> Self::Expr;\n\n    /// Expression evaluating to 1 on all transition rows (not last row), 0 on last row.\n    fn is_transition(&self) -> Self::Expr\n\n    /// Returns a sub-builder whose constraints are enforced only when `condition` is nonzero.\n    fn when<I: Into<Self::Expr>>(&mut self, condition: I) -> FilteredAirBuilder<'_, Self>\n\n    /// Assert that the given element is zero.\n    ///\n    /// Where possible, batching multiple assert_zero calls\n    /// into a single assert_zeros call will improve performance.\n    fn assert_zero<I: Into<Self::Expr>>(&mut self, x: I);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["From the ",(0,t.jsx)(n.code,{children:"assert_zero"})," function, we can build all the other assertion operators, like ",(0,t.jsx)(n.code,{children:"assert_bool"})," or ",(0,t.jsx)(n.code,{children:"assert_eq"}),". These assertions, creating polynomial equations, will be applied to expressions built from the variables of the trace returned by the ",(0,t.jsx)(n.code,{children:"main"})," function. Some special expressions ",(0,t.jsx)(n.code,{children:"is_first_row"}),", ",(0,t.jsx)(n.code,{children:"is_last_row"}),", and ",(0,t.jsx)(n.code,{children:"is_transition"})," help state how to initialize the trace and transition between rows. Finally, the ",(0,t.jsx)(n.code,{children:"when"})," function can be seen as a convenient helper with:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"air_builder.when(condition).assert_zero(expr);\n"})}),"\n",(0,t.jsx)(n.p,{children:"behaving like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"air_builder.assert_zero(condition * expr);\n"})}),"\n",(0,t.jsx)(n.p,{children:"since:"}),"\n",(0,t.jsx)(n.span,{className:"katex-display",children:(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mtable,{rowspacing:"0.25em",columnalign:"right left",columnspacing:"0em",children:[(0,t.jsxs)(n.mtr,{children:[(0,t.jsx)(n.mtd,{children:(0,t.jsx)(n.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mtext,{children:"condition"}),(0,t.jsx)(n.mo,{children:"\u22c5"}),(0,t.jsx)(n.mtext,{children:"expr"})]})})}),(0,t.jsx)(n.mtd,{children:(0,t.jsx)(n.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mrow,{}),(0,t.jsx)(n.mo,{children:"="}),(0,t.jsx)(n.mn,{children:"0"})]})})})]}),(0,t.jsxs)(n.mtr,{children:[(0,t.jsx)(n.mtd,{children:(0,t.jsx)(n.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mo,{children:"\u21d4"}),(0,t.jsx)(n.mtext,{children:"condition"}),(0,t.jsx)(n.mo,{mathvariant:"normal",children:"\u2260"}),(0,t.jsx)(n.mn,{children:"0"}),(0,t.jsx)(n.mo,{children:"\u21d2"}),(0,t.jsx)(n.mtext,{children:"expr"})]})})}),(0,t.jsx)(n.mtd,{children:(0,t.jsx)(n.mstyle,{scriptlevel:"0",displaystyle:"true",children:(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mrow,{}),(0,t.jsx)(n.mo,{children:"="}),(0,t.jsx)(n.mn,{children:"0"})]})})})]})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"  \\begin{align*}\n    \\text{condition} \\cdot \\text{expr} &= 0 \\\\\n    \\Leftrightarrow \\text{condition} \\neq 0 \\Rightarrow \\text{expr} &= 0\n  \\end{align*}"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"3em",verticalAlign:"-1.25em"}}),(0,t.jsx)(n.span,{className:"mord",children:(0,t.jsxs)(n.span,{className:"mtable",children:[(0,t.jsx)(n.span,{className:"col-align-r",children:(0,t.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,t.jsxs)(n.span,{className:"vlist-r",children:[(0,t.jsxs)(n.span,{className:"vlist",style:{height:"1.75em"},children:[(0,t.jsxs)(n.span,{style:{top:"-3.91em"},children:[(0,t.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(n.span,{className:"mord",children:[(0,t.jsx)(n.span,{className:"mord text",children:(0,t.jsx)(n.span,{className:"mord",children:"condition"})}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mord text",children:(0,t.jsx)(n.span,{className:"mord",children:"expr"})})]})]}),(0,t.jsxs)(n.span,{style:{top:"-2.41em"},children:[(0,t.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(n.span,{className:"mord",children:[(0,t.jsx)(n.span,{className:"mrel",children:"\u21d4"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mord text",children:(0,t.jsx)(n.span,{className:"mord",children:"condition"})}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsxs)(n.span,{className:"mrel",children:[(0,t.jsx)(n.span,{className:"mrel",children:(0,t.jsx)(n.span,{className:"mord vbox",children:(0,t.jsx)(n.span,{className:"thinbox",children:(0,t.jsxs)(n.span,{className:"rlap",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"inner",children:(0,t.jsx)(n.span,{className:"mord",children:(0,t.jsx)(n.span,{className:"mrel",children:"\ue020"})})}),(0,t.jsx)(n.span,{className:"fix"})]})})})}),(0,t.jsx)(n.span,{className:"mrel",children:"="})]}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mord",children:"0"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mrel",children:"\u21d2"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mord text",children:(0,t.jsx)(n.span,{className:"mord",children:"expr"})})]})]})]}),(0,t.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,t.jsx)(n.span,{className:"vlist-r",children:(0,t.jsx)(n.span,{className:"vlist",style:{height:"1.25em"},children:(0,t.jsx)(n.span,{})})})]})}),(0,t.jsx)(n.span,{className:"col-align-l",children:(0,t.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,t.jsxs)(n.span,{className:"vlist-r",children:[(0,t.jsxs)(n.span,{className:"vlist",style:{height:"1.75em"},children:[(0,t.jsxs)(n.span,{style:{top:"-3.91em"},children:[(0,t.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(n.span,{className:"mord",children:[(0,t.jsx)(n.span,{className:"mord"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mrel",children:"="}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mord",children:"0"})]})]}),(0,t.jsxs)(n.span,{style:{top:"-2.41em"},children:[(0,t.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsxs)(n.span,{className:"mord",children:[(0,t.jsx)(n.span,{className:"mord"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mrel",children:"="}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mord",children:"0"})]})]})]}),(0,t.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,t.jsx)(n.span,{className:"vlist-r",children:(0,t.jsx)(n.span,{className:"vlist",style:{height:"1.25em"},children:(0,t.jsx)(n.span,{})})})]})})]})})]})})]})}),"\n",(0,t.jsx)(n.h2,{id:"-storing-the-constraints",children:"\ud83d\udcda Storing the constraints"}),"\n",(0,t.jsxs)(n.p,{children:["Thanks to this modular architecture in Plonky3, we can provide a mock implementation of the ",(0,t.jsx)(n.code,{children:"AirBuilder"})," trait, which will be used to pretty-print the constraints. We implement each primitive operation by saving the parameters in a list, so that at the end of the construction of a circuit, we obtain a list of constraints. For the representation of expressions, we use the existing ",(0,t.jsx)(n.code,{children:"SymbolicExpression"})," implementation. Here is our current implementation of ",(0,t.jsx)(n.code,{children:"AirBuilder"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"struct RocqAirBuilder {\n    /// A matrix of variables, to be built with variables with an\n    /// id numbering from 0 to width * height - 1\n    main: RowMajorMatrix<SymbolicVariable<Goldilocks>>,\n    /// A list of constraints, each one being a polynomial equation of\n    /// an expression equal to zero\n    constraints: Vec<Constraint<SymbolicExpression<Goldilocks>>>,\n}\n\nimpl AirBuilder for RocqAirBuilder {\n    type F = Goldilocks;\n\n    type Expr = SymbolicExpression<Self::F>;\n\n    type Var = SymbolicVariable<Self::F>;\n\n    type M = RowMajorMatrix<Self::Var>;\n\n    fn main(&self) -> <Self as AirBuilder>::M {\n        self.main.clone()\n    }\n\n    fn is_first_row(&self) -> <Self as AirBuilder>::Expr {\n        SymbolicExpression::IsFirstRow\n    }\n\n    fn is_last_row(&self) -> <Self as AirBuilder>::Expr {\n        SymbolicExpression::IsLastRow\n    }\n\n    fn is_transition_window(&self, _: usize) -> <Self as AirBuilder>::Expr {\n        SymbolicExpression::IsTransition\n    }\n\n    fn assert_zero<I>(&mut self, expr: I)\n    where\n        I: Into<Self::Expr>,\n    {\n        // We store the constraint in a list, to be printed at the end\n        self.constraints.push(Constraint::AssertZero(expr.into()));\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"As this is convenient when the list of constraints is long (in the tens of thousands for a typical precompile), we also add a logging function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"impl LoggingAirBuilder for RocqAirBuilder {\n    fn log_in_constraints(&mut self, message: &str) {\n        self.constraints\n            .push(Constraint::Message(message.to_string()));\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"to display a string marker at any point in the code."}),"\n",(0,t.jsx)(n.h2,{id:"-pretty-printing",children:"\ud83c\udfa8 Pretty-printing"}),"\n",(0,t.jsxs)(n.p,{children:["We display the list of constraints on the standard output, so that they can be saved in a snapshot file. We take care of having an output that is regular and readable. The transformation we make is that we flatten the application of the associative binary operators ",(0,t.jsx)(n.code,{children:"+"})," and ",(0,t.jsx)(n.code,{children:"*"})," so that they get applied to a list of operands instead of two. This tends to flatten the output and increase the readability in our experience."]}),"\n",(0,t.jsx)(n.p,{children:"Here is a typical output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Trace \ud83d\udc3e\n  Message \ud83e\udd9c\n    eval_row\n  Message \ud83e\udd9c\n    eval_row::flags\n  AssertZero:\n    Mul:\n      Variable: 0\n      Sub:\n        Variable: 0\n        Constant: 1\n  AssertZero:\n    Mul:\n      Variable: 1\n      Sub:\n        Variable: 1\n        Constant: 1\n  AssertZero:\n    Mul:\n      Variable: 2\n      Sub:\n        Variable: 2\n        Constant: 1\n  AssertZero:\n    Mul:\n      Add:\n        Variable: 0\n        Variable: 2\n      Sub:\n        Add:\n          Variable: 0\n          Variable: 2\n        Constant: 1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We annotate the user messages with a \ud83e\udd9c to make them easier to find in the list of constraints. The variables are all identified by their ",(0,t.jsx)(n.em,{children:"id"})," in the trace, which is a number from ",(0,t.jsx)(n.code,{children:"0"})," to ",(0,t.jsx)(n.code,{children:"width * height - 1"}),". We flatten the consecutive applications of binary operators, like in:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"AssertZero:\n  Mul:\n    Variable: 459\n    Constant: 18446462594437939201\n    Sub:\n      Add:\n        Variable: 808\n        Constant: 0\n        Mul:\n          Variable: 11\n          Constant: 1\n        Mul:\n          Variable: 12\n          Constant: 2\n        Mul:\n          Variable: 13\n          Constant: 4\n        Mul:\n          Variable: 14\n          Constant: 8\n        Mul:\n          Variable: 15\n          Constant: 16\n        Mul:\n          Variable: 16\n          Constant: 32\n        Mul:\n          Variable: 17\n          Constant: 64\n        Mul:\n          Variable: 18\n          Constant: 128\n        Mul:\n          Variable: 19\n          Constant: 256\n        Mul:\n          Variable: 20\n          Constant: 512\n        Mul:\n          Variable: 21\n          Constant: 1024\n        Mul:\n          Variable: 22\n          Constant: 2048\n        Mul:\n          Variable: 23\n          Constant: 4096\n        Mul:\n          Variable: 24\n          Constant: 8192\n        Mul:\n          Variable: 25\n          Constant: 16384\n        Mul:\n          Variable: 26\n          Constant: 32768\n        Constant: 0\n      Add:\n        Constant: 0\n        Mul:\n          Variable: 782\n          Constant: 1\n        Mul:\n          Variable: 783\n          Constant: 256\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that the large constant ",(0,t.jsx)(n.code,{children:"18446462594437939201"})," is the inverse of ",(0,t.jsx)(n.code,{children:"2"})," for the Goldilocks prime."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"There are other kinds of constraints, like lookups, which we do not show here."})}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"We have seen here how to output the definition of a Plonky3 circuit in a readable, and sometimes verbose, text format."}),"\n",(0,t.jsx)(n.p,{children:"Next, we will see how to connect this representation to the Rocq formalization of a circuit, to make sure we are verifying the right implementation."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["You want to secure your zkVM? Discuss to check what is possible! \u21e8 ",(0,t.jsx)(n.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"})]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"For more",type:"success",children:(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Follow us on ",(0,t.jsx)(n.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,t.jsx)(n.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions!"]})})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},37944:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/green-forest-64cf93c699ac9003123bf64a9ce3f9e7.png"},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);