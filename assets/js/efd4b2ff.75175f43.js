"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[9718],{8581:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=t(4848),o=t(8453);const r={title:"\ud83e\udd80 Beginning of translation of OpenVM to Rocq",tags:["Rust","OpenVM","coq-of-rust"],authors:["guillaume_claret"]},s=void 0,a={permalink:"/blog/2025/06/15/beginning-of-openvm-to-rocq",source:"@site/blog/2025-06-15-beginning-of-openvm-to-rocq.md",title:"\ud83e\udd80 Beginning of translation of OpenVM to Rocq",description:"Here, we present our beginning work of translating part of the OpenVM code to the proof assistant &nbsp;Rocq. The aim is to experiment around the formal verification of the zero-knowledge circuits of this zkVM based on the Plonky3 library. One of the aims of the zkVMs is to increase the scalability of the blockchains by packing many transactions in a single zk proof.",date:"2025-06-15T00:00:00.000Z",formattedDate:"June 15, 2025",tags:[{label:"Rust",permalink:"/blog/tags/rust"},{label:"OpenVM",permalink:"/blog/tags/open-vm"},{label:"coq-of-rust",permalink:"/blog/tags/coq-of-rust"}],readingTime:7.72,hasTruncateMarker:!0,authors:[{name:"Guillaume Claret",url:"https://github.com/clarus",imageURL:"https://github.com/clarus.png",key:"guillaume_claret"}],frontMatter:{title:"\ud83e\udd80 Beginning of translation of OpenVM to Rocq",tags:["Rust","OpenVM","coq-of-rust"],authors:["guillaume_claret"]},unlisted:!1,prevItem:{title:"\ud83e\udd80 Functional specification of the ADD instruction of the EVM",permalink:"/blog/2025/07/06/functional-specification-add"},nextItem:{title:"\ud83e\udd80 Typing and naming of Rust code in Rocq (2/3)",permalink:"/blog/2025/02/05/links-for-rust-in-rocq-2"}},l={authorsImageUrls:[void 0]},c=[{value:"\ud83c\udfaf Target",id:"-target",level:2},{value:"\u2753 Why is Rust code complex?",id:"-why-is-rust-code-complex",level:2},{value:"\ud83d\udd0d What is the plan?",id:"-what-is-the-plan",level:2},{value:"\ud83d\udd17 Linking",id:"-linking",level:2},{value:"Trait hierarchy",id:"trait-hierarchy",level:3},{value:"Eval body",id:"eval-body",level:3},{value:"\ud83c\udff7\ufe0f Naming the versions",id:"\ufe0f-naming-the-versions",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Here, we present our beginning work of translating part of the ",(0,i.jsx)(n.a,{href:"https://openvm.dev/",children:"OpenVM"})," code to the proof assistant ",(0,i.jsxs)(n.a,{href:"https://rocq-prover.org/",children:[(0,i.jsx)("img",{src:"https://raw.githubusercontent.com/coq/rocq-prover.org/refs/heads/main/rocq-id/logos/SVG/icon-rocq-orange.svg",height:"18px"}),"\xa0Rocq"]}),". The aim is to experiment around the formal verification of the zero-knowledge circuits of this zkVM based on the ",(0,i.jsx)(n.a,{href:"https://github.com/Plonky3/Plonky3",children:"Plonky3"})," library. One of the aims of the zkVMs is to increase the scalability of the blockchains by packing many transactions in a single zk proof."]}),"\n",(0,i.jsxs)(n.admonition,{title:"Work with us!",type:"success",children:[(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.strong,{children:"formal verification"})," you can ",(0,i.jsx)(n.strong,{children:"guarantee"})," that your code is safe, given the specifications."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Contact us"})," at\xa0",(0,i.jsx)(n.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"})," to discuss how to apply formal verification to your code!\xa0\ud83d\udee1\ufe0f"]}),(0,i.jsxs)(n.p,{children:["We cover ",(0,i.jsx)(n.strong,{children:"Rust"}),", ",(0,i.jsx)(n.strong,{children:"Solidity"}),", and ",(0,i.jsx)(n.strong,{children:"ZK systems"}),"."]})]}),"\n",(0,i.jsx)(n.h2,{id:"-target",children:"\ud83c\udfaf Target"}),"\n",(0,i.jsxs)(n.p,{children:["Our goal is to formally verify that the circuit of the component ",(0,i.jsx)(n.a,{href:"https://github.com/openvm-org/openvm/blob/main/extensions/rv32im/circuit/src/branch_eq/core.rs",children:"BranchEq"})," of OpenVM is not underconstrained. This is one of the main security properties to look for in a circuit. This means that it is not possible to provide a proof of execution with a behavior different from what is expected."]}),"\n",(0,i.jsx)(n.p,{children:"A circuit is a set of equality assertions between values in a prime field using only addition or multiplication. Said otherwise, they are a set of equations on polynomials. The OpenVM project uses the Plonky3 library to define these. It adds a wrapper on top of Plonky3 with APIs to define custom instructions. An implementation for the RISC-V instruction set is provided but it could be anything, and it is easily extensible. This is convenient for example to provide optimized circuits for hashing primitives."}),"\n",(0,i.jsx)(n.p,{children:"We will attempt to directly translate the Rust code describing the circuit to Rocq. There are a lot of challenge in this translation, as the Rust language contains a lot of hidden complexities, but it has the promise to be easy to maintain as we get a circuit description that closely matches its implementation."}),"\n",(0,i.jsx)(n.p,{children:"The source links are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/openvm-org/openvm/blob/main/extensions/rv32im/circuit/src/branch_eq/core.rs",children:"github.com/openvm-org/openvm/blob/main/extensions/rv32im/circuit/src/branch_eq/core.rs"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/openvm-org/openvm/blob/main/extensions/rv32im/circuit/src/README.md",children:"github.com/openvm-org/openvm/blob/main/extensions/rv32im/circuit/src/README.md"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The main datatype on which the circuit computes is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub struct BranchEqualCoreCols<T, const NUM_LIMBS: usize> {\n    pub a: [T; NUM_LIMBS],\n    pub b: [T; NUM_LIMBS],\n\n    // Boolean result of a op b. Should branch if and only if cmp_result = 1.\n    pub cmp_result: T,\n    pub imm: T,\n\n    pub opcode_beq_flag: T,\n    pub opcode_bne_flag: T,\n\n    pub diff_inv_marker: [T; NUM_LIMBS],\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["where you can consider\xa0",(0,i.jsx)(n.code,{children:"T"})," as being the type of a prime field. The Rust function to generate the equations is:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"impl<AB, I, const NUM_LIMBS: usize> VmCoreAir<AB, I> for BranchEqualCoreAir<NUM_LIMBS>\nwhere\n    AB: InteractionBuilder,\n    I: VmAdapterInterface<AB::Expr>,\n    I::Reads: From<[[AB::Expr; NUM_LIMBS]; 2]>,\n    I::Writes: Default,\n    I::ProcessedInstruction: From<ImmInstruction<AB::Expr>>,\n{\n    fn eval(\n        &self,\n        builder: &mut AB,\n        local: &[AB::Var],\n        from_pc: AB::Var,\n    ) -> AdapterAirContext<AB::Expr, I> {\n        let cols: &BranchEqualCoreCols<_, NUM_LIMBS> = local.borrow();\n        let flags = [cols.opcode_beq_flag, cols.opcode_bne_flag];\n\n        let is_valid = flags.iter().fold(AB::Expr::ZERO, |acc, &flag| {\n            builder.assert_bool(flag);\n            acc + flag.into()\n        });\n        builder.assert_bool(is_valid.clone());\n        builder.assert_bool(cols.cmp_result);\n\n        let a = &cols.a;\n        let b = &cols.b;\n        let inv_marker = &cols.diff_inv_marker;\n\n        let cmp_eq =\n            cols.cmp_result * cols.opcode_beq_flag +\n            not(cols.cmp_result) * cols.opcode_bne_flag;\n        let mut sum = cmp_eq.clone();\n\n        for i in 0..NUM_LIMBS {\n            sum += (a[i] - b[i]) * inv_marker[i];\n            builder.assert_zero(cmp_eq.clone() * (a[i] - b[i]));\n        }\n        builder.when(is_valid.clone()).assert_one(sum);\n\n        let expected_opcode = flags\n            .iter()\n            .zip(BranchEqualOpcode::iter())\n            .fold(AB::Expr::ZERO, |acc, (flag, opcode)| {\n                acc + (*flag).into() * AB::Expr::from_canonical_u8(opcode as u8)\n            })\n            + AB::Expr::from_canonical_usize(self.offset);\n\n        let to_pc = from_pc\n            + cols.cmp_result * cols.imm\n            + not(cols.cmp_result) * AB::Expr::from_canonical_u32(self.pc_step);\n\n        AdapterAirContext {\n            to_pc: Some(to_pc),\n            reads: [cols.a.map(Into::into), cols.b.map(Into::into)].into(),\n            writes: Default::default(),\n            instruction: ImmInstruction {\n                is_valid,\n                opcode: expected_opcode,\n                immediate: cols.imm.into(),\n            }\n            .into(),\n        }\n    }\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"An interesting part of this code is that it returns polynomial expressions to be used later, in addition to generating equations."}),"\n",(0,i.jsx)(n.h2,{id:"-why-is-rust-code-complex",children:"\u2753 Why is Rust code complex?"}),"\n",(0,i.jsx)(n.p,{children:"Although the code of the function is relatively short (around 50 lines), it contains a lot of implicit function calls. This mainly comes from the fact that it is parametrized by many traits, as you can see in the signature of the function. To know exactly which function is being called, you need to unroll a lot of the definitions."}),"\n",(0,i.jsxs)(n.p,{children:["This applies to all the definitions handling field elements, like ",(0,i.jsx)(n.code,{children:"AB::Expr"}),", as well as iterators, with calls to the ",(0,i.jsx)(n.code,{children:"zip"})," and ",(0,i.jsx)(n.code,{children:"fold"})," functions for example. We are exposed to this complexity when formally verifying the code above, and this is one of the reasons Rust is a complex language to formally verify, although it is very elegant with a lot of abstractions."]}),"\n",(0,i.jsx)(n.h2,{id:"-what-is-the-plan",children:"\ud83d\udd0d What is the plan?"}),"\n",(0,i.jsx)(n.p,{children:"Our plan is as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Translate the Rust code to Rocq using ",(0,i.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust",children:"coq-of-rust"})," (this part is automatically done)."]}),"\n",(0,i.jsxs)(n.li,{children:["Express all the data types using native Rocq types and resolving the trait hierarchies (phase that we call ",(0,i.jsx)(n.strong,{children:"linking"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Define an API for Plonky3 as a free monad in Rocq, with all the primitive operations like creating an expression, building a constraint, etc."}),"\n",(0,i.jsx)(n.li,{children:"Show that the translated Rust code can be expressed in an equivalent way using this Plonky3 monad. Alternatively we could pretty-print the constraints at this point and compare them between the Rust and Rocq versions, if showing the equivalence is too hard."}),"\n",(0,i.jsx)(n.li,{children:"Formally verify that the circuits are not underconstrained."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-linking",children:"\ud83d\udd17 Linking"}),"\n",(0,i.jsxs)(n.p,{children:["We are focusing on producing a typed-version for the ",(0,i.jsx)(n.code,{children:"eval"})," function above, with an explicit trait hierarchy. Indeed ",(0,i.jsx)(n.code,{children:"coq-of-rust"})," produces definitions that are untyped (all values have the type ",(0,i.jsx)(n.code,{children:"Value.t"}),") and the relation between identifiers and function definitions or trait instances is defined by equations."]}),"\n",(0,i.jsx)(n.h3,{id:"trait-hierarchy",children:"Trait hierarchy"}),"\n",(0,i.jsxs)(n.p,{children:["In the file ",(0,i.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/blob/e91da9613fee8c2ba6b12f60d6a979935ed1d811/CoqOfRust/plonky3/commit_539bbc84/field/links/field.v",children:"CoqOfRust/plonky3/commit_539bbc84/field/links/field.v"})," we define the trait hierarchy corresponding to the Plonky3 definitions for fields in ",(0,i.jsx)(n.a,{href:"https://github.com/Plonky3/Plonky3/blob/539bbc84085efb609f4f62cb03cf49588388abdb/field/src/field.rs",children:"field/src/field.rs"}),". One thing we had to do was to break the mutual dependency between the traits ",(0,i.jsx)(n.code,{children:"FieldAlgebra"})," and ",(0,i.jsx)(n.code,{children:"Field"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait FieldAlgebra:\n    // ...\n{\n    type F: Field;\n    // ...\n}\n\npub trait Field:\n    FieldAlgebra<F = Self>\n    // ...\n{\n    // ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"by defining on the Rocq side:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["A trait ",(0,i.jsx)(n.code,{children:"FieldAlgebraWithoutField"})," that is like ",(0,i.jsx)(n.code,{children:"FieldAlgebra"})," but without the ",(0,i.jsx)(n.code,{children:"Field"})," trait constraint on the associated type ",(0,i.jsx)(n.code,{children:"F"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["A trait ",(0,i.jsx)(n.code,{children:"Field"})," depending on ",(0,i.jsx)(n.code,{children:"FieldAlgebraWithoutField"}),". Note that here, we do not need to add the ",(0,i.jsx)(n.code,{children:"Field"})," constraint on ",(0,i.jsx)(n.code,{children:"F"})," to be equivalent to the Rust code, as it is the ",(0,i.jsx)(n.code,{children:"Self"})," type of ",(0,i.jsx)(n.code,{children:"Field"}),", so it necessarily implements the ",(0,i.jsx)(n.code,{children:"Field"})," trait."]}),"\n",(0,i.jsxs)(n.li,{children:["A trait ",(0,i.jsx)(n.code,{children:"FieldAlgebra"})," taking the trait ",(0,i.jsx)(n.code,{children:"FieldAlgebraWithoutField"})," and adding the ",(0,i.jsx)(n.code,{children:"Field"})," trait constraint on the associated type ",(0,i.jsx)(n.code,{children:"F"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["On the Rocq side, we are free to organize our trait definitions as we want as long as they correspond to the trait equations generated by ",(0,i.jsx)(n.code,{children:"coq-of-rust"}),". If we do not build our trait hierarchy properly, we will be stuck when defining the typed version of the functions' bodies."]}),"\n",(0,i.jsx)(n.h3,{id:"eval-body",children:"Eval body"}),"\n",(0,i.jsxs)(n.p,{children:["For now, the typed version of the ",(0,i.jsx)(n.code,{children:"eval"})," function is defined as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-coq",children:"Instance run_eval\n      (AB I : Set) (NUM_LIMBS : Usize.t) `{Link AB} `{Link I}\n      (AirBuilder_types : AirBuilder.AssociatedTypes.t)\n      `{AirBuilder.AssociatedTypes.AreLinks AirBuilder_types}\n      (VmAdapterInterface_types : VmAdapterInterface.AssociatedTypes.t)\n      `{VmAdapterInterface.AssociatedTypes.AreLinks VmAdapterInterface_types}\n      (run_InteractionBuilder_for_AB : InteractionBuilder.Run AB AirBuilder_types)\n      (run_VmAdapterInterface_for_I :\n        VmAdapterInterface.Run\n          I\n          AirBuilder_types.(AirBuilder.AssociatedTypes.Expr)\n          VmAdapterInterface_types\n      )\n      (self : Ref.t Pointer.Kind.Ref (Self NUM_LIMBS))\n      (builder : Ref.t Pointer.Kind.MutRef AB)\n      (local :\n        Ref.t Pointer.Kind.Ref (list AirBuilder_types.(AirBuilder.AssociatedTypes.Var)))\n      (from_pc : AirBuilder_types.(AirBuilder.AssociatedTypes.Var)) :\n    Run.Trait (eval (\u03c6 NUM_LIMBS) (\u03a6 AB) (\u03a6 I))\n      [] [] [\u03c6 self; \u03c6 builder; \u03c6 local; \u03c6 from_pc]\n      unit.\n  Proof.\n    constructor.\n    destruct run_InteractionBuilder_for_AB.\n    destruct run_AirBuilder_for_Self.\n    destruct run_VmAdapterInterface_for_I.\n    destruct (Impl_Borrow_BranchEqualCoreCols_for_slice_T.run\n      AirBuilder_types.(AirBuilder.AssociatedTypes.Var)\n      NUM_LIMBS\n    ).\n    destruct run_FieldAlgebra_for_Expr.\n    destruct run_FieldAlgebra_for_Self.\n    destruct run_Clone_for_Self.\n    pose proof (Impl_Into_for_From_T.run (\n      Impl_From_for_T.run AirBuilder_types.(AirBuilder.AssociatedTypes.Expr)\n    )).\n    destruct run_Add_for_Self.\n    destruct run_Mul_for_Self.\n    destruct run_Add_Expr_for_Var.\n    destruct run_Mul_Var_for_Var.\n    destruct run_Mul_Var_for_Expr.\n    run_symbolic.\nAdmitted.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We generate the typed definition automatically with the tactic ",(0,i.jsx)(n.code,{children:"run_symbolic"}),", based on the code translated by ",(0,i.jsx)(n.code,{children:"coq-of-rust"})," and knowing there should only be one possible typed definition corresponding to each untyped one."]}),"\n",(0,i.jsxs)(n.p,{children:["A difficulty that is not solved yet is that we need to provide in context all the trait instances which will be used. This is the series of ",(0,i.jsx)(n.code,{children:"destruct"})," at the beginning of the proof. Unfortunately, a lot of them are needed and it is sometimes hard to find them, especially for those that require specific parameters which we need to make explicit."]}),"\n",(0,i.jsx)(n.p,{children:"There are also a few closures used in this code, for which the handling is not automated enough yet."}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-naming-the-versions",children:"\ud83c\udff7\ufe0f Naming the versions"}),"\n",(0,i.jsxs)(n.p,{children:["For now, we put all the Rocq translation of Rust code in a folder ",(0,i.jsx)(n.a,{href:"https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust",children:"CoqOfRust/"}),". To avoid collisions between different versions of the same library, we started using a sub-folder for each crate with the name of the version in use. For example, the Plonky3 translation is now put in the folder ",(0,i.jsx)(n.code,{children:"CoqOfRust/plonky3/commit_539bbc84"})," as this is the precise version used by the OpenVM code we are looking at."]}),"\n",(0,i.jsxs)(n.p,{children:["In the long run, it will also be useful to make backward compatibility proofs, where we show that a newer version of a crate behaves the same as an older one on all the common endpoints. The only downside of this naming scheme is that it makes the paths longer in the ",(0,i.jsx)(n.code,{children:"Require"})," commands."]}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["We have not succeeded yet in extracting a typed Rocq version of the ",(0,i.jsx)(n.code,{children:"BranchEq"})," module of OpenVM. We will work next on adding more automation to ",(0,i.jsx)(n.code,{children:"coq-of-rust"})," to make the linking phase easier."]}),"\n",(0,i.jsxs)(n.p,{children:["In parallel, we are working on a hand-written version of the ",(0,i.jsx)(n.code,{children:"BranchEq"})," module in Rocq, to start verifying the circuits, which we will show equivalent to the translated version once the linking phase is automated."]}),"\n",(0,i.jsx)(n.admonition,{title:"For more",type:"success",children:(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Follow us on ",(0,i.jsx)(n.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,i.jsx)(n.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions!"]})})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);