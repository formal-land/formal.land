"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[5706],{99767:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>o});var s=n(74848),r=n(28453);const a={title:"\ud83e\udd80 Functional correctness of STATIC_CALL in Revm",tags:["Rust","EVM","rocq-of-rust","functional correctness"],authors:[]},i=void 0,l={permalink:"/blog/2026/01/16/functional-correctness-static-call-revm",source:"@site/blog/2026-01-16-functional-correctness-static-call-revm.md",title:"\ud83e\udd80 Functional correctness of STATIC_CALL in Revm",description:"In this blog post, we show how we state the functional correctness of the implementation of the STATIC_CALL instruction in Revm, an implementation of the Ethereum's virtual machine EVM in Rust. This involves running rocq-of-rust to translate the Rust code to the theorem prover Rocq, and then making a proof by refinements until obtaining a specification of the code written in purely functional style, optimized for formal verification. This also proves the code cannot panic, as our specifications are free of panics.",date:"2026-01-16T00:00:00.000Z",formattedDate:"January 16, 2026",tags:[{label:"Rust",permalink:"/blog/tags/rust"},{label:"EVM",permalink:"/blog/tags/evm"},{label:"rocq-of-rust",permalink:"/blog/tags/rocq-of-rust"},{label:"functional correctness",permalink:"/blog/tags/functional-correctness"}],readingTime:8.235,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Functional correctness of STATIC_CALL in Revm",tags:["Rust","EVM","rocq-of-rust","functional correctness"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd84 Formal verification is translation and verification",permalink:"/blog/2026/01/20/translation-and-verification"},nextItem:{title:"\ud83e\udd77 Formal verification of the Keccak precompile from Plonky3",permalink:"/blog/2026/01/14/formal-verification-keccak-plonky3"}},c={authorsImageUrls:[]},o=[{value:"Source code",id:"source-code",level:2},{value:"Translation of the THIR",id:"translation-of-the-thir",level:2},{value:"Typing",id:"typing",level:2},{value:"Memory",id:"memory",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",mspace:"mspace",msub:"msub",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In this blog post, we show how we state the functional correctness of the implementation of the ",(0,s.jsx)(t.code,{children:"STATIC_CALL"})," instruction in ",(0,s.jsx)(t.a,{href:"https://github.com/bluealloy/revm",children:"Revm"}),", an implementation of the Ethereum's virtual machine EVM in Rust. This involves running ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/rocq-of-rust",children:"rocq-of-rust"})," to translate the Rust code to the theorem prover ",(0,s.jsx)(t.a,{href:"https://rocq-prover.org/",children:"Rocq"}),", and then making a proof by refinements until obtaining a specification of the code written in purely functional style, optimized for formal verification. This also proves the code cannot panic, as our specifications are free of panics."]}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsxs)(t.p,{children:["This work was funded by a grant from the ",(0,s.jsx)(t.a,{href:"https://ethereum.foundation/",children:"Ethereum Foundation"}),", to whom we are thankful, related to the ",(0,s.jsx)(t.a,{href:"https://verified-zkevm.org/",children:"zkEVM Formal Verification Project"}),", to bring more security to the Ethereum ecosystem in general."]}),(0,s.jsx)(t.p,{children:"Completing this work on Revm and the other main implementations of the EVM, together with a proof of equivalence between them, will enable proving that there cannot be network splits due to nodes disagreeing on the EVM semantics."})]}),"\n",(0,s.jsx)("figure",{children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Snow forest",src:n(45905).A+"",width:"1024",height:"1024"})})}),"\n",(0,s.jsx)(t.h2,{id:"source-code",children:"Source code"}),"\n",(0,s.jsxs)(t.p,{children:["Here is the body of the function implementing the ",(0,s.jsx)(t.code,{children:"STATIC_CALL"})," instruction in Revm, from the file ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/revm/blob/80099a7702084332b8de4a99dabe0095b5cde705/crates/interpreter/src/instructions/contract.rs",children:"interpreter/src/instructions/contract.rs"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub fn static_call<WIRE: InterpreterTypes, H: Host + ?Sized>(\n    interpreter: &mut Interpreter<WIRE>,\n    host: &mut H,\n) {\n    check!(interpreter, BYZANTIUM);\n    popn!([local_gas_limit, to], interpreter);\n    let to = Address::from_word(B256::from(to));\n    // Max gas limit is not possible in real ethereum situation.\n    let local_gas_limit = u64::try_from(local_gas_limit).unwrap_or(u64::MAX);\n\n    let Some((input, return_memory_offset)) = get_memory_input_and_out_ranges(interpreter) else {\n        return;\n    };\n\n    let Some(mut load) = host.load_account_delegated(to) else {\n        interpreter\n            .control\n            .set_instruction_result(InstructionResult::FatalExternalError);\n        return;\n    };\n    // Set `is_empty` to false as we are not creating this account.\n    load.is_empty = false;\n    let Some(gas_limit) = calc_call_gas(interpreter, load, false, local_gas_limit) else {\n        return;\n    };\n    gas!(interpreter, gas_limit);\n\n    // Call host to interact with target contract\n    interpreter.control.set_next_action(\n        InterpreterAction::NewFrame(FrameInput::Call(Box::new(CallInputs {\n            input,\n            gas_limit,\n            target_address: to,\n            caller: interpreter.input.target_address(),\n            bytecode_address: to,\n            value: CallValue::Transfer(U256::ZERO),\n            scheme: CallScheme::StaticCall,\n            is_static: true,\n            is_eof: false,\n            return_memory_offset,\n        }))),\n        InstructionResult::CallOrCreate,\n    );\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"This code contains many difficult parts, including:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The use of complex traits, such as ",(0,s.jsx)(t.code,{children:"InterpreterTypes"}),", relying on associated types and sub-traits;"]}),"\n",(0,s.jsxs)(t.li,{children:["The use of macros such as ",(0,s.jsx)(t.code,{children:"gas!"}),", hiding more code than it appears;"]}),"\n",(0,s.jsxs)(t.li,{children:["Conversions with inference of the target type, through the use of the ",(0,s.jsx)(t.code,{children:"from"})," and ",(0,s.jsx)(t.code,{children:"try_from"})," functions;"]}),"\n",(0,s.jsx)(t.li,{children:"A bit of control flow with pattern-matching and early returns."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Here is our specification in Rocq, from the file ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/rocq-of-rust/blob/main/RocqOfRust/revm/revm_interpreter/instructions/simulate/contract/static_call.v",children:"revm_interpreter/instructions/simulate/contract/static_call.v"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Definition static_call\n    {WIRE H : Set} `{Link WIRE} `{Link H}\n    {WIRE_types : InterpreterTypes.Types.t} `{InterpreterTypes.Types.AreLinks WIRE_types}\n    {IInterpreterTypes : InterpreterTypes.C WIRE_types}\n    {IHost : Host.C H}\n    (interpreter : Interpreter.t WIRE WIRE_types)\n    (host : H) :\n    Interpreter.t WIRE WIRE_types * H :=\n  check_macro interpreter SpecId.BYZANTIUM\n    (fun interpreter => (interpreter, host)) (fun interpreter =>\n  popn_macro interpreter {| Integer.value := 2 |}\n    (fun interpreter => (interpreter, host)) (fun arr interpreter =>\n  let '(_, to, local_gas_limit) := ArrayPairs.to_tuple_rev (arr.(array.value)) in\n  let to := Impl_Address.from_word (Impl_From_U256_for_FixedBytes_32.from to) in\n\n  let local_gas_limit :=\n    Impl_Result_T_E.unwrap_or\n      (TryFrom_Uint_for_u64.try_from local_gas_limit)\n      Impl_u64.MAX in\n\n  match call_helpers.get_memory_input_and_out_ranges interpreter with\n  | (None, interpreter) => (interpreter, host)\n  | (Some (input, return_memory_offset), interpreter) =>\n\n  match IHost.(Host.load_account_delegated) host to with\n  | (None, host) =>\n    let control :=\n      IInterpreterTypes\n          .(InterpreterTypes.Loop)\n          .(Loop.set_instruction_result)\n        interpreter.(Interpreter.control)\n        instruction_result.InstructionResult.FatalExternalError in\n    let interpreter :=\n      interpreter\n        <| Interpreter.control := control |> in\n    (interpreter, host)\n  | (Some load, host) =>\n\n  let load := load <| AccountLoad.is_empty := false |> in\n  match call_helpers.calc_call_gas interpreter load false local_gas_limit with\n  | (None, interpreter) => (interpreter, host)\n  | (Some gas_limit, interpreter) =>\n  gas_macro interpreter gas_limit\n    (fun interpreter => (interpreter, host)) (fun interpreter =>\n\n  let control :=\n    IInterpreterTypes\n        .(InterpreterTypes.Loop)\n        .(Loop.set_next_action)\n      interpreter.(Interpreter.control)\n      (interpreter_action.InterpreterAction.NewFrame\n        (interpreter_action.FrameInput.Call\n          (Impl_Box.new\n            {|\n              call_inputs.CallInputs.bytecode_address := to;\n              call_inputs.CallInputs.caller :=\n                InputTraits.target_address interpreter.(Interpreter.input);\n              call_inputs.CallInputs.gas_limit := gas_limit;\n              call_inputs.CallInputs.input := input;\n              call_inputs.CallInputs.is_eof := false;\n              call_inputs.CallInputs.is_static := true;\n              call_inputs.CallInputs.return_memory_offset := return_memory_offset;\n              call_inputs.CallInputs.scheme := call_inputs.CallScheme.StaticCall;\n              call_inputs.CallInputs.target_address := to;\n              call_inputs.CallInputs.value := call_inputs.CallValue.Transfer Impl_Uint.ZERO\n            |}\n      )))\n      instruction_result.InstructionResult.CallOrCreate in\n  let interpreter :=\n    interpreter <| Interpreter.control := control |> in\n\n  (interpreter, host)\n  ) end end end)).\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We aim to keep the structure of the Rust code, using the ",(0,s.jsx)(t.code,{children:"check_macro"})," and ",(0,s.jsx)(t.code,{children:"popn_macro"})," functions to also reproduce the Rust macros. The added verbosity is essentially due to Rocq notations being heavier, in particular to manipulate structures or to call trait methods, as well as making the state manipulation explicit."]}),"\n",(0,s.jsx)(t.h2,{id:"translation-of-the-thir",children:"Translation of the THIR"}),"\n",(0,s.jsxs)(t.p,{children:["Running the command ",(0,s.jsx)(t.code,{children:"cargo rocq-of-rust"}),", after installing the tool, automatically extracts the THIR intermediate representation of the Rust code of Revm to Rocq. The representation is typically very verbose, with around 1,000 lines, for example, for the ",(0,s.jsx)(t.code,{children:"STATIC_CALL"})," function. You can look at the extracted code in ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/rocq-of-rust/blob/main/RocqOfRust/revm/revm_interpreter/instructions/contract.v",children:"revm_interpreter/instructions/contract.v"}),". This is mostly a deep-embedding; it starts like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:'Definition static_call (\u03b5 : list Value.t) (\u03c4 : list Ty.t) (\u03b1 : list Value.t) : M :=\n      match \u03b5, \u03c4, \u03b1 with\n      | [], [ WIRE; H ], [ interpreter; host ] =>\n        ltac:(M.monadic\n          (let interpreter :=\n            M.alloc (|\n              Ty.apply\n                (Ty.path "&mut")\n                []\n                [ Ty.apply (Ty.path "revm_interpreter::interpreter::Interpreter") [] [ WIRE ] ],\n              interpreter\n            |) in\n          let host := M.alloc (| Ty.apply (Ty.path "&mut") [] [ H ], host |) in\n          M.catch_return (Ty.tuple []) (|\n            ltac:(M.monadic\n              (M.read (|\n                let~ _ : Ty.tuple [] :=\n                  M.match_operator (|\n                    Ty.tuple [],\n                    M.alloc (| Ty.tuple [], Value.Tuple [] |),\n                    [\n                      fun \u03b3 =>\n                        ltac:(M.monadic\n                          (let \u03b3 :=\n                            M.use\n                              (M.alloc (|\n                                Ty.path "bool",\n                                M.call_closure (|\n                                  Ty.path "bool",\n                                  UnOp.not,\n'})}),"\n",(0,s.jsx)(t.p,{children:"To make it understandable, we make a proof by refinement, where we prove in a few steps that the code is equivalent to a simpler version, until arriving at the functional specification."}),"\n",(0,s.jsx)(t.h2,{id:"typing",children:"Typing"}),"\n",(0,s.jsxs)(t.p,{children:["Even if the extracted code contains the type annotations from the Rust compiler (the letter T of THIR stands for Type), the extracted code is, for now, untyped, and all the values are in the special type ",(0,s.jsx)(t.code,{children:"Value.t"})," representing all possible Rust values. We do a first pass where we type all the code using user-provided Rocq types representing the Rust values of interest."]}),"\n",(0,s.jsx)(t.p,{children:"For example, for the Rust type:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub enum Ordering {\n    Less = -1,\n    Equal = 0,\n    Greater = 1,\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"we will provide the Rocq type:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Module Ordering.\n  Inductive t : Set :=\n  | Less\n  | Equal\n  | Greater.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["with an injection\xa0",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"\u03c6"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\varphi"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"\u03c6"})]})})]})," to go to the type of Rust values:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:'\u03c6 x :=\n  match x with\n  | Less =>\n      Value.StructTuple "core::cmp::Ordering::Less" [] [] []\n  | Equal =>\n      Value.StructTuple "core::cmp::Ordering::Equal" [] [] []\n  | Greater =>\n      Value.StructTuple "core::cmp::Ordering::Greater" [] [] []\n  end\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The bulk of the type-checking phase is about showing that we can view all the untyped values as images of typed values, both for the inputs and outputs of functions, through the canonical injection\xa0",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"\u03c6"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\varphi"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"\u03c6"})]})})]})," defined for each type."]}),"\n",(0,s.jsxs)(t.p,{children:["Here is the typing statement for the ",(0,s.jsx)(t.code,{children:"STATIC_CALL"})," function, from the file ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/rocq-of-rust/blob/main/RocqOfRust/revm/revm_interpreter/instructions/links/contract/static_call.v",children:"revm_interpreter/instructions/links/contract/static_call.v"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Instance run_static_call\n  {WIRE H : Set} `{Link WIRE} `{Link H}\n  {WIRE_types : InterpreterTypes.Types.t} `{InterpreterTypes.Types.AreLinks WIRE_types}\n  {H_types : Host.Types.t} `{Host.Types.AreLinks H_types}\n  (run_InterpreterTypes_for_WIRE : InterpreterTypes.Run WIRE WIRE_types)\n  (run_Host_for_H : Host.Run H H_types)\n  (interpreter : '&mut (Interpreter.t WIRE WIRE_types))\n  (host : '&mut H) :\n  Run.Trait\n    instructions.contract.static_call [] [ \u03a6 WIRE; \u03a6 H ] [ \u03c6 interpreter; \u03c6 host ]\n    unit.\nProof.\n  constructor.\n  destruct (TryFrom_Uint_for_u64.method_try_from\n    (BITS := {| Integer.value := 256 |})\n    (LIMBS := {| Integer.value := 4 |})\n  ).\n  run_symbolic.\nDefined.\nGlobal Opaque run_static_call.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Most of the proof is automated in the ",(0,s.jsx)(t.code,{children:"run_symbolic"})," tactic, once we have properly declared the corresponding Rocq types and expressed the Rust traits as Rocq typeclasses."]}),"\n",(0,s.jsxs)(t.p,{children:["Essentially, for a function ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"f"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"f"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.10764em"},children:"f"})]})})]})," from ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"A"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"A"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"A"})]})})]})," to ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"B"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"B"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"})]})})]}),", we show that:"]}),"\n",(0,s.jsx)(t.span,{className:"katex-display",children:(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{mathvariant:"normal",children:"\u2200"}),(0,s.jsx)(t.mtext,{children:"\u2009"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"x"}),(0,s.jsx)(t.mo,{children:":"}),(0,s.jsx)(t.mi,{children:"A"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"}),(0,s.jsx)(t.mo,{separator:"true",children:","}),(0,s.jsx)(t.mtext,{children:"\xa0"}),(0,s.jsx)(t.mi,{mathvariant:"normal",children:"\u2203"}),(0,s.jsx)(t.mtext,{children:"\u2009"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"y"}),(0,s.jsx)(t.mo,{children:":"}),(0,s.jsx)(t.mi,{children:"B"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"}),(0,s.jsx)(t.mo,{separator:"true",children:","}),(0,s.jsx)(t.mspace,{width:"1em"}),(0,s.jsx)(t.mi,{children:"f"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsxs)(t.msub,{children:[(0,s.jsx)(t.mi,{children:"\u03c6"}),(0,s.jsx)(t.mi,{children:"A"})]}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"x"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"}),(0,s.jsx)(t.mo,{children:"="}),(0,s.jsxs)(t.msub,{children:[(0,s.jsx)(t.mi,{children:"\u03c6"}),(0,s.jsx)(t.mi,{children:"B"})]}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"y"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"  \\forall\\,(x : A),\\ \\exists\\,(y : B), \\quad f (\u03c6_A(x)) = \u03c6_B(y)"})]})})}),(0,s.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord",children:"\u2200"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"x"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(t.span,{className:"mrel",children:":"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"A"}),(0,s.jsx)(t.span,{className:"mclose",children:")"}),(0,s.jsx)(t.span,{className:"mpunct",children:","}),(0,s.jsx)(t.span,{className:"mspace",children:"\xa0"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(t.span,{className:"mord",children:"\u2203"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(t.span,{className:"mrel",children:":"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"}),(0,s.jsx)(t.span,{className:"mclose",children:")"}),(0,s.jsx)(t.span,{className:"mpunct",children:","}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"1em"}}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.10764em"},children:"f"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsxs)(t.span,{className:"mord",children:[(0,s.jsx)(t.span,{className:"mord mathnormal",children:"\u03c6"}),(0,s.jsx)(t.span,{className:"msupsub",children:(0,s.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(t.span,{className:"vlist-r",children:[(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.3283em"},children:(0,s.jsxs)(t.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,s.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(t.span,{className:"mord mathnormal mtight",children:"A"})})]})}),(0,s.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(t.span,{className:"vlist-r",children:(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(t.span,{})})})]})})]}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"x"}),(0,s.jsx)(t.span,{className:"mclose",children:"))"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(t.span,{className:"mrel",children:"="}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsxs)(t.span,{className:"mord",children:[(0,s.jsx)(t.span,{className:"mord mathnormal",children:"\u03c6"}),(0,s.jsx)(t.span,{className:"msupsub",children:(0,s.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(t.span,{className:"vlist-r",children:[(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.3283em"},children:(0,s.jsxs)(t.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,s.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(t.span,{className:"mord mathnormal mtight",style:{marginRight:"0.05017em"},children:"B"})})]})}),(0,s.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(t.span,{className:"vlist-r",children:(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(t.span,{})})})]})})]}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,s.jsx)(t.span,{className:"mclose",children:")"})]})]})]})}),"\n",(0,s.jsxs)(t.p,{children:["with a constructive proof enabling the computation of ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"y"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"y"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"})]})})]})," from ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"x"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"x"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"x"})]})})]}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"memory",children:"Memory"}),"\n",(0,s.jsxs)(t.p,{children:["We do not print the code of the typed version of ",(0,s.jsx)(t.code,{children:"static_call"}),", as this code can be extremely verbose! But we will step through it, using a semantics where we allocate local values on the stack, to show that the typed code is equivalent to the functional specification above. In this phase, we:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Convert the control flow of Rust, with its ",(0,s.jsx)(t.code,{children:"match"}),", ",(0,s.jsx)(t.code,{children:"return"}),", ... operators to Rocq ones;"]}),"\n",(0,s.jsx)(t.li,{children:"Convert the use of stack-allocated (and sometimes heap-allocated) values to Rocq values, which are implicitly allocated, as this is a functional language."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Depending on the code, we will structure it using a state and/or error monad. The statement for the equivalence, from the file ",(0,s.jsx)(t.a,{href:"https://github.com/formal-land/rocq-of-rust/blob/main/RocqOfRust/revm/revm_interpreter/instructions/simulate/contract/static_call.v",children:"revm_interpreter/instructions/simulate/contract/static_call.v"}),", is:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"Lemma static_call_eq\n    {WIRE H : Set} `{Link WIRE} `{Link H}\n    {WIRE_types : InterpreterTypes.Types.t} `{InterpreterTypes.Types.AreLinks WIRE_types}\n    {H_types : Host.Types.t} `{Host.Types.AreLinks H_types}\n    (run_InterpreterTypes_for_WIRE : InterpreterTypes.Run WIRE WIRE_types)\n    (run_Host_for_H : Host.Run H H_types)\n    (IInterpreterTypes : InterpreterTypes.C WIRE_types)\n    (InterpreterTypesEq :\n      InterpreterTypes.Eq.t WIRE WIRE_types run_InterpreterTypes_for_WIRE IInterpreterTypes)\n    (IHost : Host.C H)\n    (HostEq : Host.Eq.t IHost)\n    (interpreter : Interpreter.t WIRE WIRE_types)\n    (host : H) :\n  let ref_interpreter := make_ref 0 in\n  let ref_host := make_ref 1 in\n  {{\n    SimulateM.eval_f (\n      run_static_call\n        run_InterpreterTypes_for_WIRE run_Host_for_H ref_interpreter ref_host\n      )\n      [interpreter; host]%stack \ud83c\udf32\n    (\n      Output.Success tt,\n      let (interpreter, host) := static_call interpreter host in\n      [interpreter; host]%stack\n    )\n  }}.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["where the function ",(0,s.jsx)(t.code,{children:"run_static_call"})," is the typed version of the code extracted by ",(0,s.jsx)(t.code,{children:"rocq-of-rust"}),", and ",(0,s.jsx)(t.code,{children:"static_all"})," is our functional specification."]}),"\n",(0,s.jsx)(t.p,{children:"The notation:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"{{ e \ud83c\udf32 v }}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["means that the monadic expression ",(0,s.jsx)(t.code,{children:"e"})," evaluates to the purely functional value ",(0,s.jsx)(t.code,{children:"v"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The proof is done by stepping through each functional call or branching of the code of ",(0,s.jsx)(t.code,{children:"static_call"}),". We could automate the proof further, but for now, we still step manually through the code for better control. Here is an extract from the proof:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-coq",children:"eapply Run.Call. {\n  apply Impl_From_U256_for_FixedBytes_32.from_eq.\n}\neapply Run.Call. {\n  apply Impl_Address.from_word_eq.\n}\neapply Run.Call. {\n  apply TryFrom_Uint_for_u64.try_from_eq.\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"stepping through the function calls for:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"B256::from(...)"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"Address::from_word(...)"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"u64::try_from(...)"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,s.jsxs)(t.p,{children:["We have seen how to formally verify the functional correctness of the Rust implementation for the ",(0,s.jsx)(t.code,{children:"STATIC_CALL"})," instruction of the EVM using ",(0,s.jsx)(t.code,{children:"rocq-of-rust"}),". These techniques are general, and enable the formal verification at scale of programs for a large subset of Rust, for arbitrary security properties using the theorem prover Rocq."]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["You want to secure critical applications? Discuss with us to know what is possible at ",(0,s.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{title:"Socials",type:"success",children:(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["Follow us on ",(0,s.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,s.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more!"]})})})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},45905:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/snow-forest-303a602e7f98ea125e6997305a3ba831.png"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var s=n(96540);const r={},a=s.createContext(r);function i(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);