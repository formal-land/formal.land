"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[8481],{65545:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=o(74848),a=o(28453);const r={title:"\ud83e\udd77 Semantics for LLZK in Rocq",tags:["LLZK","semantics","zero-knowledge"],authors:[]},i=void 0,s={permalink:"/blog/2025/07/30/llzk-to-rocq-semantics",source:"@site/blog/2025-07-30-llzk-to-rocq-semantics.md",title:"\ud83e\udd77 Semantics for LLZK in Rocq",description:"LLZK is a language designed to implement zero-knowledge circuits. We wrote a translation tool from this language to a representation in the formal language Rocq.",date:"2025-07-30T00:00:00.000Z",formattedDate:"July 30, 2025",tags:[{label:"LLZK",permalink:"/blog/tags/llzk"},{label:"semantics",permalink:"/blog/tags/semantics"},{label:"zero-knowledge",permalink:"/blog/tags/zero-knowledge"}],readingTime:6.26,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd77 Semantics for LLZK in Rocq",tags:["LLZK","semantics","zero-knowledge"],authors:[]},unlisted:!1,prevItem:{title:"\ud83e\udd77 Formal verification of LLZK circuits in Rocq",permalink:"/blog/2025/07/31/llzk-to-rocq-verification"},nextItem:{title:"\ud83e\udd77 Beginning of a formal verification tool for LLZK",permalink:"/blog/2025/07/28/llzk-to-rocq-beginning"}},l={authorsImageUrls:[]},c=[];function g(e){const t={a:"a",p:"p",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://github.com/Veridise/llzk-lib",children:"LLZK"})," is a language designed to implement ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Zero-knowledge_proof",children:"zero-knowledge"})," circuits. We wrote a translation tool from this language to a representation in the formal language ",(0,n.jsx)(t.a,{href:"https://rocq-prover.org/",children:"Rocq"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"In this blog post, we present how we give a semantics to all the primitive operations of LLZK in Rocq. The end-goal is to provide a way to formally verify that a zero-knowledge circuit is safe, that is to say, without under-constraints."})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(g,{...e})}):g(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>s});var n=o(96540);const a={},r=n.createContext(a);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);