"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[7422],{7823:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=n(74848),s=n(28453);const a={title:"\ud83e\udd80 Example of verification for the Move's checker of Sui",tags:["Rust","Move","Sui","type-checker"],authors:[]},r=void 0,i={permalink:"/blog/2024/11/14/sui-move-checker-abstract-stack",source:"@site/blog/2024-11-14-sui-move-checker-abstract-stack.md",title:"\ud83e\udd80 Example of verification for the Move's checker of Sui",description:"We are continuing our formal verification work for the implementation of the type-checker of the Move language in the \ud83d\udca7&nbsp;Sui blockchain. We verify a manual translation in the proof system \ud83d\udc13&nbsp;Coq of the \ud83e\udd80&nbsp;Rust code of the Move checker as available on GitHub.",date:"2024-11-14T00:00:00.000Z",formattedDate:"November 14, 2024",tags:[{label:"Rust",permalink:"/blog/tags/rust"},{label:"Move",permalink:"/blog/tags/move"},{label:"Sui",permalink:"/blog/tags/sui"},{label:"type-checker",permalink:"/blog/tags/type-checker"}],readingTime:7.74,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd80 Example of verification for the Move's checker of Sui",tags:["Rust","Move","Sui","type-checker"],authors:[]},unlisted:!1,prevItem:{title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 2",permalink:"/blog/2024/11/15/tool-for-noir-2"},nextItem:{title:"\u25fc\ufe0f A formal verification tool for Noir \u2013 1",permalink:"/blog/2024/11/01/tool-for-noir-1"}},c={authorsImageUrls:[]},l=[{value:"\ud83d\udd75\ufe0f The code to verify",id:"\ufe0f-the-code-to-verify",level:2},{value:"\u2696\ufe0f Specification",id:"\ufe0f-specification",level:2},{value:"\ud83e\udd13 Proof",id:"-proof",level:2},{value:"\u2712\ufe0f Conclusion",id:"\ufe0f-conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["We are continuing our formal verification work for the implementation of the type-checker of the ",(0,o.jsx)(t.a,{href:"https://sui.io/move",children:"Move"})," language in the ",(0,o.jsx)(t.a,{href:"https://sui.io/",children:"\ud83d\udca7\xa0Sui"})," blockchain. We verify a manual translation in the proof system ",(0,o.jsx)(t.a,{href:"https://coq.inria.fr/",children:"\ud83d\udc13\xa0Coq"})," of the ",(0,o.jsx)(t.a,{href:"https://www.rust-lang.org/",children:"\ud83e\udd80\xa0Rust"})," code of the Move checker as available on ",(0,o.jsx)(t.a,{href:"https://github.com/move-language/move-sui/tree/main/crates/move-bytecode-verifier",children:"GitHub"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["In this blog post, we present in detail the verification of a particular function ",(0,o.jsx)(t.code,{children:"AbstractStack::pop_eq_n"})," that manipulates \ud83d\udcda\xa0stacks of types to show that it is equivalent to its naive implementation."]}),"\n",(0,o.jsxs)(t.p,{children:["All the code presented here is on our GitHub at ",(0,o.jsx)(t.a,{href:"https://github.com/formal-land/coq-of-rust",children:"github.com/formal-land/coq-of-rust"})," \ud83e\uddd1\u200d\ud83c\udfeb."]}),"\n",(0,o.jsxs)(t.admonition,{title:"Get started",type:"success",children:[(0,o.jsxs)(t.p,{children:["To ensure your code is secure today, contact us at\xa0",(0,o.jsx)(t.a,{href:"mailto:contact@formal.land",children:"\xa0\ud83d\udc8ccontact@formal.land"}),"!\xa0\ud83d\ude80"]}),(0,o.jsxs)(t.p,{children:["Formal verification goes further than traditional audits to make 100% sure you cannot lose your funds, thanks to ",(0,o.jsx)(t.strong,{children:"mathematical reasoning on the code"}),". It can be integrated into your CI pipeline to check that every commit is fully correct ",(0,o.jsx)(t.strong,{children:"without doing a whole audit again"}),"."]}),(0,o.jsxs)(t.p,{children:["We make bugs such as the ",(0,o.jsx)(t.a,{href:"https://www.gemini.com/fr-fr/cryptopedia/the-dao-hack-makerdao",children:"DAO hack"})," ($60 million stolen) virtually ",(0,o.jsx)(t.strong,{children:"impossible to happen again"}),"."]})]}),"\n",(0,o.jsx)("figure",{children:(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Water in forest",src:n(80351).A+"",width:"1792",height:"1024"})})}),"\n",(0,o.jsx)(t.h2,{id:"\ufe0f-the-code-to-verify",children:"\ud83d\udd75\ufe0f The code to verify"}),"\n",(0,o.jsxs)(t.p,{children:["Here is the definition in Rust of an ",(0,o.jsx)(t.code,{children:"AbstractStack"}),", from the file ",(0,o.jsx)(t.a,{href:"https://github.com/move-language/move-sui/blob/main/crates/move-abstract-stack/src/lib.rs",children:"move-abstract-stack/src/lib.rs"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// An abstract value that compresses runs of the same value to reduce space usage\npub struct AbstractStack<T> {\n    values: Vec<(u64, T)>,\n    len: u64,\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["It says that a stack of elements of type\xa0",(0,o.jsx)(t.code,{children:"T"})," is a vector of pairs of a number and a value. The number is the number of times the value is repeated in the stack. The field\xa0",(0,o.jsx)(t.code,{children:"len"})," is the total number of elements in the stack. This representation is more efficient than a naive stack, in case the stack contains many repeated values."]}),"\n",(0,o.jsx)(t.p,{children:"Here is one of the primitives to remove elements from this stack:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// Pops n values off the stack, erroring if there are not enough items or if the n items are\n/// not equal\npub fn pop_eq_n(&mut self, n: NonZeroU64) -> Result<T, AbsStackError> {\n    let n: u64 = n.get();\n    if self.is_empty() || n > self.len {\n        return Err(AbsStackError::Underflow);\n    }\n    let (count, last) = self.values.last_mut().unwrap();\n    debug_assert!(*count > 0);\n    let ret = match (*count).cmp(&n) {\n        Ordering::Less => return Err(AbsStackError::ElementNotEqual),\n        Ordering::Equal => {\n            let (_, last) = self.values.pop().unwrap();\n            last\n        }\n        Ordering::Greater => {\n            *count -= n;\n            last.clone()\n        }\n    };\n    self.len -= n;\n    Ok(ret)\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This function removes ",(0,o.jsx)(t.code,{children:"n"})," elements from the stack, returning the value of removed elements. It returns an error if there are not enough elements in the stack or if the ",(0,o.jsx)(t.code,{children:"n"})," last items are not grouped as equal elements."]}),"\n",(0,o.jsxs)(t.p,{children:["Our goal is to ",(0,o.jsx)(t.strong,{children:"show that this function is equal to the naive pop function with repetition"})," on flattened stacks."]}),"\n",(0,o.jsx)(t.h2,{id:"\ufe0f-specification",children:"\u2696\ufe0f Specification"}),"\n",(0,o.jsx)(t.p,{children:"Here is the property we want to verify in the formal language Coq:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Lemma flatten_pop_eq_n {A : Set} `{Eq.Trait A} (n : Z) (stack : AbstractStack.t A)\n    (H_n : n > 0) :\n  match AbstractStack.pop_eq_n n stack with\n  | Panic.Value (Result.Ok item, stack') =>\n    flatten stack = List.repeat item (Z.to_nat n) ++ flatten stack'\n  | _ => True\n  end.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["It says that for any possible ",(0,o.jsx)(t.code,{children:"stack"})," and ",(0,o.jsx)(t.code,{children:"n"})," greater than 0, if we remove ",(0,o.jsx)(t.code,{children:"n"})," elements from the stack and when the execution succeeds, the flattened stack is equal to the repetition of the removed element ",(0,o.jsx)(t.code,{children:"n"})," times followed by the flattened stack."]}),"\n",(0,o.jsx)(t.p,{children:"How did we get from the Rust code above to the expression of this property? We manually converted the Rust code above in Coq with the following definitions:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Module AbstractStack.\n  Record t (A : Set) : Set := {\n    values : list (Z * A);\n    len : Z;\n  }.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["for the ",(0,o.jsx)(t.code,{children:"AbstractStack"})," type, and:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:'Definition pop_eq_n {A : Set} (n : Z) : MS! (t A) (Result.t A AbsStackError.t) :=\n  fun (self : t A) =>\n  if (is_empty self || (n >? len self))%bool then\n    return! (Result.Err AbsStackError.Underflow, self)\n  else\n  let! (count, last) := Option.unwrap (List.hd_error self.(values)) in\n  if count <? n then\n    return! (Result.Err AbsStackError.ElementNotEqual, self)\n  else if count =? n then\n    let (_, values) := vec.pop_front self.(values) in\n    let self := {|\n      values := values;\n      len := self.(len) - n\n    |} in\n    return! (Result.Ok last, self)\n  else\n    let! values :=\n      match values self with\n      | [] => panic! "unreachable"\n      | (_, last) :: values => return! ((count - n, last) :: values)\n      end in\n    let self := {|\n      values := values;\n      len := self.(len) - n\n    |} in\n    return! (Result.Ok last, self).\n'})}),"\n",(0,o.jsxs)(t.p,{children:["for the ",(0,o.jsx)(t.code,{children:"pop_eq_n"})," function. Note that this definition uses a lot of user-defined notations, such as ",(0,o.jsx)(t.code,{children:"let!"}),", that we made in order to simplify the expression of effects in Coq. You can read more about these notations on our previous blog post ",(0,o.jsx)(t.a,{href:"/blog/2024/10/14/verification-move-sui-type-checker-2",children:"\ud83e\udd80\xa0Formal verification of the type checker of Sui \u2013 part 2"}),". We checked by testing that our translation above behaves as the original Rust code, as explained in our blog post ",(0,o.jsx)(t.a,{href:"/blog/2024/10/15/verification-move-sui-type-checker-3",children:"\ud83e\udd80\xa0Formal verification of the type checker of Sui \u2013 part 3"}),". It is not necessary to understand the translation in detail, as its verification will flow naturally."]}),"\n",(0,o.jsxs)(t.p,{children:["We define the ",(0,o.jsx)(t.code,{children:"flatten"})," function to translate a stack with repetitions to a flat stack as:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Definition flatten {A : Set} (abstract_stack : AbstractStack.t A) : list A :=\n  List.flat_map (fun '(n, v) => List.repeat v (Z.to_nat n)) abstract_stack.(AbstractStack.values).\n"})}),"\n",(0,o.jsxs)(t.p,{children:["It duplicates all the elements\xa0",(0,o.jsx)(t.code,{children:"n"})," times with ",(0,o.jsx)(t.code,{children:"List.repeat v (Z.to_nat n)"})," and concatenates them with ",(0,o.jsx)(t.code,{children:"List.flat_map"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"-proof",children:"\ud83e\udd13 Proof"}),"\n",(0,o.jsx)(t.p,{children:"To show that the specification above is correct for any stacks, we cannot test it as it will only cover a finite amount of cases. We must write a Coq proof showing by mathematical reasoning that the code is always correct."}),"\n",(0,o.jsx)(t.p,{children:"Here is our full proof:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Proof.\n  destruct stack as [stack].\n  unfold AbstractStack.pop_eq_n, flatten.\n  (* if (is_empty self || (n >? len self))%bool then *)\n  destruct (_  || _); simpl; [reflexivity|].\n  unfold List.hd_error.\n  (* Option.unwrap (List.hd_error self.(values)) *)\n  destruct stack as [|[count last] stack]; simpl; [reflexivity|].\n  (* if count <? n then *)\n  destruct (_ <? n)%Z eqn:?; simpl; [reflexivity|].\n  (* if count =? n then *)\n  destruct (_ =? n)%Z eqn:?; simpl.\n  { now replace n with count by lia. }\n  { rewrite List.app_assoc.\n    rewrite <- List.repeat_app.\n    now replace (Z.to_nat n + Z.to_nat (count - n))%nat\n      with (Z.to_nat count)\n      by lia.\n  }\nQed.\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The way it works is that we follow all the possible execution branches in the Coq definition of ",(0,o.jsx)(t.code,{children:"pop_eq_n"})," to show that each branch leads to either an execution error or a ",(0,o.jsx)(t.code,{children:"Result.Ok"})," value with the correct stack. The ",(0,o.jsx)(t.code,{children:"destruct"})," tactic is the one that allows us to explore each branch of the code, and is used every time we have a ",(0,o.jsx)(t.code,{children:"match"})," or an ",(0,o.jsx)(t.code,{children:"if"})," in the code."]}),"\n",(0,o.jsxs)(t.p,{children:["Other reasoning operations include ",(0,o.jsx)(t.code,{children:"unfold"})," to expand a definition or ",(0,o.jsx)(t.code,{children:"rewrite"})," and ",(0,o.jsx)(t.code,{children:"replace"})," to replace an expression with another when we have proved they are equal. For example, we replace:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Z.to_nat n + Z.to_nat (count - n)\n"})}),"\n",(0,o.jsx)(t.p,{children:"by:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"Z.to_nat count\n"})}),"\n",(0,o.jsxs)(t.p,{children:["as addition and subtraction by ",(0,o.jsx)(t.code,{children:"n"})," cancel each other, and ",(0,o.jsx)(t.code,{children:"count"})," is greater than ",(0,o.jsx)(t.code,{children:"n"})," in this context for the ",(0,o.jsx)(t.code,{children:"Z.to_nat (count - n)"})," operation to be well-defined."]}),"\n",(0,o.jsxs)(t.p,{children:["While we write the proof in Coq we get a better view thanks to the interactive proof mode. For example, after the last\xa0",(0,o.jsx)(t.code,{children:"destruct"})," we have:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-coq",children:"A: Set\nH: Eq.Trait A\nn, count: Z\nlast: A\nstack: list (Z * A)\nlen: Z\nH_n: n >= 0\nHeqb: (count <? n) = false\nHeqb0: (count =? n) = true\n\n--------------------------------------\n\n1/2\nList.repeat last (Z.to_nat count) ++ List.flat_map (fun '(n0, v) => List.repeat v (Z.to_nat n0)) stack =\nList.repeat last (Z.to_nat n) ++ List.flat_map (fun '(n0, v) => List.repeat v (Z.to_nat n0)) stack\n\n--------------------------------------\n\n2/2\nList.repeat last (Z.to_nat count) ++ List.flat_map (fun '(n0, v) => List.repeat v (Z.to_nat n0)) stack =\nList.repeat last (Z.to_nat n) ++\nList.repeat last (Z.to_nat (count - n)) ++ List.flat_map (fun '(n0, v) => List.repeat v (Z.to_nat n0)) stack\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This is how we can progress in the proof and know which command to type. We see two sub-goals ",(0,o.jsx)(t.code,{children:"(1/2)"})," and ",(0,o.jsx)(t.code,{children:"(2/2)"})," for each branch explored by the last ",(0,o.jsx)(t.code,{children:"destruct"}),". In both cases, we need to show an equality:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["The first one is solved by the fact that ",(0,o.jsx)(t.code,{children:"count = n"})," in this branch."]}),"\n",(0,o.jsxs)(t.li,{children:["The second one is solved by the fact that ",(0,o.jsx)(t.code,{children:"count > n"})," in this branch, so that we can group the ",(0,o.jsx)(t.code,{children:"List.repeat last (Z.to_nat n)"})," with ",(0,o.jsx)(t.code,{children:"List.repeat last (Z.to_nat (count - n))"}),' (repeating a "negative" number of times is the empty list so we need to make sure that ',(0,o.jsx)(t.code,{children:"count - n"})," is not negative)."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"\ufe0f-conclusion",children:"\u2712\ufe0f Conclusion"}),"\n",(0,o.jsxs)(t.p,{children:["In this example, we have seen how to verify that the ",(0,o.jsx)(t.code,{children:"pop_eq_n"})," function of the ",(0,o.jsx)(t.code,{children:"AbstractStack"})," type in the Move checker of Sui is equivalent to the naive pop function with repetition on flattened stacks. As this is a formal proof, we are sure that this property holds for any possible stack and value of ",(0,o.jsx)(t.code,{children:"n"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"We are continuing the work to verify the other functions of the project, with the final aim to verify the whole type-checker. We will keep you updated on our progress in the next blog posts\xa0\ud83d\ude80."}),"\n",(0,o.jsx)(t.admonition,{title:"For more",type:"success",children:(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:["Follow us on ",(0,o.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," or ",(0,o.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more, or comment on this post below! Feel free to DM us for any questions or requests!"]})})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},80351:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/water-in-forest-c6f1a042b20e0b0ef9d33cd340ebdb01.webp"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var o=n(96540);const s={},a=o.createContext(s);function r(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);