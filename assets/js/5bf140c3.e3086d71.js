"use strict";(self.webpackChunkformal_land=self.webpackChunkformal_land||[]).push([[5247],{60117:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=a(74848),n=a(28453);const o={title:"\ud83e\udd84 Formal verification is translation and verification",tags:["formal verification","translation","verification"],authors:[]},r=void 0,s={permalink:"/blog/2026/01/20/translation-and-verification",source:"@site/blog/2026-01-20-translation-and-verification.md",title:"\ud83e\udd84 Formal verification is translation and verification",description:"In this post, we propose a general overview of what formal verification is by decomposing it into two main steps:",date:"2026-01-20T00:00:00.000Z",formattedDate:"January 20, 2026",tags:[{label:"formal verification",permalink:"/blog/tags/formal-verification"},{label:"translation",permalink:"/blog/tags/translation"},{label:"verification",permalink:"/blog/tags/verification"}],readingTime:2.745,hasTruncateMarker:!0,authors:[],frontMatter:{title:"\ud83e\udd84 Formal verification is translation and verification",tags:["formal verification","translation","verification"],authors:[]},unlisted:!1,nextItem:{title:"\ud83e\udd80 Functional correctness of STATIC_CALL in Revm",permalink:"/blog/2026/01/16/functional-correctness-static-call-revm"}},l={authorsImageUrls:[]},c=[{value:"Translation",id:"translation",level:2},{value:"Verification",id:"verification",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"In this post, we propose a general overview of what formal verification is by decomposing it into two main steps:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Translation"})," of the source code to a formal language;"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Verification"})," of the formal specification in the formal language."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We will cover the main techniques used at each step, knowing that in most cases it is possible to combine the approaches."}),"\n",(0,i.jsx)("figure",{children:(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"White forest",src:a(97668).A+"",width:"951",height:"948"})})}),"\n",(0,i.jsx)(t.h2,{id:"translation",children:"Translation"}),"\n",(0,i.jsx)(t.p,{children:"The translation part handles all the programming details, such as manipulating data structures from the standard library, or handling how pointers, states, and i/o are done."}),"\n",(0,i.jsxs)(t.p,{children:["The end goal of the translation is to generate a purely functional representation of the code, as formal systems are purely mathematical representations of the code (think languages like ",(0,i.jsx)(t.a,{href:"https://www.haskell.org/",children:"Haskell"}),"/",(0,i.jsx)(t.a,{href:"https://ocaml.org/",children:"OCaml"}),", or mathematical propositions). The end result can be extremely verbose."]}),"\n",(0,i.jsx)(t.p,{children:"There are a few approaches to make it manageable:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Use fully automated formal verification, where the computer will have to read the translation, but not the human. This is the approach of SMT/model checking. The downside is that verification can timeout."}),"\n",(0,i.jsx)(t.li,{children:"Use a manual/AI translation to an idiomatic representation in the formal language, with a manual review or tests to make sure it captures all the details. The drawback is that it can introduce mistakes, and it is hard to maintain when code changes."}),"\n",(0,i.jsx)(t.li,{children:'Use a compiler, which can work very well with enough automation or by restricting the source programming language to a specific and "safe" subset. It can be combined with proof-by-refinements, so the user can provide and prove correct custom "cleaning" of the translation.'}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"verification",children:"Verification"}),"\n",(0,i.jsx)(t.p,{children:"Then comes the time of specifications and proofs."}),"\n",(0,i.jsxs)(t.p,{children:['The specification language can be the programming language itself, with some "assert", some specific language embedded as comments, or the formal language itself. Depending on the language you use, you will have different expressiveness. With more expressive languages, you can write more general properties like "this program never lets non-admins read admin data", leading to cleaner and hence potentially safer specifications. Theorem provers (',(0,i.jsx)(t.a,{href:"https://rocq-prover.org/",children:"Rocq"}),", ",(0,i.jsx)(t.a,{href:"https://leanprover.github.io/",children:"Lean"}),", ",(0,i.jsx)(t.a,{href:"https://isabelle.in.tum.de/",children:"Isabelle"}),") are the most expressive."]}),"\n",(0,i.jsx)(t.p,{children:'For the proof, the system either handles it automatically (SMT/model checking), at the cost of loop approximations sometimes, or timeouts when it is too complicated. Or you can help the system manually (theorem prover). It gives more control and removes the "magic" part of the system. It enables the verification of the most complex properties like cryptographic maths. The drawback is that you need to learn and use those languages.'}),"\n",(0,i.jsx)(t.p,{children:"At the end, you are 100% sure your code is correct for what you stated: you get a mathematical proof covering all possible entries. The correctness of what you state is up to the scope you consider (the more you verify, the better!) and the exhaustiveness of your specifications."}),"\n",(0,i.jsx)("figure",{children:(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Diagram",src:a(77405).A+"",width:"1320",height:"625"})})}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"Formal verification is often the combination of the two phases above, with quite different focuses but often similar complexity."}),"\n",(0,i.jsx)(t.p,{children:"We hope this helps you get a better understanding of what formal methods are and which techniques are best suited to your project."}),"\n",(0,i.jsxs)(t.p,{children:["Do you want to improve your processes by verifying your code? Discuss with us to know what is possible at ",(0,i.jsx)(t.a,{href:"mailto:contact@formal.land",children:"contact@formal.land"}),"."]}),"\n",(0,i.jsx)(t.admonition,{title:"Socials",type:"success",children:(0,i.jsxs)(t.p,{children:["Do not forget to follow us on ",(0,i.jsx)(t.a,{href:"https://x.com/FormalLand",children:"X"})," and ",(0,i.jsx)(t.a,{href:"https://fr.linkedin.com/company/formal-land",children:"LinkedIn"})," for more."]})})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},77405:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/diagram-e2a10ba370dad0d0ee01743418183acf.jpeg"},97668:(e,t,a)=>{a.d(t,{A:()=>i});const i=a.p+"assets/images/white-forest-4935d524d0043daf676bd04662ad429e.png"},28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>s});var i=a(96540);const n={},o=i.createContext(n);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);