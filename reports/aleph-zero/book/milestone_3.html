<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Milestone 3 - Aleph Zero - coq-of-rust and coq-of-solidity</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Aleph Zero - coq-of-rust and coq-of-solidity</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="milestone-3"><a class="header" href="#milestone-3">Milestone 3</a></h1>
<blockquote>
<p>Finishing the Tool and the Smart Contract</p>
</blockquote>
<p>This report details what we have done at <a href="https://formal.land/">ðŸŒ² Formal Land</a> for the third milestone of the formal verification project for the <a href="https://use.ink/">ink!</a> language of smart contracts for the <a href="https://alephzero.org/">Aleph Zero</a> blockchain, developing the formal verification tool <a href="https://github.com/formal-land/coq-of-rust">coq-of-rust</a>.</p>
<p>The goal of this milestone is, to quote the grant agreement:</p>
<blockquote>
<p>The tool which works in 95% of cases. Amount of cases is counted by examples from the
<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a> book. The tool should be
able to translate 95% of examples from the book. - Translate one smart contract mainly
with the created tool. Finish translation manually if needed. Postulate statements for
top-level functions of the translated contract. Prove 90% of statements. - One blog post
with clarifications of ongoing work. - Report. <strong>Duration 4 weeks</strong></p>
</blockquote>
<p>In this step, we take the analysis work that we have done for the previous milestone, and implement it to have a more reliable translation from the Rust language to Coq. This translation now covers a big part of the language, and is able to translate most of the standard library of Rust without modifications, for example.</p>
<h2 id="blog-posts"><a class="header" href="#blog-posts">Blog posts</a></h2>
<p>We have written four blog posts explaining what we have done:</p>
<ul>
<li><a href="https://formal.land/blog/2024/03/08/improvements-rust-translation-part-2">Improvements in the Rust translation to Coq, part 2</a></li>
<li><a href="https://formal.land/blog/3024/03/08/improvements-rust-translation-part-3">Improvements in the Rust translation to Coq, part 3</a></li>
<li><a href="https://formal.land/blog/2024/04/03/monadic-notation-for-rust-translation">Monadic notation for the Rust translation</a></li>
<li><a href="https://formal.land/blog/2024/04/26/translation-core-alloc-crates">Translation of the Rust's core and alloc crates</a></li>
</ul>
<p>In these blog posts, we explain what we have done to make the translation from Rust to Coq of <code>coq-of-rust</code> smoother. In a summary:</p>
<ul>
<li>We removed the types from the translation, as well as the requirement on the ordering of the definitions.</li>
<li>We added a better notation for the monadic code that we generate.</li>
<li>We integrated the translation of large parts of the Rust's standard library.</li>
</ul>
<p>Additionally, we presented the <code>coq-of-rust</code> project for the Ink! smart contracts in a lightning talk at the <a href="https://sites.google.com/view/rustverify2024">Rust Verification Workshop 2024</a> co-located with the ETAPS conference.</p>
<h2 id="changes-to-the-translation"><a class="header" href="#changes-to-the-translation">Changes to the translation</a></h2>
<p>The new translation of <code>coq-of-rust</code> integrates the changes that we proposed in the previous milestone, which was about "analyzing what to improve". The goal is to be able to translate almost any Rust projects, with minimal or no modifications. Here is an example of input Rust code:</p>
<pre><code class="language-rs">fn main() {
    println!("Hello World!");
}
</code></pre>
<p>We now translate it to:</p>
<pre><code class="language-coq">Definition main (Ï„ : list Ty.t) (Î± : list Value.t) : M :=
  match Ï„, Î± with
  | [], [] =&gt;
    ltac:(M.monadic
      (M.read (|
        let _ :=
          let _ :=
            M.alloc (|
              M.call_closure (|
                M.get_function (| "std::io::stdio::_print", [] |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_const", [] |),
                    [
                      (* Unsize *)
                      M.pointer_coercion
                        (M.alloc (| Value.Array [ M.read (| M.mk_str "Hello World!
" |) ] |))
                    ]
                  |)
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |) in
        M.alloc (| Value.Tuple [] |)
      |)))
  | _, _ =&gt; M.impossible
  end.
</code></pre>
<p>This translation is much more verbose, but also more reliable, than the translation that we used to have:</p>
<pre><code class="language-coq">Definition main : M unit :=
  let* _ : M.Val unit :=
    let* _ : M.Val unit :=
      let* Î±0 : ref str.t := M.read (mk_str "Hello World!
") in
      let* Î±1 : M.Val (array (ref str.t)) := M.alloc [ Î±0 ] in
      let* Î±2 : core.fmt.Arguments.t :=
        M.call
          (core.fmt.Arguments.t::["new_const"]
            (pointer_coercion "Unsize" (borrow Î±1))) in
      let* Î±3 : unit := M.call (std.io.stdio._print Î±2) in
      M.alloc Î±3 in
    M.alloc tt in
  let* Î±0 : M.Val unit := M.alloc tt in
  M.read Î±0.
</code></pre>
<p>We now quickly detail the changes, that were also presented in the previous milestone report as ongoing work.</p>
<h3 id="removal-of-the-types"><a class="header" href="#removal-of-the-types">Removal of the types</a></h3>
<p>We now translate all the Rust values to a single Coq type <code>Value.t</code> representing all Rust values that we have encountered:</p>
<pre><code class="language-coq">Module Value.
  Inductive t : Set :=
  | Bool : bool -&gt; t
  | Integer : Z -&gt; t
  | Float : string -&gt; t
  | UnicodeChar : Z -&gt; t
  | String : string -&gt; t
  | Tuple : list t -&gt; t
  | Array : list t -&gt; t
  | StructRecord : string -&gt; list (string * t) -&gt; t
  | StructTuple : string -&gt; list t -&gt; t
  | Pointer : Pointer.t t -&gt; t
  | Closure : {'(t, M) : Set * Set @ list t -&gt; M} -&gt; t
  | Error (message : string)
  | DeclaredButUndefined.
End Value.
</code></pre>
<p>Even if we then lose information in the translation process, this is actually helpful as:</p>
<ul>
<li>We have no type-checking errors anymore on the Coq side, as all values have the same type <code>Value.t</code>. The type inference mechanism of Coq was sometimes not working for some corner cases in the generated code, even when adding a lot of annotations. This was due, in particular, to the use of type-classes to represent traits.</li>
<li>We can represent arbitrarily complex recursive types as we now inject all the values to a single <code>Value.t</code> type. Mutually recursive types are generally complex to represent in Coq.</li>
<li>We do not need to order the definitions so that the types always appear before the values that use them. This was a big issue in the previous translation, as Rust does not require the definitions to be ordered. In addition, for some cases with interactions with traits combining methods and associated types, it was not even clear how to order the definitions.</li>
</ul>
<h3 id="removal-of-the-trait-constraints"><a class="header" href="#removal-of-the-trait-constraints">Removal of the trait constraints</a></h3>
<p>We removed the trait constraints on the parameters of the functions. This was a big issue in the previous translation, as we did not achieve a trait translation reliable enough to handle big examples. We now put the trait constraints in the rules of our semantics to evaluate Rust expressions. When calling a trait method, we check that there is a trait instance for a marker of the type of the <code>self</code> value. If there is no trait instance, the evaluation is stuck. These code examples should, anyway, not be reachable, as the type checker of Rust verifies that trait constraints are satisfied.</p>
<p>We add back the trait constraints as pre-conditions in the proofs, making sure that we do not reason about code that gets stuck. We will not be able to make progress in the proofs if we forget about one of the constraints.</p>
<h3 id="no-ordering-of-definitions"><a class="header" href="#no-ordering-of-definitions">No ordering of definitions</a></h3>
<p>When we call a function, whether it is a trait method or a plain function, we now use a special construct of our monad that is purely descriptive. The call of a function is its absolute name as a string. We also bind each function definition to its absolute string name.</p>
<p>We cannot evaluate the calls to the functions anymore using the native Coq evaluation. Instead, we use the semantics rules on our monad to state that a function named by its unique string can be replaced by its definition.</p>
<h3 id="translation-of-rusts-book-by-examples"><a class="header" href="#translation-of-rusts-book-by-examples">Translation of Rust's "Book By Examples"</a></h3>
<p>We now translate all the examples of the book to valid Coq code, even if for some features, such inlined assembly code, we generate a dummy term.</p>
<h2 id="changes-to-the-proofs"><a class="header" href="#changes-to-the-proofs">Changes to the proofs</a></h2>
<p>All the changes above made the translation of the code simpler, but our proofs more complicated. We summarize here what changes it implied.</p>
<h3 id="removal-of-the-types-1"><a class="header" href="#removal-of-the-types-1">Removal of the types</a></h3>
<p>Removing the type information from the generated code is probably the main change that made the proofs more complex. We use injection functions to translate the Coq types that we use in our specifications or simulations (<code>bool</code>, <code>Z</code>, <code>string</code>, <code>list</code>, ...) to their corresponding <code>Value.t</code> values.</p>
<p>This makes the specification about the validity of the simulations (simplified implementation of the code that we use to make our proofs) more verbose. In addition, it can sometimes be hard in the proofs to remember from which "high-level" type a value comes from. We are still working on this issue to find better automation, even if this is currently manageable.</p>
<p>The main change that we necessary to keep the complexity low was in the representation of pointers. We now keep track in each pointer of the injection used to go from the high-level type to the <code>Value.t</code> type. Thanks to this tracking, we can reason on a memory only composed of high-level types instead of <code>Value.t</code> values.</p>
<h3 id="removal-of-the-trait-constraints-1"><a class="header" href="#removal-of-the-trait-constraints-1">Removal of the trait constraints</a></h3>
<p>We now need an additional pre-condition on lemma talking about functions with trait constraints for the types. This constraint says that a certain type implements a trait, together with a proof linking it to a Coq typeclass instance. We give more details in the last section <a href="https://formal.land/blog/2024/03/22/improvements-rust-translation-part-3#traits">Traits</a> of one of our blog posts.</p>
<h3 id="no-ordering-of-definitions-1"><a class="header" href="#no-ordering-of-definitions-1">No ordering of definitions</a></h3>
<p>Each time there is a call to a function, an associated function for a type, or a trait method, we need to find at proof time which is the original definition. This is, for now, done manually by explicitly giving the Coq's name of the needed definition. We plan to automate this part as this is very repetitive, even if simple to do.</p>
<h2 id="support-of-the-standard-library"><a class="header" href="#support-of-the-standard-library">Support of the standard library</a></h2>
<p>Ink! smart contracts often make use of primitives from the standard library of Rust, like primitives to manipulate <code>Option</code> values. We were previously axiomatizing these primitives by hand in Coq. However, this is error-prone and time-consuming.</p>
<p>Instead, we are now able to leverage <code>coq-of-rust</code> to translate enough of the Rust standard library to use these definitions instead. This should represent less work for us in the long run, and we can be more confident that the definitions are correct.</p>
<p>We updated our current <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/examples/default/examples/ink_contracts/proofs/erc20.v">verification of the ERC-20 smart contract</a> to integrate all the changes above so that the specifications that we wrote are still verified.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>We have presented what we have implemented to improve the translation of <code>coq-of-rust</code> and make the tool much more reliable to translate Rust code to Coq without failing. We have also presented an update to our verification methodology to handle the new translation, as well as ported our verification of the ERC-20 smart contract to the new translation.</p>
<p>For the next milestone, we will verify four additional Ink! smart contracts using <code>coq-of-rust</code>, and continue to improve our proof methodology.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="milestone_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="milestone_4_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="milestone_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="milestone_4_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
