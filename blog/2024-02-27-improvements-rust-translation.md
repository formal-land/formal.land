---
title: Improvements in the Rust translation to Coq
tags: [coq-of-rust, Rust, Coq, translation]
authors: []
---

Our tool [coq-of-rust](https://github.com/formal-land/coq-of-rust) is translating Rust&nbsp;ü¶Ä programs to the proof system Coq&nbsp;üêì to do formal verification on Rust programs. Even if we are able to verify realistic code, such as as [ERC-20 smart contract](http://localhost:3000/blog/2023/12/13/rust-verify-erc-20-smart-contract), `coq-of-rust` still has some limitations:

- fragile trait handling
- difficulties to order the definitions, in their order of dependencies as required by Coq

We will present how we plan to improve our tool to address these limitations.

<!-- truncate -->

## Introduction

We will take the Rust [serde](https://github.com/serde-rs/serde) serialization library to have an example of code to translate in Coq. This is a popular Rust library that is used in almost all projects, either as a direct or transitive dependency. Serialization has a simple specification (being a bijection between the data and its serialized form) and is a good candidate for formal verification. We might verify this library afterwards if there is need.

:::tip Contact

You can [follow us on X](https://twitter.com/LandFoobar) to get our updates. We propose tools and services to make your codebase totally bug-free. Contact us at&nbsp;[&#099;&#111;&#110;&#116;&#097;&#099;&#116;&#064;formal&#046;&#108;&#097;&#110;&#100;](mailto:contact@formal.land) to chat! We offer a free audit to assess the feasibility of formal verification on your case.

:::

:::note Goal

Our company goal is to make formal verification accessible to all projects, reducing its cost to&nbsp;20% of the development cost. There should be no reason to have bugs in end-user products!

:::

## Warnings

We start by running the command:

```sh
cargo coq-of-rust
```

in the `serde` directory. We get a lot of warnings, but the translation does not panic as it tries to always produces something for debugging purposes. We have two kinds of warnings.

### Constants in patterns

The warning is the following:

```
warning: Constants in patterns are not yet supported.
    --> serde/src/de/mod.rs:2277:13
     |
2277 |             0 => panic!(), // special case elsewhere
     |             ^
```

The reason why we did not handle constants in patterns is that they are represented in a special format in the Rust compiler that was not obvious to handle. The definition of [rustc_middle::mir::consts::Const](https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/mir/consts/enum.Const.html) representing the constants in patterns is:

```rust
pub enum Const<'tcx> {
    Ty(Const<'tcx>),
    Unevaluated(UnevaluatedConst<'tcx>, Ty<'tcx>),
    Val(ConstValue<'tcx>, Ty<'tcx>),
}
```

There are three cases that each contains several more cases. To fix this issue, we added the code to handle the signed and unsigned integers, that are enough for our `serde` example. We will need to add other cases later, especially for the strings. This allowed us to discover and fix a bug in our handling of patterns for tuples with elision&nbsp;`..`, like in the example:

```rust
fn main() {
    let triple = (0, -2, 3);

    match triple {
        (0, y, z) => println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..) => println!("First is `1` and the rest doesn't matter"),
        (.., 2) => println!("last is `2` and the rest doesn't matter"),
        (3, .., 4) => println!("First is `3`, last is `4`, and the rest doesn't matter"),
        _ => println!("It doesn't matter what they are"),
    }
}
```

These changes are in the pull-request [coq-of-rust#470](https://github.com/formal-land/coq-of-rust/pull/470).

### Unimplemented `parent_kind`

We get a second form of warning:

```
unimplemented parent_kind: Struct
expression: Expr {
    kind: ZstLiteral {
        user_ty: None,
    },
    ty: FnDef(
        DefId(2:31137 ~ core[10bc]::cmp::Reverse::{constructor#0}),
        [
        T/#1,
        ],
    ),
    temp_lifetime: Some(
        Node(14),
    ),
    span: serde/src/de/impls.rs:778:22: 778:29 (#0),
}
```

This is for some cases of expressions [rustc_middle::thir::ExprKind::ZstLiteral](https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/thir/enum.ExprKind.html#variant.ZstLiteral) in the Rust's [THIR representation](https://rustc-dev-guide.rust-lang.org/thir.html) that we do no handle. If we look at the `span` field, we see that it appears in the source in the file `serde/src/de/impls.rs` at line 778:

```rust
forwarded_impl! {
    (T), Reverse<T>, Reverse // Here is the error
}
```

This is not very informative as this code is generated by a macro. Another similar kind of expression appears later:

```rust
impl<'de, T> Deserialize<'de> for Wrapping<T>
where
    T: Deserialize<'de>,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
      Deserialize::deserialize(deserializer).map(
          // Here is the error:
          Wrapping
      )
    }
}
```

The `Wrapping` term is the constructor of a structure, used as a function. We add the support of this case in the pull-request [coq-of-rust#471](https://github.com/formal-land/coq-of-rust/pull/471).

## Coq errors

When we type-check the generated Coq code we quickly get an error:

```coq
(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module lib.
  Module core.

  End core.
End lib.

Module macros.

End macros.

Module integer128.

End integer128.

Module de.
  Module value.
    Module  Error.
    Section Error.
      Record t : Set := {
        (* Here is the error: *)
        err : ltac:(serde.de.value.ErrorImpl);
      }.

      (* 180.000 more lines! *)
```

The reason is that here&nbsp;`serde.de.value.ErrorImpl` is not yet defined. In Coq we must order the definitions in the order of dependencies, to ensure that there are no non-terminating definitions with infinite recursive calls and preserve the consistency of the system.

This issue does not seem easy to us, as in a Rust crate everything can depend on each others:

- types
- definitions
- traits
- `impl` blocks

Our current solutions are:

1. **To reorder the definitions in the source Rust code**, so that they appear in the right order for Coq. This is technically the simplest solution (no changes in `coq-of-rust`), but not very practical. Indeed, reordering elements in a big project generates a lot of conflicts in the version control system, especially if we cannot upstream the changes to the original project.
2. **To use a configuration file** to specify the order of the definitions. This works in a lot of cases, but we need to write this file manually and have it complete to compile the whole crate in Coq, even if we are interested in verifying a small part of the code. There are also some cases that are hard to entangle, in particular with traits that can depend on both types and definitions, that themselves may depend on traits.

In order to handle large projects, such as `serde`, we need to find a more definitive solution to handle the order of dependencies.

## Plan for the order of definitions

Our idea is to use a more verbose, but simpler translation, to generate Coq code that is not sensitive to the ordering of Rust. In addition, we should have a more robust mechanism for the traits, as there are still some edge cases that we do not handle well.

Our main ingredients are:

1. Generating an untyped code, where all Rust values become part of a single and shared `Value` type. With this approach we can represent mutually recursive Rust types, that are generally hard to translate in a sound manner to Coq. We should also avoid a lot of errors on the Coq side related to type inference.
2. Adding an indirection level to all function calls, as any function call might refer to a definition that appears later in the code.

These ingredients have some drawbacks:

- By removing the types, we will obtain a code that is less readable. It might contain translation errors that will be harder to spot. We will need to add the types back during the specification of the code.
- We will need to add error cases corresponding to type errors at runtime, as we will not have the type system to ensure that functions expecting a certain type of value receive it. We know from the Rust type checker that these errors should not happen, but we will need to prove it in Coq.
- We will have to resolve the indirections in the calls at proof time, or with other mechanisms, that will be more complex than the current translation.
- We will still need to have a translation of the types (as values), to guide the inference of trait instances.

## Conclusion

If you are interested in this project, please contact us at&nbsp;[&#099;&#111;&#110;&#116;&#097;&#099;&#116;&#064;formal&#046;&#108;&#097;&#110;&#100;](mailto:contact@formal.land) or go to our [GitHub repository](https://github.com/formal-land/coq-of-rust) for `coq-of-rust`.
