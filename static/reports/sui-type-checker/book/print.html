<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Formal Verification of the Sui&#x27;s Move Implementation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Formal Verification of the Sui&#x27;s Move Implementation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In this document, we explain our work to formally verify the correctness of the <a href="https://github.com/move-language/move-sui">ü¶Ä¬†Rust implementation</a> of the <a href="https://sui.io/move">Move language</a> for the <a href="https://sui.io/">üíß¬†Sui blockchain</a>.</p>
<p>For now, we concentrate on the <em>type-checker</em> of the Move bytecode. Smart contracts are stored as Move bytecode on the blockchain, and several sanity checks are performed on the bytecode before it is executed. The type-checker is one of these checks, and the one that is the most involved.</p>
<div style="text-align: center; margin-bottom: 60px; margin-top: 60px;">
  <img src="./logo.svg" alt="Logo" width="250" />
</div>
<p>Here are some reference files:</p>
<ul>
<li>The type-checker <a href="https://github.com/move-language/move-sui/blob/main/crates/move-bytecode-verifier/src/type_safety.rs">move-bytecode-verifier/src/type_safety.rs</a></li>
<li>The interpreter of the Move bytecode <a href="https://github.com/move-language/move-sui/blob/main/crates/move-vm-runtime/src/interpreter.rs">move-vm-runtime/src/interpreter.rs</a></li>
<li>A README about the list of checks performed on the bytecode <a href="https://github.com/move-language/move-sui/tree/main/crates/move-bytecode-verifier">crates/move-bytecode-verifier/README.md</a></li>
</ul>
<h2 id="general-strategy"><a class="header" href="#general-strategy">General strategy</a></h2>
<p>We use the <a href="https://coq.inria.fr/">üêì¬†Coq</a> proof assistant for our formal verification effort.</p>
<p>With have the tool <a href="https://github.com/formal-land/coq-of-rust">coq-of-rust</a> which automatically translates Rust programs to Coq, but we are not using it for this project as the generated translation is too verbose. Typically, handling the details of the memory handling, interactions with the standard library, or the traits hierarchy represents too much work.</p>
<p>Instead we write a Coq translation by hand of the Rust code of:</p>
<ul>
<li>the type-checker and</li>
<li>the interpreter</li>
</ul>
<p>which we test as being equivalent to the Rust code on a set of test cases.</p>
<p>Then we verify the following property on the type-checker:</p>
<blockquote>
<p>Starting from a <code>stack</code> of a type <code>stack_ty</code>, if the function <code>verify_instr</code> of the type-checker is successful, then the function <code>execute_instruction</code> of the interpreter is also successful, with a resulting stack of the type returned by the type-checker.</p>
</blockquote>
<p>This is not everything we could check but it is a start. Ultimately, we will verify that:</p>
<blockquote>
<p>If the type-checker is successful, then the interpreter does not run with a critical error.</p>
</blockquote>
<p>To ensure this property, other checks such as the "stack safety" (analysis of the stack height) will be necessary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coq-translation"><a class="header" href="#coq-translation">Coq translation</a></h1>
<p>To get more information about our manual Coq translation of the Rust code of the type-checker and the interpreter of Move, you can read our following blog post: <a href="https://formal.land/blog/2024/10/14/verification-move-sui-type-checker-2">ü¶Ä Formal verification of the type checker of Sui ‚Äì part 2</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>To know more about how we verify that our translation of the Rust code of the type-checker in Coq is equivalent to the original code by testing, you can read our blog post <a href="https://formal.land/blog/2024/10/15/verification-move-sui-type-checker-3">ü¶Ä Formal verification of the type checker of Sui ‚Äì part 3</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification"><a class="header" href="#verification">Verification</a></h1>
<p>We are currently working on the formal verification of the type checker of the Move bytecode. Here is a blog post explaining the verification of a specific sub-function: <a href="https://formal.land/blog/2024/11/14/sui-move-checker-abstract-stack">ü¶Ä Example of verification for the Move's checker of Sui</a>.</p>
<p>We are focusing on the following property, that we verify for each kind of instruction of the Move bytecode:</p>
<blockquote>
<p>Starting from a <code>stack</code> of a type <code>stack_ty</code>, if the function <code>verify_instr</code> of the type-checker is successful, then the function <code>execute_instruction</code> of the interpreter is also successful, with a resulting stack of the type returned by the type-checker.</p>
</blockquote>
<h2 id="relevant-files"><a class="header" href="#relevant-files">Relevant files</a></h2>
<p>We have put all of our work in the <a href="https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/move_sui">CoqOfRust/move_sui</a> folder, with the two following sub-folders that are of interest:</p>
<ul>
<li><a href="https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/move_sui/simulations">simulations</a> This defines a Rocq version of the Rust code of the Move interpreter and type-checker.</li>
<li><a href="https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/move_sui/proofs">proofs</a> The gives the specifications and proofs we have made of the simulations.</li>
</ul>
<p>The folder <a href="https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/move_sui/translations">translations</a> is generated and not used here, and the folder <a href="https://github.com/formal-land/coq-of-rust/tree/main/CoqOfRust/move_sui/links">links</a>.</p>
<p>With the Rocq file names with follow the names of the Rust files of the Move's implementation:</p>
<ul>
<li>The main function of the type-checker <code>verify_instr</code> is defined <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/simulations/move_bytecode_verifier/type_safety.v">simulations/move_bytecode_verifier/type_safety.v</a>.</li>
<li>The main function of the interpreter <code>execute_instruction</code> is defined in <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/simulations/move_vm_runtime/interpreter.v">simulations/move_vm_runtime/interpreter.v</a>.</li>
<li>The main verified statement about the type-checker is the lemma <code>progress</code> in <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/proofs/move_bytecode_verifier/type_safety.v">proofs/move_bytecode_verifier/type_safety.v</a>. There is also the lemma <code>verify_instr_is_valid</code> in it to show that the output of the type-checker is well-shaped.</li>
<li>In the file <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/proofs/move_abstract_stack/lib.v">proofs/move_abstract_stack/lib.v</a> we group the proofs about the abstract stack used in the type-checker to represent the stack of types in a compact manner.</li>
</ul>
<h2 id="verification-of-the-abstract-stack"><a class="header" href="#verification-of-the-abstract-stack">Verification of the abstract stack</a></h2>
<p>A first thing we formally verified is the abstract stack:</p>
<ul>
<li>The Rust definition is in <a href="https://github.com/move-language/move-sui/blob/main/crates/move-abstract-stack/src/lib.rs">move-abstract-stack/src/lib.rs</a>.</li>
<li>The Rocq simulations are in <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/simulations/move_abstract_stack/lib.v">simulations/move_abstract_stack/lib.v</a>.</li>
<li>The verifications are in <a href="https://github.com/formal-land/coq-of-rust/blob/main/CoqOfRust/move_sui/proofs/move_abstract_stack/lib.v">proofs/move_abstract_stack/lib.v</a>.</li>
</ul>
<p>In Rust, the abstract stack is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AbstractStack&lt;T&gt; {
    values: Vec&lt;(u64, T)&gt;,
    len: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>The field <code>len</code> must always be equal to the number of elements in the stack. To avoid repetitions, each element comes with a number <code>u64</code> indicating the number of times it is repeated.</p>
<p>For each of the stack operations, we check that:</p>
<ul>
<li>The <code>len</code> field is always correct.</li>
<li>The stack behaves as if we were applying the normal stack operations push/pop on the stack of values when we repeat the same values multiple times.</li>
</ul>
<p>As an example, here is the statement for <code>push_n</code> that adds <code>n</code> times the same value to the stack:</p>
<pre><code class="language-coq">Lemma check_push_n {A : Set} `{Eq.Trait A} (item : A) (n : Z) (stack : AbstractStack.t A)
    (H_Eq : Eq.Valid.t (fun _ =&gt; True))
    (H_n : Integer.Valid.t IntegerKind.U64 n)
    (H_stack : AbstractStack.Valid.t stack) :
  match AbstractStack.push_n item n stack with
  | Panic.Value (Result.Ok tt, stack') =&gt;
    AbstractStack.Valid.t stack' /\
    flatten stack' = List.repeat item (Z.to_nat n) ++ flatten stack
    | Panic.Value (Result.Err _, stack') =&gt;
    stack' = stack
  | _ =&gt; True
  end.
</code></pre>
<p>For context, the type of the Rust code is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn push_n(&amp;mut self, item: T, n: u64) -&gt; Result&lt;(), AbsStackError&gt;
<span class="boring">}</span></code></pre></pre>
<p>It says that:</p>
<ul>
<li>If the <code>AbstractStack.push_n</code> operation succeeds then:
<ul>
<li>The resulting <code>len</code> is accurate (<code>AbstractStack.Valid.t stack'</code>).</li>
<li>The resulting stack, once flattened to duplicate all the repeated elements, is the concatenation of the previous stack with <code>n</code> times the same value <code>item</code> added on top.</li>
</ul>
</li>
<li>If the operation fails, then the stack is unchanged.</li>
</ul>
<h2 id="first-formal-statement-for-the-type-checker"><a class="header" href="#first-formal-statement-for-the-type-checker">First formal statement for the type-checker</a></h2>
<p>Here is our initial formal statement of the validity of the type-checker:</p>
<pre><code class="language-coq">Lemma progress
    (* [...] The list of parameters and properties stating that they are correct *)
    (H_of_type : IsInterpreterContextOfType.t locals interpreter type_safety_checker)
  match
    verify_instr instruction pc type_safety_checker,
    execute_instruction ty_args function resolver instruction state
  with
  | Panic.Value (Result.Ok _, type_safety_checker'),
    Panic.Value (Result.Ok _, state') =&gt;
    let '{|
      State.pc := _;
      State.locals := locals';
      State.interpreter := interpreter';
    |} := state' in
    IsInterpreterContextOfType.t locals' interpreter' type_safety_checker'
  | Panic.Value (Result.Ok _, _), Panic.Panic _ =&gt; False
  | Panic.Value (Result.Ok _, _), Panic.Value (Result.Err error, _) =&gt;
    let '{| PartialVMError.major_status := major_status |} := error in
    match major_status with
    | StatusCode.EXECUTION_STACK_OVERFLOW
    | StatusCode.ARITHMETIC_ERROR =&gt; True
    | _ =&gt; False
    end
  | Panic.Panic _, _ | Panic.Value (Result.Err _, _), _ =&gt; True
  end.
</code></pre>
<p>We compare the results of <code>verify_instr</code> and <code>execute_instruction</code>, which are the functions to type-check and execute an instruction, respectively. With the hypothesis <code>H_type</code>, we assume that we start with state (composed of a stack and local variables) of types given in <code>type_safety_checker</code>.</p>
<p>In case of success of both the type-checker and the interpreter, we get a new state and a new set of types that are matching.</p>
<p>If the type-checker fails, either with a panic or an explicit error, we consider that the interpreter can return any result.</p>
<p>If the type-checker returns a success and the interpreter fails, we state that it can only fail with an explicit error taken from a white list, and no panics.</p>
<h2 id="updated-formal-statement"><a class="header" href="#updated-formal-statement">Updated formal statement</a></h2>
<p>While doing the proof, we realized that there are many cases when the interpreter can possibly fail with an explicit error. For example, by calling twice <code>Bytecode::MoveLoc</code> on the same local variable. We decided to then only show that panics of the interpreter are not possible if the type-checker succeeds, and that the next state is well-typed in case of success.</p>
<p>Here is the new formal statement:</p>
<pre><code class="language-coq">match
  verify_instr instruction pc type_safety_checker,
  execute_instruction ty_args function resolver instruction state
with
| Panic.Value (Result.Ok _, type_safety_checker'),
  Panic.Value (Result.Ok _, state') =&gt;
  let '{|
    State.pc := _;
    State.locals := locals';
    State.interpreter := interpreter';
  |} := state' in
  IsInterpreterContextOfType.t locals' interpreter' type_safety_checker'
| Panic.Value (Result.Ok _, _), Panic.Panic _ =&gt; False
| Panic.Value (Result.Ok _, _), Panic.Value (Result.Err _, _)
| Panic.Value (Result.Err _, _), _
| Panic.Panic _, _ =&gt; True
end.
</code></pre>
<p>This is the same as before, but with a simpler model to handle the errors: we handle any execution errors except panics.</p>
<h3 id="loc-operations"><a class="header" href="#loc-operations">Loc operations</a></h3>
<p>For the instructions to manipulate the local variables (<code>CopyLoc</code>, <code>MoveLoc</code>, and <code>StLoc</code>):</p>
<ul>
<li>We axiomatized some of the operations as they are doing operations too low-level for our Rocq model, such as calling the Rust function <code>std::mem::replace</code>.</li>
<li>We also axiomatized some of their properties by lack of time.</li>
</ul>
<h3 id="call-operations"><a class="header" href="#call-operations">Call operations</a></h3>
<p>These are the two instructions <code>Call</code> and <code>CallGeneric</code>. They do not modify anything on the interpreter side and immediately return. However, on the type-checker side, they check the type of function parameters which are supposed to be on the top of the stack, and push the type of the results. We do not handle this kind of operation in our statement (final node in the control flow graph) and instead add them in a black-list of final operations which we do not cover.</p>
<h3 id="packunpack-operations"><a class="header" href="#packunpack-operations">Pack/unpack operations</a></h3>
<p>The <code>Pack</code> and <code>PackGeneric</code> instructions pop a list of fields from the stack and push the resulting structure. The <code>Unpack</code> and <code>UnpackGeneric</code> instructions do the opposite. We do not handle these operations yet in our proof.</p>
<h2 id="issues-in-our-translation"><a class="header" href="#issues-in-our-translation">Issues in our translation</a></h2>
<p>Here is the list of issues we found in our translation of the Move implementation to the Coq language. The code was correctly working in Rust. We found these issues despite the fact that we have a test suite for the type-checker, to compare the results of the Rust and Coq implementations.</p>
<h3 id="typing-of-bytecodecastu256"><a class="header" href="#typing-of-bytecodecastu256">Typing of <code>Bytecode::CastU256</code></a></h3>
<p>We were returning the type <code>SignatureToken.U64</code> instead of <code>SignatureToken.U256</code>.</p>
<h2 id="to-investigate-more"><a class="header" href="#to-investigate-more">To investigate more</a></h2>
<h3 id="deprecated-opcodes"><a class="header" href="#deprecated-opcodes">Deprecated opcodes</a></h3>
<p>There is a list of deprecated opcodes:</p>
<ul>
<li><code>MutBorrowGlobalDeprecated</code></li>
<li><code>ImmBorrowGlobalDeprecated</code></li>
<li><code>MutBorrowGlobalGenericDeprecated</code></li>
<li><code>ImmBorrowGlobalGenericDeprecated</code></li>
<li><code>ExistsDeprecated</code></li>
<li><code>ExistsGenericDeprecated</code></li>
<li><code>MoveFromDeprecated</code></li>
<li><code>MoveFromGenericDeprecated</code></li>
<li><code>MoveToDeprecated</code></li>
<li><code>MoveToGenericDeprecated</code></li>
</ul>
<p>In the type-checker we check these instructions as if they were still valid. On the interpreter side, we have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unreachable!("Global bytecodes deprecated")
<span class="boring">}</span></code></pre></pre>
<p>which would make a panic at execution time in case it is possible to load this kind of bytecode.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
